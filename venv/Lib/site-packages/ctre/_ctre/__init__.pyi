import ctre._ctre
import typing
import CANifier
import PigeonIMU
import wpilib._wpilib
import wpilib.interfaces._interfaces

__all__ = [
    "AbsoluteSensorRange",
    "AbsoluteSensorRangeRoutines",
    "BaseMotorController",
    "BaseMotorControllerConfiguration",
    "BaseMotorControllerUtil",
    "BasePIDSetConfiguration",
    "BaseTalon",
    "BaseTalonConfigUtil",
    "BaseTalonConfiguration",
    "BaseTalonPIDSetConfigUtil",
    "BaseTalonPIDSetConfiguration",
    "BufferedTrajectoryPointStream",
    "CANBusAddressable",
    "CANCoder",
    "CANCoderConfigUtils",
    "CANCoderConfiguration",
    "CANCoderFaults",
    "CANCoderStatusFrame",
    "CANCoderStickyFaults",
    "CANifier",
    "CANifierConfigUtils",
    "CANifierConfiguration",
    "CANifierControlFrame",
    "CANifierFaults",
    "CANifierStatusFrame",
    "CANifierStickyFaults",
    "CANifierVelocityMeasPeriod",
    "CANifierVelocityMeasPeriodRoutines",
    "ControlFrame",
    "ControlFrameEnhanced",
    "ControlFrameRoutines",
    "ControlMode",
    "CustomParamConfigUtil",
    "CustomParamConfiguration",
    "DemandType",
    "ErrorCode",
    "Faults",
    "FeedbackDevice",
    "FeedbackDeviceRoutines",
    "FilterConfigUtil",
    "FilterConfiguration",
    "FollowerType",
    "IFollower",
    "IMotorController",
    "IMotorControllerEnhanced",
    "InvertType",
    "LimitSwitchNormal",
    "LimitSwitchRoutines",
    "LimitSwitchSource",
    "MagnetFieldStrength",
    "MotionProfileStatus",
    "MotorCommutation",
    "NeutralMode",
    "Orchestra",
    "ParamEnum",
    "PigeonIMU",
    "PigeonIMUConfigUtils",
    "PigeonIMUConfiguration",
    "PigeonIMU_ControlFrame",
    "PigeonIMU_Faults",
    "PigeonIMU_StatusFrame",
    "PigeonIMU_StickyFaults",
    "RemoteFeedbackDevice",
    "RemoteLimitSwitchSource",
    "RemoteSensorSource",
    "RemoteSensorSourceRoutines",
    "SensorCollection",
    "SensorInitializationStrategy",
    "SensorInitializationStrategyRoutines",
    "SensorTerm",
    "SensorTermRoutines",
    "SensorTimeBase",
    "SensorTimeBaseRoutines",
    "SensorVelocityMeasPeriod",
    "SensorVelocityMeasPeriodRoutines",
    "SetValueMotionProfile",
    "SlotConfigUtil",
    "SlotConfiguration",
    "StatorCurrentLimitConfiguration",
    "StatusFrame",
    "StatusFrameEnhanced",
    "StatusFrameRoutines",
    "StickyFaults",
    "SupplyCurrentLimitConfiguration",
    "TalonFX",
    "TalonFXConfigUtil",
    "TalonFXConfiguration",
    "TalonFXControlMode",
    "TalonFXFeedbackDevice",
    "TalonFXInvertType",
    "TalonFXPIDSetConfiguration",
    "TalonFXSensorCollection",
    "TalonSRX",
    "TalonSRXConfigUtil",
    "TalonSRXConfiguration",
    "TalonSRXControlMode",
    "TalonSRXFeedbackDevice",
    "TalonSRXPIDSetConfiguration",
    "TrajectoryPoint",
    "VelocityMeasPeriod",
    "VelocityMeasPeriodRoutines",
    "VictorConfigUtil",
    "VictorSPX",
    "VictorSPXConfiguration",
    "VictorSPXControlMode",
    "VictorSPXPIDSetConfigUtil",
    "VictorSPXPIDSetConfiguration",
    "WPI_BaseMotorController",
    "WPI_TalonFX",
    "WPI_TalonSRX",
    "WPI_VictorSPX"
]


class AbsoluteSensorRange():
    """
    Enum for how to range the absolute sensor position.

    Members:

      Unsigned_0_to_360 : Express the absolute position as an unsigned value.
    E.g. [0,+1) rotations or [0,360) deg.

      Signed_PlusMinus180 : Express the absolute position as an signed value.
    E.g. [-0.5,+0.5) rotations or [-180,+180) deg.
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Signed_PlusMinus180: ctre._ctre.AbsoluteSensorRange # value = AbsoluteSensorRange.Signed_PlusMinus180
    Unsigned_0_to_360: ctre._ctre.AbsoluteSensorRange # value = AbsoluteSensorRange.Unsigned_0_to_360
    __members__: dict # value = {'Unsigned_0_to_360': AbsoluteSensorRange.Unsigned_0_to_360, 'Signed_PlusMinus180': AbsoluteSensorRange.Signed_PlusMinus180}
    pass
class AbsoluteSensorRangeRoutines():
    """
    Class to handle routines specific to AbsoluteSensorRange
    """
    def __init__(self) -> None: ...
    @staticmethod
    def toString(value: AbsoluteSensorRange) -> str: 
        """
        String representation of specified AbsoluteSensorRange

        :param value: AbsoluteSensorRange to convert to a string

        :returns: string representation of AbsoluteSensorRange
        """
    pass
class IFollower():
    """
    Interface for followers
    """
    def __init__(self) -> None: ...
    def follow(self, masterToFollow: IMotorController) -> None: 
        """
        Set the control mode and output value so that this motor controller will
        follow another motor controller. Currently supports following Victor SPX
        and Talon SRX.

        :param masterToFollow: Motor Controller object to follow.
        """
    def valueUpdated(self) -> None: 
        """
        When master makes a device, this routine is called to signal the update.
        """
    pass
class CustomParamConfiguration():
    """
    Configurables for any custom param configs
    """
    def __init__(self) -> None: ...
    @typing.overload
    def toString(self) -> str: 
        """
        :returns: string representation of currently selected configs



        :param prependString: String to prepend to all the configs

        :returns: string representation fo currently selected configs
        """
    @typing.overload
    def toString(self, prependString: str) -> str: ...
    @property
    def customParam0(self) -> int:
        """
        Custom Param 0

        :type: int
        """
    @customParam0.setter
    def customParam0(self, arg0: int) -> None:
        """
        Custom Param 0
        """
    @property
    def customParam1(self) -> int:
        """
        Custom Param 1

        :type: int
        """
    @customParam1.setter
    def customParam1(self, arg0: int) -> None:
        """
        Custom Param 1
        """
    @property
    def enableOptimizations(self) -> bool:
        """
        Enable optimizations for ConfigAll (defaults true)

        :type: bool
        """
    @enableOptimizations.setter
    def enableOptimizations(self, arg0: bool) -> None:
        """
        Enable optimizations for ConfigAll (defaults true)
        """
    pass
class CustomParamConfigUtil():
    """
    Util class to help custom configs
    """
    def __init__(self) -> None: ...
    @staticmethod
    def customParam0Different(settings: CustomParamConfiguration) -> bool: 
        """
        :param settings: Settings to compare against

        :returns: Whether CustomParam0 is different
        """
    @staticmethod
    def customParam1Different(settings: CustomParamConfiguration) -> bool: 
        """
        :param settings: Settings to compare against

        :returns: Whether CustomParam1 is different
        """
    pass
class BasePIDSetConfiguration():
    """
    Base set of configurables related to PID
    """
    def __init__(self) -> None: ...
    @typing.overload
    def toString(self) -> str: 
        """
        :returns: String representation of configs



        :param prependString: String to prepend to configs

        :returns: String representation of configs
        """
    @typing.overload
    def toString(self, prependString: str) -> str: ...
    @property
    def selectedFeedbackCoefficient(self) -> float:
        """
        Feedback coefficient of selected sensor

        :type: float
        """
    @selectedFeedbackCoefficient.setter
    def selectedFeedbackCoefficient(self, arg0: float) -> None:
        """
        Feedback coefficient of selected sensor
        """
    pass
class IMotorController(IFollower):
    """
    Interface for motor controllers
    """
    def changeMotionControlFramePeriod(self, periodMs: int) -> ErrorCode: 
        """
        Calling application can opt to speed up the handshaking between the robot
        API and the controller to increase the download rate of the controller's Motion
        Profile. Ideally the period should be no more than half the period of a
        trajectory point.

        :param periodMs: The transmit period in ms.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def clearMotionProfileHasUnderrun(self, timeoutMs: int = 0) -> ErrorCode: 
        """
        Clear the "Has Underrun" flag. Typically this is called after application
        has confirmed an underrun had occured.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def clearMotionProfileTrajectories(self) -> ErrorCode: 
        """
        Clear the buffered motion profile in both controller's RAM (bottom), and in the
        API (top).

        :returns: Error Code generated by function. 0 indicates no error
        """
    def clearStickyFaults(self, timeoutMs: int = 0) -> ErrorCode: 
        """
        Clears all sticky faults.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.

        :returns: Last Error Code generated by a function.
        """
    def configAllowableClosedloopError(self, slotIdx: int, allowableCloseLoopError: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the allowable closed-loop error in the given parameter slot.

        :param slotIdx:        Parameter slot for the constant.

        :param allowableCloseLoopError: Value of the allowable closed-loop error in sensor units (or sensor units per 100ms for velocity).

        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configAuxPIDPolarity(self, invert: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the Polarity of the Auxiliary PID (PID1).

        Standard Polarity:
        Primary Output = PID0 + PID1,
        Auxiliary Output = PID0 - PID1,

        Inverted Polarity:
        Primary Output = PID0 - PID1,
        Auxiliary Output = PID0 + PID1,

        :param invert: If true, use inverted PID1 output polarity.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.

        :returns: Error Code
        """
    def configClearPositionOnLimitF(self, clearPositionOnLimitF: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Enables clearing the position of the feedback sensor when the forward
        limit switch is triggered

        :param clearPositionOnLimitF: Whether clearing is enabled, defaults false

        :param timeoutMs:    Timeout value in ms. If nonzero, function will wait for
                             config success and report an error if it times out.
                             If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnLimitR(self, clearPositionOnLimitR: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Enables clearing the position of the feedback sensor when the reverse
        limit switch is triggered

        :param clearPositionOnLimitR: Whether clearing is enabled, defaults false

        :param timeoutMs:    Timeout value in ms. If nonzero, function will wait for
                             config success and report an error if it times out.
                             If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnQuadIdx(self, clearPositionOnQuadIdx: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Enables clearing the position of the feedback sensor when the quadrature index signal
        is detected

        :param clearPositionOnQuadIdx: Whether clearing is enabled, defaults false

        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.
                              If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClosedLoopPeakOutput(self, slotIdx: int, percentOut: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the peak closed-loop output.  This peak output is slot-specific and
        is applied to the output of the associated PID loop.
        This setting is seperate from the generic Peak Output setting.

        :param slotIdx: Parameter slot for the constant.

        :param percentOut: Peak Percent Output from 0 to 1.  This value is absolute and
                  the magnitude will apply in both forward and reverse directions.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClosedLoopPeriod(self, slotIdx: int, loopTimeMs: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the loop time (in milliseconds) of the PID closed-loop calculations.
        Default value is 1 ms.

        :param slotIdx: Parameter slot for the constant.

        :param loopTimeMs: Loop timing of the closed-loop calculations.  Minimum value of
                  1 ms, maximum of 64 ms.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClosedloopRamp(self, secondsFromNeutralToFull: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the closed-loop ramp rate of throttle output.

        :param secondsFromNeutralToFull: Minimum desired time to go from neutral to full throttle. A
                                value of '0' will disable the ramp.

        :param timeoutMs:       Timeout value in ms. If nonzero, function will wait for
                                config success and report an error if it times out.
                                If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configFactoryDefault(self, timeout: int) -> ErrorCode: 
        """
        Revert all configurations to factory default values.
        Use this before your individual config* calls to avoid having to config every single param.

        Alternatively you can use the configAllSettings routine.

        :param timeout: Timeout value in ms. Function will generate error if config is
               not successful within timeout.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configFeedbackNotContinuous(self, feedbackNotContinuous: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Disables continuous tracking of the position for analog and pulse-width.
        If the signal goes from 4095 to 0 (pulse-width) a motor controller will continue to read 4096 by default.
        If overflow tracking is disabled, it will wrap to 0 (not continuous)

        If using pulse-width on CTRE Mag Encoder (within one rotation) or absolute analog sensor (within one rotation),
        setting feedbackNotContinuous to true is recommended, to prevent intermittent
        connections from causing sensor "jumps" of 4096 (or 1024 for analog) units.

        :param feedbackNotContinuous: True to disable the overflow tracking.

        :param timeoutMs:    Timeout value in ms. If nonzero, function will wait for
                             config success and report an error if it times out.
                             If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configForwardLimitSwitchSource(self, type: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-F pin of another Talon
        or CANifier.

        :param type:     Remote limit switch source. User can choose between a remote
                         Talon SRX, CANifier, or deactivate the feature.

        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                         setting matches the Phoenix Tuner drop down.

        :param deviceID: Device ID of remote source (Talon SRX or CANifier device ID).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                         success and report an error if it times out. If zero, no
                         blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configForwardSoftLimitEnable(self, enable: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward soft limit enable.

        :param enable: Forward Sensor Position Limit Enable.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configForwardSoftLimitThreshold(self, forwardSensorLimit: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward soft limit threhold.

        :param forwardSensorLimit: Forward Sensor Position Limit (in raw sensor units).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configGetCustomParam(self, paramIndex: int, timeoutMs: int = 0) -> int: 
        """
        Gets the value of a custom parameter.

        :param paramIndex: Index of custom parameter [0,1].

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                  success and report an error if it times out. If zero, no
                  blocking or checking is performed.

        :returns: Value of the custom param.
        """
    def configGetParameter(self, paramEnum: ParamEnum, ordinal: int, timeoutMs: int = 0) -> float: 
        """
        Gets a parameter.

        :param paramEnum: Parameter enumeration.

        :param ordinal: Ordinal of parameter.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Value of parameter.
        """
    def configLimitSwitchDisableNeutralOnLOS(self, limitSwitchDisableNeutralOnLOS: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Disables limit switches triggering (if enabled) when the sensor is no longer detected.

        :param limitSwitchDisableNeutralOnLOS: disable triggering

        :param timeoutMs:             Timeout value in ms. If nonzero, function will wait for
                                      config success and report an error if it times out.
                                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMaxIntegralAccumulator(self, slotIdx: int, iaccum: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the maximum integral accumulator in the given parameter slot.

        :param slotIdx: Parameter slot for the constant.

        :param iaccum: Value of the maximum integral accumulator (closed loop error
                 units X 1ms).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionAcceleration(self, sensorUnitsPer100msPerSec: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the Motion Magic Acceleration. This is the target acceleration that
        the motion magic curve generator can use.

        :param sensorUnitsPer100msPerSec: Motion Magic Acceleration (in raw sensor units per 100 ms per
                                 second).

        :param timeoutMs:        Timeout value in ms. If nonzero, function will wait for config
                                 success and report an error if it times out. If zero, no
                                 blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionCruiseVelocity(self, sensorUnitsPer100ms: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the Motion Magic Cruise Velocity. This is the peak target velocity
        that the motion magic curve generator can use.

        :param sensorUnitsPer100ms: Motion Magic Cruise Velocity (in raw sensor units per 100 ms).

        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for config
                           success and report an error if it times out. If zero, no
                           blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionProfileTrajectoryPeriod(self, baseTrajDurationMs: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        When trajectory points are processed in the motion profile executer, the MPE determines
        how long to apply the active trajectory point by summing baseTrajDurationMs with the
        timeDur of the trajectory point (see TrajectoryPoint).

        This allows general selection of the execution rate of the points with 1ms resolution,
        while allowing some degree of change from point to point.

        :param baseTrajDurationMs: The base duration time of every trajectory point.
                          This is summed with the trajectory points unique timeDur.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionSCurveStrength(self, curveStrength: int, timeoutMs: int) -> ErrorCode: 
        """
        Sets the Motion Magic S Curve Strength.
        Call this before using Motion Magic.
        Modifying this during a Motion Magic action should be avoided.

        :param curveStrength: 0 to use Trapezoidal Motion Profile. [1,8] for S-Curve (greater value yields greater smoothing).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                     success and report an error if it times out. If zero, no
                     blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configNeutralDeadband(self, percentDeadband: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the output deadband percentage.

        :param percentDeadband: Desired deadband percentage. Minimum is 0.1%, Maximum is 25%.
                       Pass 0.04 for 4% (factory default).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                       config success and report an error if it times out.
                       If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configNominalOutputForward(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward nominal output percentage.

        :param percentOut: Nominal (minimum) percent output. [0,+1]

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configNominalOutputReverse(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse nominal output percentage.

        :param percentOut: Nominal (minimum) percent output. [-1,0]

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configOpenloopRamp(self, secondsFromNeutralToFull: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the open-loop ramp rate of throttle output.

        :param secondsFromNeutralToFull: Minimum desired time to go from neutral to full throttle. A
                                value of '0' will disable the ramp.

        :param timeoutMs:       Timeout value in ms. If nonzero, function will wait for
                                config success and report an error if it times out.
                                If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPeakOutputForward(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward peak output percentage.

        :param percentOut: Desired peak output percentage. [0,1]

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPeakOutputReverse(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse peak output percentage.

        :param percentOut: Desired peak output percentage.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPulseWidthPeriod_EdgesPerRot(self, pulseWidthPeriod_EdgesPerRot: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the edges per rotation of a pulse width sensor. (This should be set for
        tachometer use).

        :param pulseWidthPeriod_EdgesPerRot: edges per rotation

        :param timeoutMs:           Timeout value in ms. If nonzero, function will wait for
                                    config success and report an error if it times out.
                                    If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPulseWidthPeriod_FilterWindowSz(self, pulseWidthPeriod_FilterWindowSz: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the number of samples to use in smoothing a pulse width sensor with a rolling
        average. Default is 1 (no smoothing).

        :param pulseWidthPeriod_FilterWindowSz: samples for rolling avg

        :param timeoutMs:              Timeout value in ms. If nonzero, function will wait for
                                       config success and report an error if it times out.
                                       If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configRemoteFeedbackFilter(self, canCoderRef: CANCoder, remoteOrdinal: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
        After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
        as a PID source for closed-loop features.

        :param deviceID:  The device ID of the remote sensor device.

        :param remoteSensorSource: The remote sensor device and signal type to bind.

        :param remoteOrdinal: 0 for configuring Remote Sensor 0,
                          1 for configuring Remote Sensor 1

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
        After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
        as a PID source for closed-loop features.

        :param canCoderRef: CANCoder device reference to use.

        :param remoteOrdinal: 0 for configuring Remote Sensor 0,
                     1 for configuring Remote Sensor 1

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                     config success and report an error if it times out.
                     If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configRemoteFeedbackFilter(self, deviceID: int, remoteSensorSource: RemoteSensorSource, remoteOrdinal: int, timeoutMs: int = 0) -> ErrorCode: ...
    def configRemoteSensorClosedLoopDisableNeutralOnLOS(self, remoteSensorClosedLoopDisableNeutralOnLOS: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Disables going to neutral (brake/coast) when a remote sensor is no longer detected.

        :param remoteSensorClosedLoopDisableNeutralOnLOS: disable going to neutral

        :param timeoutMs:                        Timeout value in ms. If nonzero, function will wait for
                                                 config success and report an error if it times out.
                                                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configReverseLimitSwitchSource(self, type: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-R pin of another Talon
        or CANifier.

        :param type:     Remote limit switch source. User can choose between a remote
                         Talon SRX, CANifier, or deactivate the feature.

        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                         setting matches the Phoenix Tuner drop down.

        :param deviceID: Device ID of remote source (Talon SRX or CANifier device ID).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                         success and report an error if it times out. If zero, no
                         blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configReverseSoftLimitEnable(self, enable: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse soft limit enable.

        :param enable: Reverse Sensor Position Limit Enable.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configReverseSoftLimitThreshold(self, reverseSensorLimit: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse soft limit threshold.

        :param reverseSensorLimit: Reverse Sensor Position Limit (in raw sensor units).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSelectedFeedbackCoefficient(self, coefficient: float, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: 
        """
        The Feedback Coefficient is a scalar applied to the value of the
        feedback sensor.  Useful when you need to scale your sensor values
        within the closed-loop calculations.  Default value is 1.

        Selected Feedback Sensor register in firmware is the decoded sensor value
        multiplied by the Feedback Coefficient.

        :param coefficient: Feedback Coefficient value.  Maximum value of 1.
                   Resolution is 1/(2^16).  Cannot be 0.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                   config success and report an error if it times out.
                   If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: 
        """
        Select the remote feedback device for the motor controller.
        Most CTRE CAN motor controllers will support remote sensors over CAN.

        :param feedbackDevice: Remote Feedback Device to select.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                      config success and report an error if it times out.
                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSensorTerm(self, sensorTerm: SensorTerm, feedbackDevice: FeedbackDevice, timeoutMs: int = 0) -> ErrorCode: 
        """
        Select what sensor term should be bound to switch feedback device.
        Sensor Sum = Sensor Sum Term 0 - Sensor Sum Term 1
        Sensor Difference = Sensor Diff Term 0 - Sensor Diff Term 1
        The four terms are specified with this routine.  Then Sensor Sum/Difference
        can be selected for closed-looping.

        :param sensorTerm: Which sensor term to bind to a feedback source.

        :param feedbackDevice: The sensor signal to attach to sensorTerm.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                      config success and report an error if it times out.
                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSetCustomParam(self, newValue: int, paramIndex: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the value of a custom parameter. This is for arbitrary use.

        Sometimes it is necessary to save calibration/limit/target information in
        the device. Particularly if the device is part of a subsystem that can be
        replaced.

        :param newValue: Value for custom parameter.

        :param paramIndex: Index of custom parameter [0,1]

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                  success and report an error if it times out. If zero, no
                  blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSetParameter(self, param: ParamEnum, value: float, subValue: int, ordinal: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets a parameter. Generally this is not used. This can be utilized in -
        Using new features without updating API installation. - Errata
        workarounds to circumvent API implementation. - Allows for rapid testing
        / unit testing of firmware.

        :param param: Parameter enumeration.

        :param value: Value of parameter.

        :param subValue: Subvalue for parameter. Maximum value of 255.

        :param ordinal: Ordinal of parameter.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSoftLimitDisableNeutralOnLOS(self, softLimitDisableNeutralOnLOS: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Disables soft limits triggering (if enabled) when the sensor is no longer detected.

        :param softLimitDisableNeutralOnLOS: disable triggering

        :param timeoutMs:           Timeout value in ms. If nonzero, function will wait for
                                    config success and report an error if it times out.
                                    If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVoltageCompSaturation(self, voltage: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the Voltage Compensation saturation voltage.

        :param voltage: This is the max voltage to apply to the hbridge when voltage
                 compensation is enabled.  For example, if 10 (volts) is specified
                 and a TalonSRX is commanded to 0.5 (PercentOutput, closed-loop, etc)
                 then the TalonSRX will attempt to apply a duty-cycle to produce 5V.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVoltageMeasurementFilter(self, filterWindowSamples: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the voltage measurement filter.

        :param filterWindowSamples: Number of samples in the rolling average of voltage
                           measurement.

        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_IntegralZone(self, slotIdx: int, izone: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the Integral Zone constant in the given parameter slot. If the
        (absolute) closed-loop error is outside of this zone, integral
        accumulator is automatically cleared. This ensures than integral wind up
        events will stop after the sensor gets far enough from its target.

        :param slotIdx: Parameter slot for the constant.

        :param izone: Value of the Integral Zone constant (closed loop error units X
                 1ms).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kD(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the 'D' constant in the given parameter slot.

        This is multiplied by derivative error (sensor units per PID loop, typically 1ms).
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '250' to get full output if derr is 4096u (Mag Encoder 1 rotation) per 1000 loops (typ 1 sec)

        :param slotIdx: Parameter slot for the constant.

        :param value: Value of the D constant.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kF(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the 'F' constant in the given parameter slot.

        See documentation for calculation details.
        If using velocity, motion magic, or motion profile,
        use (1023 * duty-cycle / sensor-velocity-sensor-units-per-100ms).

        :param slotIdx: Parameter slot for the constant.

        :param value: Value of the F constant.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kI(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the 'I' constant in the given parameter slot.
        This is multiplied by accumulated closed loop error in sensor units every PID Loop.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.00025' to get full output if err is 4096u for 1000 loops (accumulater holds 4,096,000),
        [which is equivalent to one CTRE mag encoder rotation for 1000 milliseconds].

        :param slotIdx: Parameter slot for the constant.

        :param value: Value of the I constant.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kP(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the 'P' constant in the given parameter slot.
        This is multiplied by closed loop error in sensor units.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.25' to get full output if err is 4096u (Mag Encoder 1 rotation)

        :param slotIdx: Parameter slot for the constant.

        :param value: Value of the P constant.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def enableVoltageCompensation(self, enable: bool) -> None: 
        """
        Enables voltage compensation. If enabled, voltage compensation works in
        all control modes.

        Be sure to configure the saturation voltage before enabling this.

        :param enable: Enable state of voltage compensation.
        """
    def getActiveTrajectoryArbFeedFwd(self, pidIdx: int = 0) -> float: 
        """
        Gets the active trajectory arbitrary feedforward using
        MotionMagic/MotionProfile control modes.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: The Active Trajectory ArbFeedFwd in units of percent output
                  (where 0.01 is 1%).
        """
    def getActiveTrajectoryHeading(self) -> float: 
        """
        Gets the active trajectory target heading using
        MotionMagicArc/MotionProfileArc control modes.

        :returns: The Active Trajectory Heading in degrees.
                  @deprecated Use :meth:`.GetActiveTrajectoryPosition` with 1 passed as an argument instead.
        """
    def getActiveTrajectoryPosition(self, pidIdx: int = 0) -> int: 
        """
        Gets the active trajectory target position for using
        MotionMagic/MotionProfile control modes.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: The Active Trajectory Position in sensor units.
        """
    def getActiveTrajectoryVelocity(self, pidIdx: int = 0) -> int: 
        """
        Gets the active trajectory target velocity for using
        MotionMagic/MotionProfile control modes.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: The Active Trajectory Velocity in sensor units per 100ms.
        """
    def getBaseID(self) -> int: 
        """
        :returns: BaseID of device
        """
    def getBusVoltage(self) -> float: 
        """
        Gets the bus voltage seen by the device.

        :returns: The bus voltage value (in volts).
        """
    def getClosedLoopError(self, pidIdx: int = 0) -> int: 
        """
        Gets the closed-loop error. The units depend on which control mode is in
        use.

        If closed-loop is seeking a target sensor position, closed-loop error is the difference between target
        and current sensor value (in sensor units.  Example 4096 units per rotation for CTRE Mag Encoder).

        If closed-loop is seeking a target sensor velocity, closed-loop error is the difference between target
        and current sensor value (in sensor units per 100ms).

        If using motion profiling or Motion Magic, closed loop error is calculated against the current target,
        and not the "final" target at the end of the profile/movement.

        See Phoenix-Documentation information on units.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: Closed-loop error value.
        """
    def getClosedLoopTarget(self, pidIdx: int = 0) -> float: 
        """
        Gets the current target of a given closed loop.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: The closed loop target.
        """
    def getControlMode(self) -> ControlMode: 
        """
        :returns: control mode motor controller is in
        """
    def getDeviceID(self) -> int: 
        """
        Returns the Device ID

        :returns: Device number.
        """
    def getErrorDerivative(self, pidIdx: int = 0) -> float: 
        """
        Gets the derivative of the closed-loop error.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: The error derivative value.
        """
    def getFaults(self, toFill: Faults) -> ErrorCode: 
        """
        Polls the various fault flags.

        :param toFill: Caller's object to fill with latest fault flags.

        :returns: Last Error Code generated by a function.
        """
    def getFirmwareVersion(self) -> int: 
        """
        Gets the firmware version of the device.

        :returns: Firmware version of device. For example: version 1-dot-2 is
                  0x0102.
        """
    def getIntegralAccumulator(self, pidIdx: int = 0) -> float: 
        """
        Gets the iaccum value.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: Integral accumulator value (Closed-loop error X 1ms).
        """
    def getInverted(self) -> bool: 
        """
        :returns: invert setting of motor output.
        """
    def getLastError(self) -> ErrorCode: 
        """
        Gets the last error generated by this object. Not all functions return an
        error code but can potentially report errors. This function can be used
        to retrieve those error codes.

        :returns: Last Error Code generated by a function.
        """
    def getMotionProfileStatus(self, statusToFill: MotionProfileStatus) -> ErrorCode: 
        """
        Retrieve all status information.
        For best performance, Caller can snapshot all status information regarding the
        motion profile executer.

        :param statusToFill: Caller supplied object to fill.

                    The members are filled, as follows...

                    topBufferRem:	The available empty slots in the trajectory buffer.
                    The robot API holds a "top buffer" of trajectory points, so your applicaion
                    can dump several points at once.  The API will then stream them into the
                    low-level buffer, allowing the motor controller to act on them.

                    topBufferRem: The number of points in the top trajectory buffer.

                    btmBufferCnt: The number of points in the low level controller buffer.

                    hasUnderrun: 	Set if isUnderrun ever gets set.
                    Can be manually cleared by clearMotionProfileHasUnderrun() or automatically cleared by startMotionProfile().

                    isUnderrun:		This is set if controller needs to shift a point from its buffer into
                    the active trajectory point however
                    the buffer is empty.
                    This gets cleared automatically when is resolved.

                    activePointValid:	True if the active trajectory point is not empty, false otherwise. The members in activePoint are only valid if this signal is set.

                    isLast:	is set/cleared based on the MP executer's current
                    trajectory point's IsLast value.  This assumes
                    IsLast was set when PushMotionProfileTrajectory
                    was used to insert the currently processed trajectory
                    point.

                    profileSlotSelect: The currently processed trajectory point's
                    selected slot.  This can differ in the currently selected slot used
                    for Position and Velocity servo modes

                    outputEnable:		The current output mode of the motion profile
                    executer (disabled, enabled, or hold).  When changing the set()
                    value in MP mode, it's important to check this signal to
                    confirm the change takes effect before interacting with the top buffer.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getMotionProfileTopLevelBufferCount(self) -> int: 
        """
        Retrieve just the buffer count for the api-level (top) buffer. This
        routine performs no CAN or data structure lookups, so its fast and ideal
        if caller needs to quickly poll the progress of trajectory points being
        emptied into controller's RAM. Otherwise just use GetMotionProfileStatus.

        :returns: number of trajectory points in the top buffer.
        """
    def getMotorOutputPercent(self) -> float: 
        """
        Gets the output percentage of the motor controller.

        :returns: Output of the motor controller (in percent).
        """
    def getMotorOutputVoltage(self) -> float: 
        """
        :returns: applied voltage to motor  in volts.
        """
    def getSelectedSensorPosition(self, pidIdx: int = 0) -> int: 
        """
        Get the selected sensor position (in raw sensor units).

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop. See
              Phoenix-Documentation for how to interpret.

        :returns: Position of selected sensor (in raw sensor units).
        """
    def getSelectedSensorVelocity(self, pidIdx: int = 0) -> int: 
        """
        Get the selected sensor velocity.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: selected sensor (in raw sensor units) per 100ms.
                  See Phoenix-Documentation for how to interpret.
        """
    def getStatusFramePeriod(self, frame: StatusFrame, timeoutMs: int = 0) -> int: 
        """
        Gets the period of the given status frame.

        :param frame: Frame to get the period of.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Period of the given status frame.
        """
    def getStickyFaults(self, toFill: StickyFaults) -> ErrorCode: 
        """
        Polls the various sticky fault flags.

        :param toFill: Caller's object to fill with latest sticky fault flags.

        :returns: Last Error Code generated by a function.
        """
    def getTemperature(self) -> float: 
        """
        Gets the temperature of the motor controller.

        :returns: Temperature of the motor controller (in 'C)
        """
    def hasResetOccurred(self) -> bool: 
        """
        Returns true if the device has reset since last call.

        :returns: Has a Device Reset Occurred?
        """
    def isMotionProfileTopLevelBufferFull(self) -> bool: 
        """
        Retrieve just the buffer full for the api-level (top) buffer. This
        routine performs no CAN or data structure lookups, so its fast and ideal
        if caller needs to quickly poll. Otherwise just use
        GetMotionProfileStatus.

        :returns: number of trajectory points in the top buffer.
        """
    def isVoltageCompensationEnabled(self) -> bool: 
        """
        Returns the enable state of Voltage Compensation that the caller has set.

        :returns: TRUE if voltage compensation is enabled.
        """
    def neutralOutput(self) -> None: 
        """
        Neutral the motor output by setting control mode to disabled.
        """
    def overrideLimitSwitchesEnable(self, enable: bool) -> None: 
        """
        Sets the enable state for limit switches.

        :param enable: Enable state for limit switches.
        """
    def overrideSoftLimitsEnable(self, enable: bool) -> None: 
        """
        Can be used to override-disable the soft limits.
        This function can be used to quickly disable soft limits without
        having to modify the persistent configuration.

        :param enable: Enable state for soft limit switches.
        """
    def processMotionProfileBuffer(self) -> None: 
        """
        This must be called periodically to funnel the trajectory points from the
        API's top level buffer to the controller's bottom level buffer. Recommendation
        is to call this twice as fast as the execution rate of the motion
        profile. So if MP is running with 20ms trajectory points, try calling
        this routine every 10ms. All motion profile functions are thread-safe
        through the use of a mutex, so there is no harm in having the caller
        utilize threading.
        """
    def pushMotionProfileTrajectory(self, trajPt: TrajectoryPoint) -> ErrorCode: 
        """
        Push another trajectory point into the top level buffer (which is emptied
        into the motor controller's bottom buffer as room allows).

        :param trajPt: to push into buffer.
              The members should be filled in with these values...

              targPos:  servo position in sensor units.
              targVel:  velocity to feed-forward in sensor units
              per 100ms.
              profileSlotSelect0  Which slot to get PIDF gains. PID is used for position servo. F is used
              as the Kv constant for velocity feed-forward. Typically this is hardcoded
              to the a particular slot, but you are free gain schedule if need be.
              Choose from [0,3]
              profileSlotSelect1 Which slot to get PIDF gains for auxiliary PId.
              This only has impact during MotionProfileArc Control mode.
              Choose from [0,1].
              isLastPoint  set to nonzero to signal motor controller to keep processing this
              trajectory point, instead of jumping to the next one
              when timeDurMs expires.  Otherwise MP executer will
              eventually see an empty buffer after the last point
              expires, causing it to assert the IsUnderRun flag.
              However this may be desired if calling application
              never wants to terminate the MP.
              zeroPos  set to nonzero to signal motor controller to "zero" the selected
              position sensor before executing this trajectory point.
              Typically the first point should have this set only thus
              allowing the remainder of the MP positions to be relative to
              zero.
              timeDur Duration to apply this trajectory pt.
              This time unit is ADDED to the exising base time set by
              configMotionProfileTrajectoryPeriod().

        :returns: CTR_OKAY if trajectory point push ok. ErrorCode if buffer is
                  full due to kMotionProfileTopBufferCapacity.
        """
    def selectProfileSlot(self, slotIdx: int, pidIdx: int) -> ErrorCode: 
        """
        Selects which profile slot to use for closed-loop control.

        :param slotIdx: Profile slot to select.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.
        """
    @typing.overload
    def set(self, Mode: ControlMode, demand: float) -> None: 
        """
        Sets the appropriate output on the talon, depending on the mode.

        :param Mode: The output mode to apply.
              In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
              In Current mode, output value is in amperes.
              In Velocity mode, output value is in position change / 100ms.
              In Position mode, output value is in encoder ticks or an analog value,
              depending on the sensor.
              In Follower mode, the output value is the integer device ID of the talon to
              duplicate.

        :param demand: The setpoint value, as described above.


              Standard Driving Example:
              _talonLeft.set(ControlMode.PercentOutput, leftJoy);
              _talonRght.set(ControlMode.PercentOutput, rghtJoy);



        :param mode: Sets the appropriate output on the talon, depending on the mode.

        :param demand0: The output value to apply.
                   such as advanced feed forward and/or auxiliary close-looping in firmware.
                   In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                   In Current mode, output value is in amperes.
                   In Velocity mode, output value is in position change / 100ms.
                   In Position mode, output value is in encoder ticks or an analog value,
                   depending on the sensor. See
                   In Follower mode, the output value is the integer device ID of the talon to
                   duplicate.

        :param demand1Type: The demand type for demand1.
                   Neutral: Ignore demand1 and apply no change to the demand0 output.
                   AuxPID: Use demand1 to set the target for the auxiliary PID 1.
                   ArbitraryFeedForward: Use demand1 as an arbitrary additive value to the
                   demand0 output.  In PercentOutput the demand0 output is the motor output,
                   and in closed-loop modes the demand0 output is the output of PID0.

        :param demand1: Supplmental output value.  Units match the set mode.


                   Arcade Drive Example:
                   _talonLeft.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, +joyTurn);
                   _talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, -joyTurn);

                   Drive Straight Example:
                   Note: Selected Sensor Configuration is necessary for both PID0 and PID1.
                   _talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
                   _talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.AuxPID, desiredRobotHeading);

                   Drive Straight to a Distance Example:
                   Note: Other configurations (sensor selection, PID gains, etc.) need to be set.
                   _talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
                   _talonRght.set(ControlMode.MotionMagic, targetDistance, DemandType.AuxPID, desiredRobotHeading);
        """
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    def setControlFramePeriod(self, frame: ControlFrame, periodMs: int) -> ErrorCode: 
        """
        Sets the period of the given control frame.

        :param frame: Frame whose period is to be changed.

        :param periodMs: Period in ms for the given frame.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setIntegralAccumulator(self, iaccum: float, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the integral accumulator. Typically this is used to clear/zero the
        integral accumulator, however some use cases may require seeding the
        accumulator for a faster response.

        :param iaccum: Value to set for the integral accumulator (closed loop error
                 units X 1ms).

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def setInverted(self, invert: bool) -> None: 
        """
        Inverts the hbridge output of the motor controller.

        This does not impact sensor phase and should not be used to correct sensor polarity.

        This will invert the hbridge output but NOT the LEDs.
        This ensures....
        - Green LEDs always represents positive request from robot-controller/closed-looping mode.
        - Green LEDs correlates to forward limit switch.
        - Green LEDs correlates to forward soft limit.

        :param invert: Invert state to set.

        Inverts the hbridge output of the motor controller in relation to the master if present

        This does not impact sensor phase and should not be used to correct sensor polarity.

        This will allow you to either:
        - Not invert the motor
        - Invert the motor
        - Always follow the master regardless of master's inversion
        - Always oppose the master regardless of master's inversion

        :param invertType: Invert state to set.
        """
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None: ...
    def setNeutralMode(self, neutralMode: NeutralMode) -> None: 
        """
        Sets the mode of operation during neutral throttle output.

        :param neutralMode: The desired mode of operation when the Controller output
                   throttle is neutral (ie brake/coast)
        """
    def setSelectedSensorPosition(self, sensorPos: int, pidIdx: int = 0, timeoutMs: int = 50) -> ErrorCode: 
        """
        Sets the sensor position to the given value.

        :param sensorPos: Position to set for the selected sensor (in raw sensor units).

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setSensorPhase(self, PhaseSensor: bool) -> None: 
        """
        Sets the phase of the sensor. Use when controller forward/reverse output
        doesn't correlate to appropriate forward/reverse reading of sensor.
        Pick a value so that positive PercentOutput yields a positive change in sensor.
        After setting this, user can freely call SetInverted() with any value.

        :param PhaseSensor: Indicates whether to invert the phase of the sensor.
        """
    def setStatusFramePeriod(self, frame: StatusFrame, periodMs: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the period of the given status frame.

        User ensure CAN Bus utilization is not high.

        This setting is not persistent and is lost when device is reset. If this
        is a concern, calling application can use HasResetOccurred() to determine if the
        status frame needs to be reconfigured.

        :param frame: Frame whose period is to be changed.

        :param periodMs: Period in ms for the given frame.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    pass
class BaseTalonConfigUtil():
    """
    Util class to help with talon configs
    """
    def __init__(self) -> None: ...
    @staticmethod
    def diff0TermDifferent(settings: BaseTalonConfiguration) -> bool: ...
    @staticmethod
    def diff1TermDifferent(settings: BaseTalonConfiguration) -> bool: ...
    @staticmethod
    def forwardLimitSwitchDeviceIDDifferent(settings: BaseTalonConfiguration) -> bool: ...
    @staticmethod
    def forwardLimitSwitchDifferent(settings: BaseTalonConfiguration) -> bool: ...
    @staticmethod
    def forwardLimitSwitchNormalDifferent(settings: BaseTalonConfiguration) -> bool: ...
    @staticmethod
    def forwardLimitSwitchSourceDifferent(settings: BaseTalonConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    @staticmethod
    def reverseLimitSwitchDeviceIDDifferent(settings: BaseTalonConfiguration) -> bool: ...
    @staticmethod
    def reverseLimitSwitchDifferent(settings: BaseTalonConfiguration) -> bool: ...
    @staticmethod
    def reverseLimitSwitchNormalDifferent(settings: BaseTalonConfiguration) -> bool: ...
    @staticmethod
    def reverseLimitSwitchSourceDifferent(settings: BaseTalonConfiguration) -> bool: ...
    @staticmethod
    def sum0TermDifferent(settings: BaseTalonConfiguration) -> bool: ...
    @staticmethod
    def sum1TermDifferent(settings: BaseTalonConfiguration) -> bool: ...
    pass
class BaseMotorControllerConfiguration(CustomParamConfiguration):
    """
    Configurables available to base motor controllers
    """
    def __init__(self) -> None: ...
    @typing.overload
    def toString(self) -> str: 
        """
        :returns: String representation of configs



        :param prependString: String to prepend to configs

        :returns: String representation of configs
        """
    @typing.overload
    def toString(self, prependString: str) -> str: ...
    @property
    def auxPIDPolarity(self) -> bool:
        """
        PID polarity inversion

        Standard Polarity:
        Primary Output = PID0 + PID1,
        Auxiliary Output = PID0 - PID1,

        Inverted Polarity:
        Primary Output = PID0 - PID1,
        Auxiliary Output = PID0 + PID1,

        :type: bool
        """
    @auxPIDPolarity.setter
    def auxPIDPolarity(self, arg0: bool) -> None:
        """
        PID polarity inversion

        Standard Polarity:
        Primary Output = PID0 + PID1,
        Auxiliary Output = PID0 - PID1,

        Inverted Polarity:
        Primary Output = PID0 - PID1,
        Auxiliary Output = PID0 + PID1,
        """
    @property
    def clearPositionOnLimitF(self) -> bool:
        """
        Clear the position on forward limit

        :type: bool
        """
    @clearPositionOnLimitF.setter
    def clearPositionOnLimitF(self, arg0: bool) -> None:
        """
        Clear the position on forward limit
        """
    @property
    def clearPositionOnLimitR(self) -> bool:
        """
        Clear the position on reverse limit

        :type: bool
        """
    @clearPositionOnLimitR.setter
    def clearPositionOnLimitR(self, arg0: bool) -> None:
        """
        Clear the position on reverse limit
        """
    @property
    def clearPositionOnQuadIdx(self) -> bool:
        """
        Clear the position on index

        :type: bool
        """
    @clearPositionOnQuadIdx.setter
    def clearPositionOnQuadIdx(self, arg0: bool) -> None:
        """
        Clear the position on index
        """
    @property
    def closedloopRamp(self) -> float:
        """
        Seconds to go from 0 to full in closed loop

        :type: float
        """
    @closedloopRamp.setter
    def closedloopRamp(self, arg0: float) -> None:
        """
        Seconds to go from 0 to full in closed loop
        """
    @property
    def feedbackNotContinuous(self) -> bool:
        """
        Determine whether feedback sensor is continuous or not

        :type: bool
        """
    @feedbackNotContinuous.setter
    def feedbackNotContinuous(self, arg0: bool) -> None:
        """
        Determine whether feedback sensor is continuous or not
        """
    @property
    def forwardSoftLimitEnable(self) -> bool:
        """
        Enable forward soft limit

        :type: bool
        """
    @forwardSoftLimitEnable.setter
    def forwardSoftLimitEnable(self, arg0: bool) -> None:
        """
        Enable forward soft limit
        """
    @property
    def forwardSoftLimitThreshold(self) -> int:
        """
        Threshold for soft limits in forward direction (in raw sensor units)

        :type: int
        """
    @forwardSoftLimitThreshold.setter
    def forwardSoftLimitThreshold(self, arg0: int) -> None:
        """
        Threshold for soft limits in forward direction (in raw sensor units)
        """
    @property
    def limitSwitchDisableNeutralOnLOS(self) -> bool:
        """
        Disable neutral'ing the motor when remote limit switch is lost on CAN bus

        :type: bool
        """
    @limitSwitchDisableNeutralOnLOS.setter
    def limitSwitchDisableNeutralOnLOS(self, arg0: bool) -> None:
        """
        Disable neutral'ing the motor when remote limit switch is lost on CAN bus
        """
    @property
    def motionAcceleration(self) -> int:
        """
        Motion Magic acceleration in (raw sensor units per 100 ms) per second.

        :type: int
        """
    @motionAcceleration.setter
    def motionAcceleration(self, arg0: int) -> None:
        """
        Motion Magic acceleration in (raw sensor units per 100 ms) per second.
        """
    @property
    def motionCruiseVelocity(self) -> int:
        """
        Motion Magic cruise velocity in raw sensor units per 100 ms.

        :type: int
        """
    @motionCruiseVelocity.setter
    def motionCruiseVelocity(self, arg0: int) -> None:
        """
        Motion Magic cruise velocity in raw sensor units per 100 ms.
        """
    @property
    def motionCurveStrength(self) -> int:
        """
        Zero to use trapezoidal motion during motion magic.  [1,8] for S-Curve, higher value for greater smoothing.

        :type: int
        """
    @motionCurveStrength.setter
    def motionCurveStrength(self, arg0: int) -> None:
        """
        Zero to use trapezoidal motion during motion magic.  [1,8] for S-Curve, higher value for greater smoothing.
        """
    @property
    def motionProfileTrajectoryPeriod(self) -> int:
        """
        Motion profile base trajectory period in milliseconds.

        The period specified in a trajectory point will be
        added on to this value

        :type: int
        """
    @motionProfileTrajectoryPeriod.setter
    def motionProfileTrajectoryPeriod(self, arg0: int) -> None:
        """
        Motion profile base trajectory period in milliseconds.

        The period specified in a trajectory point will be
        added on to this value
        """
    @property
    def neutralDeadband(self) -> float:
        """
        Neutral deadband [0.001, 0.25]

        :type: float
        """
    @neutralDeadband.setter
    def neutralDeadband(self, arg0: float) -> None:
        """
        Neutral deadband [0.001, 0.25]
        """
    @property
    def nominalOutputForward(self) -> float:
        """
        Nominal/Minimum output in forward direction [0,1]

        :type: float
        """
    @nominalOutputForward.setter
    def nominalOutputForward(self, arg0: float) -> None:
        """
        Nominal/Minimum output in forward direction [0,1]
        """
    @property
    def nominalOutputReverse(self) -> float:
        """
        Nominal/Minimum output in reverse direction [-1,0]

        :type: float
        """
    @nominalOutputReverse.setter
    def nominalOutputReverse(self, arg0: float) -> None:
        """
        Nominal/Minimum output in reverse direction [-1,0]
        """
    @property
    def openloopRamp(self) -> float:
        """
        Seconds to go from 0 to full in open loop

        :type: float
        """
    @openloopRamp.setter
    def openloopRamp(self, arg0: float) -> None:
        """
        Seconds to go from 0 to full in open loop
        """
    @property
    def peakOutputForward(self) -> float:
        """
        Peak output in forward direction [0,1]

        :type: float
        """
    @peakOutputForward.setter
    def peakOutputForward(self, arg0: float) -> None:
        """
        Peak output in forward direction [0,1]
        """
    @property
    def peakOutputReverse(self) -> float:
        """
        Peak output in reverse direction [-1,0]

        :type: float
        """
    @peakOutputReverse.setter
    def peakOutputReverse(self, arg0: float) -> None:
        """
        Peak output in reverse direction [-1,0]
        """
    @property
    def pulseWidthPeriod_EdgesPerRot(self) -> int:
        """
        Number of edges per rotation for a tachometer sensor

        :type: int
        """
    @pulseWidthPeriod_EdgesPerRot.setter
    def pulseWidthPeriod_EdgesPerRot(self, arg0: int) -> None:
        """
        Number of edges per rotation for a tachometer sensor
        """
    @property
    def pulseWidthPeriod_FilterWindowSz(self) -> int:
        """
        Desired window size for a tachometer sensor

        :type: int
        """
    @pulseWidthPeriod_FilterWindowSz.setter
    def pulseWidthPeriod_FilterWindowSz(self, arg0: int) -> None:
        """
        Desired window size for a tachometer sensor
        """
    @property
    def remoteFilter0(self) -> FilterConfiguration:
        """
        Configuration for RemoteFilter 0

        :type: FilterConfiguration
        """
    @remoteFilter0.setter
    def remoteFilter0(self, arg0: FilterConfiguration) -> None:
        """
        Configuration for RemoteFilter 0
        """
    @property
    def remoteFilter1(self) -> FilterConfiguration:
        """
        Configuration for RemoteFilter 1

        :type: FilterConfiguration
        """
    @remoteFilter1.setter
    def remoteFilter1(self, arg0: FilterConfiguration) -> None:
        """
        Configuration for RemoteFilter 1
        """
    @property
    def remoteSensorClosedLoopDisableNeutralOnLOS(self) -> bool:
        """
        Disable neutral'ing the motor when remote sensor is lost on CAN bus

        :type: bool
        """
    @remoteSensorClosedLoopDisableNeutralOnLOS.setter
    def remoteSensorClosedLoopDisableNeutralOnLOS(self, arg0: bool) -> None:
        """
        Disable neutral'ing the motor when remote sensor is lost on CAN bus
        """
    @property
    def reverseSoftLimitEnable(self) -> bool:
        """
        Enable reverse soft limit

        :type: bool
        """
    @reverseSoftLimitEnable.setter
    def reverseSoftLimitEnable(self, arg0: bool) -> None:
        """
        Enable reverse soft limit
        """
    @property
    def reverseSoftLimitThreshold(self) -> int:
        """
        Threshold for soft limits in reverse direction (in raw sensor units)

        :type: int
        """
    @reverseSoftLimitThreshold.setter
    def reverseSoftLimitThreshold(self, arg0: int) -> None:
        """
        Threshold for soft limits in reverse direction (in raw sensor units)
        """
    @property
    def slot0(self) -> SlotConfiguration:
        """
        Configuration for slot 0

        :type: SlotConfiguration
        """
    @slot0.setter
    def slot0(self, arg0: SlotConfiguration) -> None:
        """
        Configuration for slot 0
        """
    @property
    def slot1(self) -> SlotConfiguration:
        """
        Configuration for slot 1

        :type: SlotConfiguration
        """
    @slot1.setter
    def slot1(self, arg0: SlotConfiguration) -> None:
        """
        Configuration for slot 1
        """
    @property
    def slot2(self) -> SlotConfiguration:
        """
        Configuration for slot 2

        :type: SlotConfiguration
        """
    @slot2.setter
    def slot2(self, arg0: SlotConfiguration) -> None:
        """
        Configuration for slot 2
        """
    @property
    def slot3(self) -> SlotConfiguration:
        """
        Configuration for slot 3

        :type: SlotConfiguration
        """
    @slot3.setter
    def slot3(self, arg0: SlotConfiguration) -> None:
        """
        Configuration for slot 3
        """
    @property
    def softLimitDisableNeutralOnLOS(self) -> bool:
        """
        Disable neutral'ing the motor when remote soft limit is lost on CAN bus

        :type: bool
        """
    @softLimitDisableNeutralOnLOS.setter
    def softLimitDisableNeutralOnLOS(self, arg0: bool) -> None:
        """
        Disable neutral'ing the motor when remote soft limit is lost on CAN bus
        """
    @property
    def trajectoryInterpolationEnable(self) -> bool:
        """
        Enable motion profile trajectory point interpolation (defaults to true).

        :type: bool
        """
    @trajectoryInterpolationEnable.setter
    def trajectoryInterpolationEnable(self, arg0: bool) -> None:
        """
        Enable motion profile trajectory point interpolation (defaults to true).
        """
    @property
    def velocityMeasurementPeriod(self) -> VelocityMeasPeriod:
        """
        Desired period for velocity measurement

        :type: VelocityMeasPeriod
        """
    @velocityMeasurementPeriod.setter
    def velocityMeasurementPeriod(self, arg0: VelocityMeasPeriod) -> None:
        """
        Desired period for velocity measurement
        """
    @property
    def velocityMeasurementWindow(self) -> int:
        """
        Desired window for velocity measurement

        :type: int
        """
    @velocityMeasurementWindow.setter
    def velocityMeasurementWindow(self, arg0: int) -> None:
        """
        Desired window for velocity measurement
        """
    @property
    def voltageCompSaturation(self) -> float:
        """
        This is the max voltage to apply to the hbridge when voltage
        compensation is enabled.  For example, if 10 (volts) is specified
        and a TalonSRX is commanded to 0.5 (PercentOutput, closed-loop, etc)
        then the TalonSRX will attempt to apply a duty-cycle to produce 5V.

        :type: float
        """
    @voltageCompSaturation.setter
    def voltageCompSaturation(self, arg0: float) -> None:
        """
        This is the max voltage to apply to the hbridge when voltage
        compensation is enabled.  For example, if 10 (volts) is specified
        and a TalonSRX is commanded to 0.5 (PercentOutput, closed-loop, etc)
        then the TalonSRX will attempt to apply a duty-cycle to produce 5V.
        """
    @property
    def voltageMeasurementFilter(self) -> int:
        """
        Number of samples in rolling average for voltage

        :type: int
        """
    @voltageMeasurementFilter.setter
    def voltageMeasurementFilter(self, arg0: int) -> None:
        """
        Number of samples in rolling average for voltage
        """
    pass
class BaseTalonPIDSetConfigUtil():
    """
    Util class to help with BaseTalon's PID configs
    """
    def __init__(self) -> None: ...
    @staticmethod
    def selectedFeedbackCoefficientDifferent(settings: BaseTalonPIDSetConfiguration) -> bool: ...
    @staticmethod
    def selectedFeedbackSensorDifferent(settings: BaseTalonPIDSetConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    pass
class BaseTalonPIDSetConfiguration(BasePIDSetConfiguration):
    """
    Configurables available to BaseTalon's PID
    """
    def __init__(self, defaultFeedbackDevice: FeedbackDevice) -> None: ...
    @typing.overload
    def toString(self) -> str: 
        """
        :returns: string representation of configs



        :param prependString: String to prepend to configs

        :returns: String representation of configs
        """
    @typing.overload
    def toString(self, prependString: str) -> str: ...
    @property
    def selectedFeedbackSensor(self) -> FeedbackDevice:
        """
        Feedback device for a particular PID loop.
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        @code
        configs.primaryPID.selectedFeedbackSensor = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        configs.primaryPID.selectedFeedbackSensor = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        @endcode

        :type: FeedbackDevice
        """
    @selectedFeedbackSensor.setter
    def selectedFeedbackSensor(self, arg0: FeedbackDevice) -> None:
        """
        Feedback device for a particular PID loop.
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        @code
        configs.primaryPID.selectedFeedbackSensor = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        configs.primaryPID.selectedFeedbackSensor = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        @endcode
        """
    pass
class BufferedTrajectoryPointStream():
    """
    Stream of trajectory points for Talon/Victor motion profiling.
    """
    def __init__(self) -> None: ...
    def clear(self) -> ErrorCode: 
        """
        Clear all trajectory points.

        :returns: nonzero error code if operation fails.
        """
    def getHandle(self) -> capsule: 
        """
        :returns: raw handle for resource management.
        """
    @typing.overload
    def write(self, trajPt: TrajectoryPoint) -> ErrorCode: 
        """
        Write a single trajectory point into the buffer.

        :returns: nonzero error code if operation fails.

        Writes an array of trajectory point into the buffer.

        :returns: nonzero error code if operation fails.
        """
    @typing.overload
    def write(self, trajPts: TrajectoryPoint, trajPtCount: int) -> ErrorCode: ...
    pass
class CANBusAddressable():
    """
    Simple address holder.
    """
    def __init__(self, deviceNumber: int) -> None: 
        """
        Constructor for a CANBusAddressable device

        :param deviceNumber: CAN Device ID of device
        """
    def getDeviceNumber(self) -> int: 
        """
        :returns: CAN device number of device
        """
    pass
class CANCoder(CANBusAddressable):
    """
    CTRE CANCoder

    Device for interfacing common devices to the CAN bus.
    """
    def __init__(self, deviceNumber: int) -> None: 
        """
        Constructor.

        :param deviceNumber: The CAN Device ID of the CANCoder.
        """
    def clearStickyFaults(self, timeoutMs: int = 0) -> ErrorCode: 
        """
        Clears the Sticky Faults

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configAbsoluteSensorRange(self, absoluteSensorRange: AbsoluteSensorRange, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the signage and range of the "Absolute Position" signal.
        Choose unsigned for an absolute range of [0,+1) rotations, [0,360) deg, etc...
        Choose signed for an absolute range of [-0.5,+0.5) rotations, [-180,+180) deg, etc...

        :param absoluteSensorRange: Desired Sign/Range for the absolute position register.

        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configAllSettings(self, allConfigs: CANCoderConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures all persistent settings.

        :param allConfigs: Object with all of the persistant settings

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configFactoryDefault(self, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures all persistent settings to defaults (overloaded so timeoutMs is 50 ms).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configFeedbackCoefficient(self, sensorCoefficient: float, unitString: str, sensortimeBase: SensorTimeBase, timeoutMs: int = 0) -> ErrorCode: 
        """
        Choose what units you want the API to get/set.  This also impacts the units displayed in Self-Test in Tuner.
        Depending on your mechanism, you may want to scale rotational units (deg, radians, rotations), or scale to a distance (inches, centimeters).

        :param sensorCoefficient: Scalar to multiply the CANCoder's native 12-bit resolute sensor. Defaults to 0.087890625 to produce degrees.

        :param unitString: String holding the unit to report in.  This impacts all routines (except for ConfigMagnetOffset) and the self-test in Tuner.
                         The string value itself is arbitrary.  The max number of letters will depend on firmware versioning, but generally CANCoder
                         supports up to eight letters.  However, common units such as "centimeters" are supported explicitly despite exceeding the eight-letter limit.
                         Default is "deg"

        :param sensortimeBase: Desired denominator to report velocity in.  This impacts GetVelocity and the reported velocity in self-test in Tuner.
                         Default is "Per Second".

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                         config success and report an error if it times out.
                         If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configGetCustomParam(self, paramIndex: int, timeoutMs: int = 0) -> int: 
        """
        Gets the value of a custom parameter. This is for arbitrary use.

        Sometimes it is necessary to save calibration/duty cycle/output
        information in the device. Particularly if the
        device is part of a subsystem that can be replaced.

        :param paramIndex: Index of custom parameter. [0-1]

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Value of the custom param.
        """
    @typing.overload
    def configGetParameter(self, param: ParamEnum, ordinal: int, timeoutMs: int = 0) -> float: 
        """
        Gets a parameter. Generally this is not used.
        This can be utilized in
        - Using new features without updating API installation.
        - Errata workarounds to circumvent API implementation.
        - Allows for rapid testing / unit testing of firmware.

        :param param: Parameter enumeration.

        :param ordinal: Ordinal of parameter.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Value of parameter.

        Gets a parameter by passing an int by reference

        :param param: Parameter enumeration

        :param valueToSend: Value to send to parameter

        :param valueReceived: Reference to integer to receive

        :param subValue: SubValue of parameter

        :param ordinal: Ordinal of parameter

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                     config success and report an error if it times out.
                     If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configGetParameter(self, param: ParamEnum, valueToSend: int, valueReceived: int, subValue: int, ordinal: int, timeoutMs: int) -> ErrorCode: ...
    def configMagnetOffset(self, offsetDegrees: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Adjusts the zero point for the absolute position register.
        The absolute position of the sensor will always have a discontinuity (360 -> 0 deg) or (+180 -> -180)
        and a hard-limited mechanism may have such a discontinuity in its functional range.
        In which case use this config to move the discontinuity outside of the function range.

        :param offsetDegrees: Offset in degrees (unit string and coefficient DO NOT apply for this config).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                     config success and report an error if it times out.
                     If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSensorDirection(self, bSensorDirection: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Choose which direction is interpreted as positive displacement.
        This affects both "Position" and "Absolute Position".

        :param bSensorDirection: False (default) means positive rotation occurs when magnet
                        is spun counter-clockwise when observer is facing the LED side of CANCoder.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                        config success and report an error if it times out.
                        If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSensorInitializationStrategy(self, initializationStrategy: SensorInitializationStrategy, timeoutMs: int = 0) -> ErrorCode: 
        """
        Pick the strategy on how to initialize the CANCoder's "Position" register.  Depending on the mechanism,
        it may be desirable to auto set the Position register to match the Absolute Position (swerve for example).
        Or it may be desired to zero the sensor on boot (drivetrain translation sensor or a relative servo).

        TIP: Tuner's self-test feature will report what the boot sensor value will be in the event the CANCoder is reset.

        :param initializationStrategy: The sensor initialization strategy to use.  This will impact the behavior the next time CANCoder boots up.

        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.
                              If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSetCustomParam(self, newValue: int, paramIndex: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the value of a custom parameter. This is for arbitrary use.

        Sometimes it is necessary to save calibration/duty cycle/output
        information in the device. Particularly if the
        device is part of a subsystem that can be replaced.

        :param newValue: Value for custom parameter.

        :param paramIndex: Index of custom parameter. [0-1]

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSetParameter(self, param: ParamEnum, value: float, subValue: int, ordinal: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets a parameter. Generally this is not used.
        This can be utilized in
        - Using new features without updating API installation.
        - Errata workarounds to circumvent API implementation.
        - Allows for rapid testing / unit testing of firmware.

        :param param: Parameter enumeration.

        :param value: Value of parameter.

        :param subValue: Subvalue for parameter. Maximum value of 255.

        :param ordinal: Ordinal of parameter.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementPeriod(self, period: SensorVelocityMeasPeriod, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the period of each velocity sample.
        Every 1ms a position value is sampled, and the delta between that sample
        and the position sampled kPeriod ms ago is inserted into a filter.
        kPeriod is configured with this function.

        :param period: Desired period for the velocity measurement.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementWindow(self, windowSize: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the number of velocity samples used in the rolling average velocity
        measurement.

        :param windowSize: Number of samples in the rolling average of velocity
                  measurement. Valid values are 1,2,4,8,16,32. If another
                  value is specified, it will truncate to nearest support value.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @staticmethod
    def destroyAllCANCoders() -> None: 
        """
        Destructs all CANCoder objects
        """
    def getAbsolutePosition(self) -> float: 
        """
        Gets the absolute position of the sensor.
        The absolute position may be unsigned (for example: [0,360) deg), or signed (for example: [-180,+180) deg).  This is determined by a configuration.  The default selection is unsigned.
        The units are determined by the coefficient and unit-string configuration params, default is degrees.
        Note: this signal is not affected by calls to SetPosition().

        :returns: The position of the sensor.
        """
    def getAllConfigs(self, allConfigs: CANCoderConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Gets all persistant settings.

        :param allConfigs: Object with all of the persistant settings

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getBusVoltage(self) -> float: 
        """
        Gets the bus voltage seen by the device.

        :returns: The bus voltage value (in volts).
        """
    def getFaults(self, toFill: CANCoderFaults) -> ErrorCode: 
        """
        Gets the CANCoder fault status

        :param toFill: Container for fault statuses.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getFirmwareVersion(self) -> int: 
        """
        Gets the firmware version of the device.

        :returns: Firmware version of device.
        """
    def getLastError(self) -> ErrorCode: 
        """
        Call GetLastError() generated by this object.
        Not all functions return an error code but can
        potentially report errors.

        This function can be used to retrieve those error codes.

        :returns: The last ErrorCode generated.
        """
    def getLastTimestamp(self) -> float: 
        """
        Get the timestamp of the CAN frame retrieved in the last called get routine.
        """
    def getLastUnitString(self) -> str: 
        """
        Get the units for the signal retrieved in the last called get routine.
        """
    def getMagnetFieldStrength(self) -> MagnetFieldStrength: 
        """
        Gets the magnet's health.

        :returns: The magnet health code (red/orange/green).
        """
    def getPosition(self) -> float: 
        """
        Gets the position of the sensor.  This may be relative or absolute depending on configuration.
        The units are determined by the coefficient and unit-string configuration params, default is degrees.

        :returns: The position of the sensor.
        """
    def getStatusFramePeriod(self, frame: CANCoderStatusFrame, timeoutMs: int = 0) -> int: 
        """
        Gets the period of the given status frame.

        :param frame: Frame to get the period of.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Period of the given status frame.
        """
    def getStickyFaults(self, toFill: CANCoderStickyFaults) -> ErrorCode: 
        """
        Gets the CANCoder sticky fault status

        :param toFill: Container for sticky fault statuses.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getVelocity(self) -> float: 
        """
        Sets the position of the sensor.
        The units are determined by the coefficient and unit-string configuration params, default is degrees.

        :param newPosition: 

        :returns: ErrorCode generated by function. 0 indicates no error.
        """
    def hasResetOccurred(self) -> bool: 
        """
        Returns true if the device has reset since last call.

        :returns: Has a Device Reset Occurred?
        """
    def setPosition(self, newPosition: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the position of the sensor.
        The units are determined by the coefficient and unit-string configuration params, default is degrees.

        :param newPosition: 

        :returns: ErrorCode generated by function. 0 indicates no error.
        """
    def setPositionToAbsolute(self, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the position of the sensor to match the magnet's "Absolute Sensor".
        The units are determined by the coefficient and unit-string configuration params, default is degrees.

        :returns: ErrorCode generated by function. 0 indicates no error.
        """
    def setStatusFramePeriod(self, statusFrame: CANCoderStatusFrame, periodMs: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the period of the given status frame.

        :param statusFrame: Frame whose period is to be changed.

        :param periodMs: Period in ms for the given frame.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                   config success and report an error if it times out.
                   If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    pass
class CANCoderConfigUtils(CustomParamConfigUtil):
    """
    Util class to help with configuring CANCoder
    """
    def __init__(self) -> None: ...
    @staticmethod
    def absoluteSensorRangeDifferent(settings: CANCoderConfiguration) -> bool: ...
    @staticmethod
    def initializationStrategyDifferent(settings: CANCoderConfiguration) -> bool: ...
    @staticmethod
    def magnetOffsetDegreesDifferent(settings: CANCoderConfiguration) -> bool: ...
    @staticmethod
    def sensorCoefficientDifferent(settings: CANCoderConfiguration) -> bool: ...
    @staticmethod
    def sensorDirectionDifferent(settings: CANCoderConfiguration) -> bool: ...
    @staticmethod
    def sensorTimeBaseDifferent(settings: CANCoderConfiguration) -> bool: ...
    @staticmethod
    def unitStringDifferent(settings: CANCoderConfiguration) -> bool: ...
    @staticmethod
    def velocityMeasurementPeriodDifferent(settings: CANCoderConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    @staticmethod
    def velocityMeasurementWindowDifferent(settings: CANCoderConfiguration) -> bool: ...
    pass
class CANCoderConfiguration(CustomParamConfiguration):
    """
    Configurables available to CANCoder
    """
    def __init__(self) -> None: 
        """
        Constructor
        """
    @typing.overload
    def toString(self) -> str: 
        """
        :returns: String representation of configs



        :param prependString: String to prepend to configs

        :returns: String representation of configs
        """
    @typing.overload
    def toString(self, prependString: str) -> str: ...
    @property
    def absoluteSensorRange(self) -> AbsoluteSensorRange:
        """
        Desired Sign / Range for the absolute position register.
        Choose unsigned for an absolute range of[0, +1) rotations, [0, 360) deg, etc.
        Choose signed for an absolute range of[-0.5, +0.5) rotations, [-180, +180) deg, etc.

        :type: AbsoluteSensorRange
        """
    @absoluteSensorRange.setter
    def absoluteSensorRange(self, arg0: AbsoluteSensorRange) -> None:
        """
        Desired Sign / Range for the absolute position register.
        Choose unsigned for an absolute range of[0, +1) rotations, [0, 360) deg, etc.
        Choose signed for an absolute range of[-0.5, +0.5) rotations, [-180, +180) deg, etc.
        """
    @property
    def initializationStrategy(self) -> SensorInitializationStrategy:
        """
        The sensor initialization strategy to use.This will impact the behavior the next time CANCoder boots up.

        Pick the strategy on how to initialize the CANCoder's "Position" register.  Depending on the mechanism,
        it may be desirable to auto set the Position register to match the Absolute Position(swerve for example).
        Or it may be desired to zero the sensor on boot(drivetrain translation sensor or a relative servo).

        TIP: Tuner's self-test feature will report what the boot sensor value will be in the event the CANCoder is reset.

        :type: SensorInitializationStrategy
        """
    @initializationStrategy.setter
    def initializationStrategy(self, arg0: SensorInitializationStrategy) -> None:
        """
        The sensor initialization strategy to use.This will impact the behavior the next time CANCoder boots up.

        Pick the strategy on how to initialize the CANCoder's "Position" register.  Depending on the mechanism,
        it may be desirable to auto set the Position register to match the Absolute Position(swerve for example).
        Or it may be desired to zero the sensor on boot(drivetrain translation sensor or a relative servo).

        TIP: Tuner's self-test feature will report what the boot sensor value will be in the event the CANCoder is reset.
        """
    @property
    def magnetOffsetDegrees(self) -> float:
        """
        Adjusts the zero point for the absolute position register.
        The absolute position of the sensor will always have a discontinuity (360 -> 0 deg) or (+180 -> -180)
        and a hard-limited mechanism may have such a discontinuity in its functional range.
        In which case use this config to move the discontinuity outside of the function range.

        :type: float
        """
    @magnetOffsetDegrees.setter
    def magnetOffsetDegrees(self, arg0: float) -> None:
        """
        Adjusts the zero point for the absolute position register.
        The absolute position of the sensor will always have a discontinuity (360 -> 0 deg) or (+180 -> -180)
        and a hard-limited mechanism may have such a discontinuity in its functional range.
        In which case use this config to move the discontinuity outside of the function range.
        """
    @property
    def sensorCoefficient(self) -> float:
        """
        Scalar to multiply the CANCoder's native 12-bit resolute sensor. Defaults to 0.087890625 to produce degrees.

        :type: float
        """
    @sensorCoefficient.setter
    def sensorCoefficient(self, arg0: float) -> None:
        """
        Scalar to multiply the CANCoder's native 12-bit resolute sensor. Defaults to 0.087890625 to produce degrees.
        """
    @property
    def sensorDirection(self) -> bool:
        """
        Choose which direction is interpreted as positive displacement.
        This affects both "Position"and "Absolute Position".
        False(default) means positive rotation occurs when magnet
        is spun counter - clockwise when observer is facing the LED side of CANCoder.

        :type: bool
        """
    @sensorDirection.setter
    def sensorDirection(self, arg0: bool) -> None:
        """
        Choose which direction is interpreted as positive displacement.
        This affects both "Position"and "Absolute Position".
        False(default) means positive rotation occurs when magnet
        is spun counter - clockwise when observer is facing the LED side of CANCoder.
        """
    @property
    def sensorTimeBase(self) -> SensorTimeBase:
        """
        Desired denominator to report velocity in. This impacts GetVelocityand the reported velocity in self-test in Tuner.
        Default is "Per Second".

        :type: SensorTimeBase
        """
    @sensorTimeBase.setter
    def sensorTimeBase(self, arg0: SensorTimeBase) -> None:
        """
        Desired denominator to report velocity in. This impacts GetVelocityand the reported velocity in self-test in Tuner.
        Default is "Per Second".
        """
    @property
    def unitString(self) -> str:
        """
        String holding the unit to report in.  This impacts all routines(except for ConfigMagnetOffset) and the self-test in Tuner.
        The string value itself is arbitrary.The max number of letters will depend on firmware versioning, but generally CANCoder
        supports up to eight letters.However, common units such as "centimeters" are supported explicitly despite exceeding the eight-letter limit.
        Default is "deg"

        :type: str
        """
    @unitString.setter
    def unitString(self, arg0: str) -> None:
        """
        String holding the unit to report in.  This impacts all routines(except for ConfigMagnetOffset) and the self-test in Tuner.
        The string value itself is arbitrary.The max number of letters will depend on firmware versioning, but generally CANCoder
        supports up to eight letters.However, common units such as "centimeters" are supported explicitly despite exceeding the eight-letter limit.
        Default is "deg"
        """
    @property
    def velocityMeasurementPeriod(self) -> SensorVelocityMeasPeriod:
        """
        Velocity measurement period to use

        :type: SensorVelocityMeasPeriod
        """
    @velocityMeasurementPeriod.setter
    def velocityMeasurementPeriod(self, arg0: SensorVelocityMeasPeriod) -> None:
        """
        Velocity measurement period to use
        """
    @property
    def velocityMeasurementWindow(self) -> int:
        """
        Velocity measurement window to use

        :type: int
        """
    @velocityMeasurementWindow.setter
    def velocityMeasurementWindow(self, arg0: int) -> None:
        """
        Velocity measurement window to use
        """
    pass
class CANCoderFaults():
    """
    Faults available to CANCoderFaults
    """
    @typing.overload
    def __init__(self) -> None: 
        """
        Updates current fault list with specified bit field of faults

        :param bits: bit field of faults to update with
        """
    @typing.overload
    def __init__(self, bits: int) -> None: ...
    def hasAnyFault(self) -> bool: 
        """
        :returns: true if any faults are tripped
        """
    def toBitfield(self) -> int: 
        """
        :returns: Current fault list as a bit field
        """
    def update(self, bits: int) -> None: 
        """
        Updates current fault list with specified bit field of faults

        :param bits: bit field of faults to update with
        """
    @property
    def APIError(self) -> bool:
        """
        API error detected.  Make sure API and firmware versions are compatible.

        :type: bool
        """
    @APIError.setter
    def APIError(self, arg0: bool) -> None:
        """
        API error detected.  Make sure API and firmware versions are compatible.
        """
    @property
    def HardwareFault(self) -> bool:
        """
        Device detects hardware failure

        :type: bool
        """
    @HardwareFault.setter
    def HardwareFault(self, arg0: bool) -> None:
        """
        Device detects hardware failure
        """
    @property
    def MagnetTooWeak(self) -> bool:
        """
        Magnet strength is too weak to provide reliable results
        Make sure CANCoder is close to the magnet being used

        :type: bool
        """
    @MagnetTooWeak.setter
    def MagnetTooWeak(self, arg0: bool) -> None:
        """
        Magnet strength is too weak to provide reliable results
        Make sure CANCoder is close to the magnet being used
        """
    @property
    def ResetDuringEn(self) -> bool:
        """
        Device was powered-on or reset while robot is enabled.
        Check your breakers and wiring.

        :type: bool
        """
    @ResetDuringEn.setter
    def ResetDuringEn(self, arg0: bool) -> None:
        """
        Device was powered-on or reset while robot is enabled.
        Check your breakers and wiring.
        """
    @property
    def UnderVoltage(self) -> bool:
        """
        Device is under 6.5V

        :type: bool
        """
    @UnderVoltage.setter
    def UnderVoltage(self, arg0: bool) -> None:
        """
        Device is under 6.5V
        """
    pass
class CANCoderStatusFrame():
    """
    Enumerated type for status frame types.

    Members:

      SensorData

      VbatAndFaults
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    SensorData: ctre._ctre.CANCoderStatusFrame # value = CANCoderStatusFrame.SensorData
    VbatAndFaults: ctre._ctre.CANCoderStatusFrame # value = CANCoderStatusFrame.VbatAndFaults
    __members__: dict # value = {'SensorData': CANCoderStatusFrame.SensorData, 'VbatAndFaults': CANCoderStatusFrame.VbatAndFaults}
    pass
class CANCoderStickyFaults():
    """
    Sticky Faults for CANCoder (Currently has none)
    """
    @typing.overload
    def __init__(self) -> None: 
        """
        Updates current fault list with specified bit field of faults

        :param bits: bit field of faults to update with
        """
    @typing.overload
    def __init__(self, bits: int) -> None: ...
    def hasAnyFault(self) -> bool: 
        """
        :returns: true if any faults are tripped
        """
    def toBitfield(self) -> int: 
        """
        :returns: Current fault list as a bit field
        """
    def update(self, bits: int) -> None: 
        """
        Updates current fault list with specified bit field of faults

        :param bits: bit field of faults to update with
        """
    @property
    def APIError(self) -> bool:
        """
        API error detected.  Make sure API and firmware versions are compatible.

        :type: bool
        """
    @APIError.setter
    def APIError(self, arg0: bool) -> None:
        """
        API error detected.  Make sure API and firmware versions are compatible.
        """
    @property
    def HardwareFault(self) -> bool:
        """
        Device detects hardware failure

        :type: bool
        """
    @HardwareFault.setter
    def HardwareFault(self, arg0: bool) -> None:
        """
        Device detects hardware failure
        """
    @property
    def MagnetTooWeak(self) -> bool:
        """
        Magnet strength is too weak to provide reliable results
        Make sure CANCoder is close to the magnet being used

        :type: bool
        """
    @MagnetTooWeak.setter
    def MagnetTooWeak(self, arg0: bool) -> None:
        """
        Magnet strength is too weak to provide reliable results
        Make sure CANCoder is close to the magnet being used
        """
    @property
    def ResetDuringEn(self) -> bool:
        """
        Device was powered-on or reset while robot is enabled.
        Check your breakers and wiring.

        :type: bool
        """
    @ResetDuringEn.setter
    def ResetDuringEn(self, arg0: bool) -> None:
        """
        Device was powered-on or reset while robot is enabled.
        Check your breakers and wiring.
        """
    @property
    def UnderVoltage(self) -> bool:
        """
        Device is under 6.5V

        :type: bool
        """
    @UnderVoltage.setter
    def UnderVoltage(self, arg0: bool) -> None:
        """
        Device is under 6.5V
        """
    pass
class CANifier(CANBusAddressable):
    """
    CTRE CANifier

    Device for interfacing common devices to the CAN bus.
    """
    class GeneralPin():
        """
        General IO Pins on the CANifier

        Members:

          QUAD_IDX : Quadrature Idx pin

          QUAD_B : Quadrature B pin

          QUAD_A : Quadrature A pin

          LIMR : Reverse limit pin

          LIMF : Forward limit pin

          SDA : SDA pin

          SCL : SCL pin

          SPI_CS : SPI_CS pin

          SPI_MISO_PWM2P : SPI_MISO_PWM2 pin

          SPI_MOSI_PWM1P : SPI_MOSI_PWM1 pin

          SPI_CLK_PWM0P : SPI_CLK_PWM0 pin
        """
        def __eq__(self, arg0: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, arg0: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, arg0: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, arg0: int) -> None: ...
        @property
        def name(self) -> None:
            """
            :type: None
            """
        LIMF: ctre._ctre.CANifier.GeneralPin # value = GeneralPin.LIMF
        LIMR: ctre._ctre.CANifier.GeneralPin # value = GeneralPin.LIMR
        QUAD_A: ctre._ctre.CANifier.GeneralPin # value = GeneralPin.QUAD_A
        QUAD_B: ctre._ctre.CANifier.GeneralPin # value = GeneralPin.QUAD_B
        QUAD_IDX: ctre._ctre.CANifier.GeneralPin # value = GeneralPin.QUAD_IDX
        SCL: ctre._ctre.CANifier.GeneralPin # value = GeneralPin.SCL
        SDA: ctre._ctre.CANifier.GeneralPin # value = GeneralPin.SDA
        SPI_CLK_PWM0P: ctre._ctre.CANifier.GeneralPin # value = GeneralPin.SPI_CLK_PWM0P
        SPI_CS: ctre._ctre.CANifier.GeneralPin # value = GeneralPin.SPI_CS
        SPI_MISO_PWM2P: ctre._ctre.CANifier.GeneralPin # value = GeneralPin.SPI_MISO_PWM2P
        SPI_MOSI_PWM1P: ctre._ctre.CANifier.GeneralPin # value = GeneralPin.SPI_MOSI_PWM1P
        __members__: dict # value = {'QUAD_IDX': GeneralPin.QUAD_IDX, 'QUAD_B': GeneralPin.QUAD_B, 'QUAD_A': GeneralPin.QUAD_A, 'LIMR': GeneralPin.LIMR, 'LIMF': GeneralPin.LIMF, 'SDA': GeneralPin.SDA, 'SCL': GeneralPin.SCL, 'SPI_CS': GeneralPin.SPI_CS, 'SPI_MISO_PWM2P': GeneralPin.SPI_MISO_PWM2P, 'SPI_MOSI_PWM1P': GeneralPin.SPI_MOSI_PWM1P, 'SPI_CLK_PWM0P': GeneralPin.SPI_CLK_PWM0P}
        pass
    class LEDChannel():
        """
        Enum for the LED Output Channels

        Members:

          A : LED Channel A

          B : LED Channel B

          C : LED Channel C
        """
        def __eq__(self, arg0: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, arg0: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, arg0: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, arg0: int) -> None: ...
        @property
        def name(self) -> None:
            """
            :type: None
            """
        A: ctre._ctre.CANifier.LEDChannel # value = LEDChannel.A
        B: ctre._ctre.CANifier.LEDChannel # value = LEDChannel.B
        C: ctre._ctre.CANifier.LEDChannel # value = LEDChannel.C
        __members__: dict # value = {'A': LEDChannel.A, 'B': LEDChannel.B, 'C': LEDChannel.C}
        pass
    class PWMChannel():
        """
        Enum for the PWM Input Channels

        Members:

          PWMChannel0 : PWM Channel 0

          PWMChannel1 : PWM Channel 1

          PWMChannel2 : PWM Channel 2

          PWMChannel3 : PWM Channel 3
        """
        def __eq__(self, arg0: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, arg0: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, arg0: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, arg0: int) -> None: ...
        @property
        def name(self) -> None:
            """
            :type: None
            """
        PWMChannel0: ctre._ctre.CANifier.PWMChannel # value = PWMChannel.PWMChannel0
        PWMChannel1: ctre._ctre.CANifier.PWMChannel # value = PWMChannel.PWMChannel1
        PWMChannel2: ctre._ctre.CANifier.PWMChannel # value = PWMChannel.PWMChannel2
        PWMChannel3: ctre._ctre.CANifier.PWMChannel # value = PWMChannel.PWMChannel3
        __members__: dict # value = {'PWMChannel0': PWMChannel.PWMChannel0, 'PWMChannel1': PWMChannel.PWMChannel1, 'PWMChannel2': PWMChannel.PWMChannel2, 'PWMChannel3': PWMChannel.PWMChannel3}
        pass
    class PinValues():
        """
        Structure to hold the pin values.
        """
        def __init__(self) -> None: ...
        @property
        def LIMF(self) -> bool:
            """
            Forward limit pin

            :type: bool
            """
        @LIMF.setter
        def LIMF(self, arg0: bool) -> None:
            """
            Forward limit pin
            """
        @property
        def LIMR(self) -> bool:
            """
            Reverse limit pin

            :type: bool
            """
        @LIMR.setter
        def LIMR(self, arg0: bool) -> None:
            """
            Reverse limit pin
            """
        @property
        def QUAD_A(self) -> bool:
            """
            Quadrature A pin

            :type: bool
            """
        @QUAD_A.setter
        def QUAD_A(self, arg0: bool) -> None:
            """
            Quadrature A pin
            """
        @property
        def QUAD_B(self) -> bool:
            """
            Quadrature B pin

            :type: bool
            """
        @QUAD_B.setter
        def QUAD_B(self, arg0: bool) -> None:
            """
            Quadrature B pin
            """
        @property
        def QUAD_IDX(self) -> bool:
            """
            Quadrature Idx pin

            :type: bool
            """
        @QUAD_IDX.setter
        def QUAD_IDX(self, arg0: bool) -> None:
            """
            Quadrature Idx pin
            """
        @property
        def SCL(self) -> bool:
            """
            SCL pin

            :type: bool
            """
        @SCL.setter
        def SCL(self, arg0: bool) -> None:
            """
            SCL pin
            """
        @property
        def SDA(self) -> bool:
            """
            SDA pin

            :type: bool
            """
        @SDA.setter
        def SDA(self, arg0: bool) -> None:
            """
            SDA pin
            """
        @property
        def SPI_CLK_PWM0(self) -> bool:
            """
            SPI_CLK_PWM0 pin

            :type: bool
            """
        @SPI_CLK_PWM0.setter
        def SPI_CLK_PWM0(self, arg0: bool) -> None:
            """
            SPI_CLK_PWM0 pin
            """
        @property
        def SPI_CS_PWM3(self) -> bool:
            """
            SPI_CS_PWM3 pin

            :type: bool
            """
        @SPI_CS_PWM3.setter
        def SPI_CS_PWM3(self, arg0: bool) -> None:
            """
            SPI_CS_PWM3 pin
            """
        @property
        def SPI_MISO_PWM2(self) -> bool:
            """
            SPI_MISO_PWM2 pin

            :type: bool
            """
        @SPI_MISO_PWM2.setter
        def SPI_MISO_PWM2(self, arg0: bool) -> None:
            """
            SPI_MISO_PWM2 pin
            """
        @property
        def SPI_MOSI_PWM1(self) -> bool:
            """
            SPI_MOSI_PWM1 pin

            :type: bool
            """
        @SPI_MOSI_PWM1.setter
        def SPI_MOSI_PWM1(self, arg0: bool) -> None:
            """
            SPI_MOSI_PWM1 pin
            """
        pass
    def __init__(self, deviceNumber: int) -> None: 
        """
        Constructor.

        :param deviceNumber: The CAN Device ID of the CANifier.
        """
    def clearStickyFaults(self, timeoutMs: int = 0) -> ErrorCode: 
        """
        Clears the Sticky Faults

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configAllSettings(self, allConfigs: CANifierConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures all persistent settings.

        :param allConfigs: Object with all of the persistant settings

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnLimitF(self, clearPositionOnLimitF: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Enables clearing the position of the feedback sensor when the forward
        limit switch is triggered

        :param clearPositionOnLimitF: Whether clearing is enabled, defaults false

        :param timeoutMs:    Timeout value in ms. If nonzero, function will wait for
                             config success and report an error if it times out.
                             If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnLimitR(self, clearPositionOnLimitR: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Enables clearing the position of the feedback sensor when the reverse
        limit switch is triggered

        :param clearPositionOnLimitR: Whether clearing is enabled, defaults false

        :param timeoutMs:    Timeout value in ms. If nonzero, function will wait for
                             config success and report an error if it times out.
                             If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnQuadIdx(self, clearPositionOnQuadIdx: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Enables clearing the position of the feedback sensor when the quadrature index signal
        is detected

        :param clearPositionOnQuadIdx: Whether clearing is enabled, defaults false

        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.
                              If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configFactoryDefault(self, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures all persistent settings to defaults (overloaded so timeoutMs is 50 ms).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configGetCustomParam(self, paramIndex: int, timeoutMs: int = 0) -> int: 
        """
        Gets the value of a custom parameter. This is for arbitrary use.

        Sometimes it is necessary to save calibration/duty cycle/output
        information in the device. Particularly if the
        device is part of a subsystem that can be replaced.

        :param paramIndex: Index of custom parameter. [0-1]

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Value of the custom param.
        """
    @typing.overload
    def configGetParameter(self, param: ParamEnum, ordinal: int, timeoutMs: int = 0) -> float: 
        """
        Gets a parameter. Generally this is not used.
        This can be utilized in
        - Using new features without updating API installation.
        - Errata workarounds to circumvent API implementation.
        - Allows for rapid testing / unit testing of firmware.

        :param param: Parameter enumeration.

        :param ordinal: Ordinal of parameter.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Value of parameter.

        Gets a parameter by passing an int by reference

        :param param: Parameter enumeration

        :param valueToSend: Value to send to parameter

        :param valueReceived: Reference to integer to receive

        :param subValue: SubValue of parameter

        :param ordinal: Ordinal of parameter

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                     config success and report an error if it times out.
                     If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configGetParameter(self, param: ParamEnum, valueToSend: int, valueReceived: int, subValue: int, ordinal: int, timeoutMs: int) -> ErrorCode: ...
    def configSetCustomParam(self, newValue: int, paramIndex: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the value of a custom parameter. This is for arbitrary use.

        Sometimes it is necessary to save calibration/duty cycle/output
        information in the device. Particularly if the
        device is part of a subsystem that can be replaced.

        :param newValue: Value for custom parameter.

        :param paramIndex: Index of custom parameter. [0-1]

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSetParameter(self, param: ParamEnum, value: float, subValue: int, ordinal: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets a parameter. Generally this is not used.
        This can be utilized in
        - Using new features without updating API installation.
        - Errata workarounds to circumvent API implementation.
        - Allows for rapid testing / unit testing of firmware.

        :param param: Parameter enumeration.

        :param value: Value of parameter.

        :param subValue: Subvalue for parameter. Maximum value of 255.

        :param ordinal: Ordinal of parameter.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementPeriod(self, period: CANifierVelocityMeasPeriod, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the period of each velocity sample.
        Every 1ms a position value is sampled, and the delta between that sample
        and the position sampled kPeriod ms ago is inserted into a filter.
        kPeriod is configured with this function.

        :param period: Desired period for the velocity measurement.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementWindow(self, windowSize: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the number of velocity samples used in the rolling average velocity
        measurement.

        :param windowSize: Number of samples in the rolling average of velocity
                  measurement. Valid values are 1,2,4,8,16,32. If another
                  value is specified, it will truncate to nearest support value.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @staticmethod
    def destroyAllCANifiers() -> None: 
        """
        Destructs all CANifier objects
        """
    def enablePWMOutput(self, pwmChannel: int, bEnable: bool) -> ErrorCode: 
        """
        Enables PWM Outputs
        Currently supports PWM 0, PWM 1, and PWM 2

        :param pwmChannel: Index of the PWM channel to enable.

        :param bEnable: True" enables output on the pwm channel.
        """
    def getAllConfigs(self, allConfigs: CANifierConfiguration, timeoutMs: int = 50) -> None: 
        """
        Gets all persistant settings.

        :param allConfigs: Object with all of the persistant settings

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.
        """
    def getBusVoltage(self) -> float: 
        """
        Gets the bus voltage seen by the device.

        :returns: The bus voltage value (in volts).
        """
    def getFaults(self, toFill: CANifierFaults) -> ErrorCode: 
        """
        Gets the CANifier fault status

        :param toFill: Container for fault statuses.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getFirmwareVersion(self) -> int: 
        """
        Gets the firmware version of the device.

        :returns: Firmware version of device.
        """
    def getGeneralInput(self, inputPin: CANifier.GeneralPin) -> bool: 
        """
        Gets the state of the specified pin

        :param inputPin: The index of the pin.

        :returns: The state of the pin.
        """
    def getGeneralInputs(self, allPins: CANifier.PinValues) -> ErrorCode: 
        """
        Gets the state of all General Pins

        :param allPins: A structure to fill with the current state of all pins.
        """
    def getLastError(self) -> ErrorCode: 
        """
        Call GetLastError() generated by this object.
        Not all functions return an error code but can
        potentially report errors.

        This function can be used to retrieve those error codes.

        :returns: The last ErrorCode generated.
        """
    def getPWMInput(self, pwmChannel: CANifier.PWMChannel) -> typing.Tuple[ErrorCode, typing.List[float[2]]]: 
        """
        Gets the PWM Input

        :param pwmChannel: PWM channel to get.

        :param pulseWidthAndPeriod: Double array to hold Duty Cycle [0] and Period [1].
        """
    def getQuadraturePosition(self) -> int: 
        """
        Gets the quadrature encoder's position

        :returns: Position of encoder
        """
    def getQuadratureVelocity(self) -> int: 
        """
        Gets the quadrature encoder's velocity

        :returns: Velocity of encoder
        """
    def getStatusFramePeriod(self, frame: CANifierStatusFrame, timeoutMs: int = 0) -> int: 
        """
        Gets the period of the given status frame.

        :param frame: Frame to get the period of.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Period of the given status frame.
        """
    def getStickyFaults(self, toFill: CANifierStickyFaults) -> ErrorCode: 
        """
        Gets the CANifier sticky fault status

        :param toFill: Container for sticky fault statuses.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def hasResetOccurred(self) -> bool: 
        """
        Returns true if the device has reset since last call.

        :returns: Has a Device Reset Occurred?
        """
    def setControlFramePeriod(self, frame: CANifierControlFrame, periodMs: int) -> ErrorCode: 
        """
        Sets the period of the given control frame.

        :param frame: Frame whose period is to be changed.

        :param periodMs: Period in ms for the given frame.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setGeneralOutput(self, outputPin: CANifier.GeneralPin, outputValue: bool, outputEnable: bool) -> ErrorCode: 
        """
        Sets the output of a General Pin

        :param outputPin: The pin to use as output.

        :param outputValue: The desired output state.

        :param outputEnable: Whether this pin is an output. "True" enables output.
        """
    def setGeneralOutputs(self, outputBits: int, isOutputBits: int) -> ErrorCode: 
        """
        Sets the output of all General Pins

        :param outputBits: A bit mask of all the output states.  LSB->MSB is in the order of the #GeneralPin enum.

        :param isOutputBits: A boolean bit mask that sets the pins to be outputs or inputs.  A bit of 1 enables output.
        """
    def setLEDOutput(self, percentOutput: float, ledChannel: CANifier.LEDChannel) -> ErrorCode: 
        """
        Sets the LED Output

        :param percentOutput: Output duty cycle expressed as percentage.

        :param ledChannel: Channel to set the output of.
        """
    def setPWMOutput(self, pwmChannel: int, dutyCycle: float) -> ErrorCode: 
        """
        Sets the PWM Output
        Currently supports PWM 0, PWM 1, and PWM 2

        :param pwmChannel: Index of the PWM channel to output.

        :param dutyCycle: Duty Cycle (0 to 1) to output.  Default period of the signal is 4.2 ms.
        """
    def setQuadraturePosition(self, newPosition: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the quadrature encoder's position

        :param newPosition: Position to set

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                   config success and report an error if it times out.
                   If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setStatusFramePeriod(self, statusFrame: CANifierStatusFrame, periodMs: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the period of the given status frame.

        :param statusFrame: Frame whose period is to be changed.

        :param periodMs: Period in ms for the given frame.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                   config success and report an error if it times out.
                   If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @property
    def PWMChannelCount(self) -> int:
        """
        Number of PWM channels available to CANifier

        :type: int
        """
    pass
class CANifierConfigUtils():
    """
    Util class to help with configuring CANifier
    """
    def __init__(self) -> None: ...
    @staticmethod
    def clearPositionOnLimitFDifferent(settings: CANifierConfiguration) -> bool: ...
    @staticmethod
    def clearPositionOnLimitRDifferent(settings: CANifierConfiguration) -> bool: ...
    @staticmethod
    def clearPositionOnQuadIdxDifferent(settings: CANifierConfiguration) -> bool: ...
    @staticmethod
    def customParam0Different(settings: CANifierConfiguration) -> bool: ...
    @staticmethod
    def customParam1Different(settings: CANifierConfiguration) -> bool: ...
    @staticmethod
    def velocityMeasurementPeriodDifferent(settings: CANifierConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    @staticmethod
    def velocityMeasurementWindowDifferent(settings: CANifierConfiguration) -> bool: ...
    pass
class CANifierConfiguration(CustomParamConfiguration):
    """
    Configurables available to CANifier
    """
    def __init__(self) -> None: ...
    @typing.overload
    def toString(self) -> str: 
        """
        :returns: String representation of configs



        :param prependString: String to prepend to configs

        :returns: String representation of configs
        """
    @typing.overload
    def toString(self, prependString: str) -> str: ...
    @property
    def clearPositionOnLimitF(self) -> bool:
        """
        Whether to clear sensor position on forward limit

        :type: bool
        """
    @clearPositionOnLimitF.setter
    def clearPositionOnLimitF(self, arg0: bool) -> None:
        """
        Whether to clear sensor position on forward limit
        """
    @property
    def clearPositionOnLimitR(self) -> bool:
        """
        Whether to clear sensor position on reverse limit

        :type: bool
        """
    @clearPositionOnLimitR.setter
    def clearPositionOnLimitR(self, arg0: bool) -> None:
        """
        Whether to clear sensor position on reverse limit
        """
    @property
    def clearPositionOnQuadIdx(self) -> bool:
        """
        Whether to clear sensor position on index

        :type: bool
        """
    @clearPositionOnQuadIdx.setter
    def clearPositionOnQuadIdx(self, arg0: bool) -> None:
        """
        Whether to clear sensor position on index
        """
    @property
    def velocityMeasurementPeriod(self) -> CANifierVelocityMeasPeriod:
        """
        Velocity measurement period to use

        :type: CANifierVelocityMeasPeriod
        """
    @velocityMeasurementPeriod.setter
    def velocityMeasurementPeriod(self, arg0: CANifierVelocityMeasPeriod) -> None:
        """
        Velocity measurement period to use
        """
    @property
    def velocityMeasurementWindow(self) -> int:
        """
        Velocity measurement window to use

        :type: int
        """
    @velocityMeasurementWindow.setter
    def velocityMeasurementWindow(self, arg0: int) -> None:
        """
        Velocity measurement window to use
        """
    pass
class CANifierControlFrame():
    """
    Enumerated type for status frame types.

    Members:

      CANifier_Control_1_General

      CANifier_Control_2_PwmOutput
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    CANifier_Control_1_General: ctre._ctre.CANifierControlFrame # value = CANifierControlFrame.CANifier_Control_1_General
    CANifier_Control_2_PwmOutput: ctre._ctre.CANifierControlFrame # value = CANifierControlFrame.CANifier_Control_2_PwmOutput
    __members__: dict # value = {'CANifier_Control_1_General': CANifierControlFrame.CANifier_Control_1_General, 'CANifier_Control_2_PwmOutput': CANifierControlFrame.CANifier_Control_2_PwmOutput}
    pass
class CANifierFaults():
    """
    Faults available to CANifier (Currently has none)
    """
    @typing.overload
    def __init__(self) -> None: 
        """
        Updates current fault list with specified bit field of faults

        :param bits: bit field of faults to update with
        """
    @typing.overload
    def __init__(self, bits: int) -> None: ...
    def hasAnyFault(self) -> bool: 
        """
        :returns: true if any faults are tripped
        """
    def toBitfield(self) -> int: 
        """
        :returns: Current fault list as a bit field
        """
    pass
class CANifierStatusFrame():
    """
    Enumerated type for status frame types.

    Members:

      Status_1_General

      Status_2_General

      Status_3_PwmInputs0

      Status_4_PwmInputs1

      Status_5_PwmInputs2

      Status_6_PwmInputs3

      Status_8_Misc
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Status_1_General: ctre._ctre.CANifierStatusFrame # value = CANifierStatusFrame.Status_1_General
    Status_2_General: ctre._ctre.CANifierStatusFrame # value = CANifierStatusFrame.Status_2_General
    Status_3_PwmInputs0: ctre._ctre.CANifierStatusFrame # value = CANifierStatusFrame.Status_3_PwmInputs0
    Status_4_PwmInputs1: ctre._ctre.CANifierStatusFrame # value = CANifierStatusFrame.Status_4_PwmInputs1
    Status_5_PwmInputs2: ctre._ctre.CANifierStatusFrame # value = CANifierStatusFrame.Status_5_PwmInputs2
    Status_6_PwmInputs3: ctre._ctre.CANifierStatusFrame # value = CANifierStatusFrame.Status_6_PwmInputs3
    Status_8_Misc: ctre._ctre.CANifierStatusFrame # value = CANifierStatusFrame.Status_8_Misc
    __members__: dict # value = {'Status_1_General': CANifierStatusFrame.Status_1_General, 'Status_2_General': CANifierStatusFrame.Status_2_General, 'Status_3_PwmInputs0': CANifierStatusFrame.Status_3_PwmInputs0, 'Status_4_PwmInputs1': CANifierStatusFrame.Status_4_PwmInputs1, 'Status_5_PwmInputs2': CANifierStatusFrame.Status_5_PwmInputs2, 'Status_6_PwmInputs3': CANifierStatusFrame.Status_6_PwmInputs3, 'Status_8_Misc': CANifierStatusFrame.Status_8_Misc}
    pass
class CANifierStickyFaults():
    """
    Sticky Faults for CANifier (Currently has none)
    """
    @typing.overload
    def __init__(self) -> None: 
        """
        Updates current fault list with specified bit field of faults

        :param bits: bit field of faults to update with
        """
    @typing.overload
    def __init__(self, bits: int) -> None: ...
    def hasAnyFault(self) -> bool: 
        """
        :returns: true if any faults are tripped
        """
    def toBitfield(self) -> int: 
        """
        :returns: Current fault list as a bit field
        """
    pass
class CANifierVelocityMeasPeriod():
    """
    Enum for velocity periods used for CANifier

    Members:

      Period_1Ms : 1ms velocity measurement period

      Period_2Ms : 2ms velocity measurement period

      Period_5Ms : 5ms velocity measurement period

      Period_10Ms : 10ms velocity measurement period

      Period_20Ms : 20ms velocity measurement period

      Period_25Ms : 25ms velocity measurement period

      Period_50Ms : 50ms velocity measurement period

      Period_100Ms : 100ms velocity measurement period
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Period_100Ms: ctre._ctre.CANifierVelocityMeasPeriod # value = CANifierVelocityMeasPeriod.Period_100Ms
    Period_10Ms: ctre._ctre.CANifierVelocityMeasPeriod # value = CANifierVelocityMeasPeriod.Period_10Ms
    Period_1Ms: ctre._ctre.CANifierVelocityMeasPeriod # value = CANifierVelocityMeasPeriod.Period_1Ms
    Period_20Ms: ctre._ctre.CANifierVelocityMeasPeriod # value = CANifierVelocityMeasPeriod.Period_20Ms
    Period_25Ms: ctre._ctre.CANifierVelocityMeasPeriod # value = CANifierVelocityMeasPeriod.Period_25Ms
    Period_2Ms: ctre._ctre.CANifierVelocityMeasPeriod # value = CANifierVelocityMeasPeriod.Period_2Ms
    Period_50Ms: ctre._ctre.CANifierVelocityMeasPeriod # value = CANifierVelocityMeasPeriod.Period_50Ms
    Period_5Ms: ctre._ctre.CANifierVelocityMeasPeriod # value = CANifierVelocityMeasPeriod.Period_5Ms
    __members__: dict # value = {'Period_1Ms': CANifierVelocityMeasPeriod.Period_1Ms, 'Period_2Ms': CANifierVelocityMeasPeriod.Period_2Ms, 'Period_5Ms': CANifierVelocityMeasPeriod.Period_5Ms, 'Period_10Ms': CANifierVelocityMeasPeriod.Period_10Ms, 'Period_20Ms': CANifierVelocityMeasPeriod.Period_20Ms, 'Period_25Ms': CANifierVelocityMeasPeriod.Period_25Ms, 'Period_50Ms': CANifierVelocityMeasPeriod.Period_50Ms, 'Period_100Ms': CANifierVelocityMeasPeriod.Period_100Ms}
    pass
class CANifierVelocityMeasPeriodRoutines():
    """
    Class to handle routines specific to VelocityMeasPeriod
    """
    def __init__(self) -> None: ...
    @staticmethod
    def toString(value: CANifierVelocityMeasPeriod) -> str: 
        """
        String representation of specified CANifierVelocityMeasPeriod

        :param value: CANifierVelocityMeasPeriod to convert to a string

        :returns: string representation of CANifierVelocityMeasPeriod
        """
    pass
class ControlFrame():
    """
    Control Frames for motor controllers

    Members:

      Control_3_General : Control

      Control_4_Advanced : Advanced Control

      Control_6_MotProfAddTrajPoint : Trajectory points
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Control_3_General: ctre._ctre.ControlFrame # value = ControlFrame.Control_3_General
    Control_4_Advanced: ctre._ctre.ControlFrame # value = ControlFrame.Control_4_Advanced
    Control_6_MotProfAddTrajPoint: ctre._ctre.ControlFrame # value = ControlFrame.Control_6_MotProfAddTrajPoint
    __members__: dict # value = {'Control_3_General': ControlFrame.Control_3_General, 'Control_4_Advanced': ControlFrame.Control_4_Advanced, 'Control_6_MotProfAddTrajPoint': ControlFrame.Control_6_MotProfAddTrajPoint}
    pass
class ControlFrameEnhanced():
    """
    Control Frames for enhanced motor controllers

    Members:

      Control_3_General_ : Control

      Control_4_Advanced_ : Advanced Control

      Control_5_FeedbackOutputOverride_ : Override feedback output

      Control_6_MotProfAddTrajPoint_ : Trajectory points
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Control_3_General_: ctre._ctre.ControlFrameEnhanced # value = ControlFrameEnhanced.Control_3_General_
    Control_4_Advanced_: ctre._ctre.ControlFrameEnhanced # value = ControlFrameEnhanced.Control_4_Advanced_
    Control_5_FeedbackOutputOverride_: ctre._ctre.ControlFrameEnhanced # value = ControlFrameEnhanced.Control_5_FeedbackOutputOverride_
    Control_6_MotProfAddTrajPoint_: ctre._ctre.ControlFrameEnhanced # value = ControlFrameEnhanced.Control_6_MotProfAddTrajPoint_
    __members__: dict # value = {'Control_3_General_': ControlFrameEnhanced.Control_3_General_, 'Control_4_Advanced_': ControlFrameEnhanced.Control_4_Advanced_, 'Control_5_FeedbackOutputOverride_': ControlFrameEnhanced.Control_5_FeedbackOutputOverride_, 'Control_6_MotProfAddTrajPoint_': ControlFrameEnhanced.Control_6_MotProfAddTrajPoint_}
    pass
class ControlFrameRoutines():
    """
    Class to handle promotion of controlFrame to controlFrameEnhanced
    """
    def __init__(self) -> None: ...
    pass
class ControlMode():
    """
    Choose the control mode for a motor controller.
    Consult product specific documentation to determine what is available/supported.

    Members:

      PercentOutput : Percent output [-1,1]

      Position : Position closed loop

      Velocity : Velocity closed loop

      Current : Input current closed loop

      Follower : Follow other motor controller

      MotionProfile : Motion Profile

      MotionMagic : Motion Magic

      MotionProfileArc : Motion Profile with auxiliary output

      MusicTone : Plays a single tone.  Frequency (hz) is passed into set.

      Disabled : Disable Motor Controller
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Current: ctre._ctre.ControlMode # value = ControlMode.Current
    Disabled: ctre._ctre.ControlMode # value = ControlMode.Disabled
    Follower: ctre._ctre.ControlMode # value = ControlMode.Follower
    MotionMagic: ctre._ctre.ControlMode # value = ControlMode.MotionMagic
    MotionProfile: ctre._ctre.ControlMode # value = ControlMode.MotionProfile
    MotionProfileArc: ctre._ctre.ControlMode # value = ControlMode.MotionProfileArc
    MusicTone: ctre._ctre.ControlMode # value = ControlMode.MusicTone
    PercentOutput: ctre._ctre.ControlMode # value = ControlMode.PercentOutput
    Position: ctre._ctre.ControlMode # value = ControlMode.Position
    Velocity: ctre._ctre.ControlMode # value = ControlMode.Velocity
    __members__: dict # value = {'PercentOutput': ControlMode.PercentOutput, 'Position': ControlMode.Position, 'Velocity': ControlMode.Velocity, 'Current': ControlMode.Current, 'Follower': ControlMode.Follower, 'MotionProfile': ControlMode.MotionProfile, 'MotionMagic': ControlMode.MotionMagic, 'MotionProfileArc': ControlMode.MotionProfileArc, 'MusicTone': ControlMode.MusicTone, 'Disabled': ControlMode.Disabled}
    pass
class BaseMotorControllerUtil(CustomParamConfigUtil):
    """
    Util class to help with Base Motor Controller configs
    """
    def __init__(self) -> None: ...
    @staticmethod
    def auxPIDPolarityDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def clearPositionOnLimitFDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def clearPositionOnLimitRDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def clearPositionOnQuadIdxDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def closedloopRampDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def feedbackNotContinuousDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def forwardSoftLimitEnableDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def forwardSoftLimitThresholdDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def limitSwitchDisableNeutralOnLOSDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def motionAccelerationDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def motionCruiseVelocityDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def motionProfileTrajectoryPeriodDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def motionSCurveStrength(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def neutralDeadbandDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def nominalOutputForwardDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def nominalOutputReverseDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def openloopRampDifferent(settings: BaseMotorControllerConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    @staticmethod
    def peakOutputForwardDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def peakOutputReverseDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def pulseWidthPeriod_EdgesPerRotDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def pulseWidthPeriod_FilterWindowSzDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def remoteSensorClosedLoopDisableNeutralOnLOSDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def reverseSoftLimitEnableDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def reverseSoftLimitThresholdDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def softLimitDisableNeutralOnLOSDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def trajectoryInterpolationEnableDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def velocityMeasurementPeriodDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def velocityMeasurementWindowDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def voltageCompSaturationDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    @staticmethod
    def voltageMeasurementFilterDifferent(settings: BaseMotorControllerConfiguration) -> bool: ...
    pass
class BaseTalonConfiguration(BaseMotorControllerConfiguration, CustomParamConfiguration):
    """
    Configurables available to BaseTalon
    """
    def __init__(self, defaultFeedbackDevice: FeedbackDevice) -> None: ...
    @typing.overload
    def toString(self) -> str: 
        """
        :returns: String representation of all the configs



        :param prependString: String to prepend to all the configs

        :returns: String representation of all the configs
        """
    @typing.overload
    def toString(self, prependString: str) -> str: ...
    @property
    def auxiliaryPID(self) -> BaseTalonPIDSetConfiguration:
        """
        Auxiliary PID configuration

        :type: BaseTalonPIDSetConfiguration
        """
    @auxiliaryPID.setter
    def auxiliaryPID(self, arg0: BaseTalonPIDSetConfiguration) -> None:
        """
        Auxiliary PID configuration
        """
    @property
    def diff0Term(self) -> FeedbackDevice:
        """
        Feedback Device for Diff 0 Term
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        @code
        configs.diff0Term = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        configs.diff0Term = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        @endcode

        :type: FeedbackDevice
        """
    @diff0Term.setter
    def diff0Term(self, arg0: FeedbackDevice) -> None:
        """
        Feedback Device for Diff 0 Term
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        @code
        configs.diff0Term = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        configs.diff0Term = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        @endcode
        """
    @property
    def diff1Term(self) -> FeedbackDevice:
        """
        Feedback Device for Diff 1 Term
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        @code
        configs.diff1Term = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        configs.diff1Term = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        @endcode

        :type: FeedbackDevice
        """
    @diff1Term.setter
    def diff1Term(self, arg0: FeedbackDevice) -> None:
        """
        Feedback Device for Diff 1 Term
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        @code
        configs.diff1Term = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        configs.diff1Term = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        @endcode
        """
    @property
    def forwardLimitSwitchDeviceID(self) -> int:
        """
        Forward limit switch device ID

        Limit Switch device id isn't used unless device is a remote

        :type: int
        """
    @forwardLimitSwitchDeviceID.setter
    def forwardLimitSwitchDeviceID(self, arg0: int) -> None:
        """
        Forward limit switch device ID

        Limit Switch device id isn't used unless device is a remote
        """
    @property
    def forwardLimitSwitchNormal(self) -> LimitSwitchNormal:
        """
        Forward limit switch normally open/closed

        :type: LimitSwitchNormal
        """
    @forwardLimitSwitchNormal.setter
    def forwardLimitSwitchNormal(self, arg0: LimitSwitchNormal) -> None:
        """
        Forward limit switch normally open/closed
        """
    @property
    def forwardLimitSwitchSource(self) -> LimitSwitchSource:
        """
        Forward Limit Switch Source

        User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature

        :type: LimitSwitchSource
        """
    @forwardLimitSwitchSource.setter
    def forwardLimitSwitchSource(self, arg0: LimitSwitchSource) -> None:
        """
        Forward Limit Switch Source

        User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature
        """
    @property
    def primaryPID(self) -> BaseTalonPIDSetConfiguration:
        """
        Primary PID configuration

        :type: BaseTalonPIDSetConfiguration
        """
    @primaryPID.setter
    def primaryPID(self, arg0: BaseTalonPIDSetConfiguration) -> None:
        """
        Primary PID configuration
        """
    @property
    def reverseLimitSwitchDeviceID(self) -> int:
        """
        Reverse limit switch device ID

        Limit Switch device id isn't used unless device is a remote

        :type: int
        """
    @reverseLimitSwitchDeviceID.setter
    def reverseLimitSwitchDeviceID(self, arg0: int) -> None:
        """
        Reverse limit switch device ID

        Limit Switch device id isn't used unless device is a remote
        """
    @property
    def reverseLimitSwitchNormal(self) -> LimitSwitchNormal:
        """
        Reverse limit switch normally open/closed

        :type: LimitSwitchNormal
        """
    @reverseLimitSwitchNormal.setter
    def reverseLimitSwitchNormal(self, arg0: LimitSwitchNormal) -> None:
        """
        Reverse limit switch normally open/closed
        """
    @property
    def reverseLimitSwitchSource(self) -> LimitSwitchSource:
        """
        Reverse Limit Switch Source

        User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature

        :type: LimitSwitchSource
        """
    @reverseLimitSwitchSource.setter
    def reverseLimitSwitchSource(self, arg0: LimitSwitchSource) -> None:
        """
        Reverse Limit Switch Source

        User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature
        """
    @property
    def sum0Term(self) -> FeedbackDevice:
        """
        Feedback Device for Sum 0 Term
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        @code
        configs.sum0Term = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        configs.sum0Term = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        @endcode

        :type: FeedbackDevice
        """
    @sum0Term.setter
    def sum0Term(self, arg0: FeedbackDevice) -> None:
        """
        Feedback Device for Sum 0 Term
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        @code
        configs.sum0Term = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        configs.sum0Term = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        @endcode
        """
    @property
    def sum1Term(self) -> FeedbackDevice:
        """
        Feedback Device for Sum 1 Term
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        @code
        configs.sum1Term = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        configs.sum1Term = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        @endcode

        :type: FeedbackDevice
        """
    @sum1Term.setter
    def sum1Term(self, arg0: FeedbackDevice) -> None:
        """
        Feedback Device for Sum 1 Term
        Note the FeedbackDevice enum holds all possible sensor types.  Consult product documentation to confirm what is available.
        Alternatively the product specific enum can be used instead.
        @code
        configs.sum1Term = (FeedbackDevice)TalonSRXFeedbackDevice::QuadEncoder;
        configs.sum1Term = (FeedbackDevice)TalonFXFeedbackDevice::IntegratedSensor;
        @endcode
        """
    pass
class DemandType():
    """
    How to interpret a demand value.

    Members:

      Neutral : Ignore the demand value and apply neutral/no-change.

      AuxPID : When closed-looping, set the target of the aux PID loop to the demand value.

    When following, follow the processed output of the combined
    primary/aux PID output of the master.  The demand value is ignored.
    Although it is much cleaner to use the 2-param Follow() in such cases.

      ArbitraryFeedForward : When closed-looping, add demand arbitrarily to the closed-loop output.
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    ArbitraryFeedForward: ctre._ctre.DemandType # value = DemandType.ArbitraryFeedForward
    AuxPID: ctre._ctre.DemandType # value = DemandType.AuxPID
    Neutral: ctre._ctre.DemandType # value = DemandType.Neutral
    __members__: dict # value = {'Neutral': DemandType.Neutral, 'AuxPID': DemandType.AuxPID, 'ArbitraryFeedForward': DemandType.ArbitraryFeedForward}
    pass
class ErrorCode():
    """
    Members:

      OK

      OKAY : //!< No Error - Function executed as expected

      CAN_MSG_STALE

      CAN_TX_FULL

      TxFailed : //!< Could not transmit the CAN frame.

      InvalidParamValue : //!< Caller passed an invalid param

      CAN_INVALID_PARAM

      RxTimeout : //!< CAN frame has not been received within specified period of time.

      CAN_MSG_NOT_FOUND

      TxTimeout : //!< Not used.

      CAN_NO_MORE_TX_JOBS

      UnexpectedArbId : //!< Specified CAN Id is invalid.

      CAN_NO_SESSIONS_AVAIL

      BufferFull : //!< Caller attempted to insert data into a buffer that is full.

      CAN_OVERFLOW

      SensorNotPresent : //!< Sensor is not present

      FirmwareTooOld

      CouldNotChangePeriod

      BufferFailure

      FirwmwareNonFRC

      GeneralError : //!< User Specified General Error

      GENERAL_ERROR

      SIG_NOT_UPDATED

      SigNotUpdated : //!< Have not received an value response for signal.

      NotAllPIDValuesUpdated

      GEN_PORT_ERROR

      PORT_MODULE_TYPE_MISMATCH

      GEN_MODULE_ERROR

      MODULE_NOT_INIT_SET_ERROR

      MODULE_NOT_INIT_GET_ERROR

      WheelRadiusTooSmall

      TicksPerRevZero

      DistanceBetweenWheelsTooSmall

      GainsAreNotSet

      WrongRemoteLimitSwitchSource

      DoubleVoltageCompensatingWPI

      IncompatibleMode

      InvalidHandle : //!< Handle does not match stored map of handles

      FeatureRequiresHigherFirm

      MotorControllerFeatureRequiresHigherFirm

      TalonFeatureRequiresHigherFirm

      ConfigFactoryDefaultRequiresHigherFirm

      ConfigMotionSCurveRequiresHigherFirm

      TalonFXFirmwarePreVBatDetect

      LibraryCouldNotBeLoaded

      MissingRoutineInLibrary

      ResourceNotAvailable

      MusicFileNotFound

      MusicFileWrongSize

      MusicFileTooNew

      MusicFileInvalid

      InvalidOrchestraAction

      MusicFileTooOld

      MusicInterrupted

      MusicNotSupported

      PulseWidthSensorNotPresent : //!< Special Code for "isSensorPresent"

      GeneralWarning

      FeatureNotSupported

      NotImplemented

      FirmVersionCouldNotBeRetrieved

      FeaturesNotAvailableYet

      ControlModeNotValid

      ControlModeNotSupportedYet

      CascadedPIDNotSupporteYet

      AuxiliaryPIDNotSupportedYet

      RemoteSensorsNotSupportedYet

      MotProfFirmThreshold

      MotProfFirmThreshold2
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    AuxiliaryPIDNotSupportedYet: ctre._ctre.ErrorCode # value = ErrorCode.CascadedPIDNotSupporteYet
    BufferFailure: ctre._ctre.ErrorCode # value = ErrorCode.BufferFailure
    BufferFull: ctre._ctre.ErrorCode # value = ErrorCode.BufferFull
    CAN_INVALID_PARAM: ctre._ctre.ErrorCode # value = ErrorCode.InvalidParamValue
    CAN_MSG_NOT_FOUND: ctre._ctre.ErrorCode # value = ErrorCode.RxTimeout
    CAN_MSG_STALE: ctre._ctre.ErrorCode # value = ErrorCode.CAN_MSG_STALE
    CAN_NO_MORE_TX_JOBS: ctre._ctre.ErrorCode # value = ErrorCode.TxTimeout
    CAN_NO_SESSIONS_AVAIL: ctre._ctre.ErrorCode # value = ErrorCode.UnexpectedArbId
    CAN_OVERFLOW: ctre._ctre.ErrorCode # value = ErrorCode.CAN_OVERFLOW
    CAN_TX_FULL: ctre._ctre.ErrorCode # value = ErrorCode.CAN_TX_FULL
    CascadedPIDNotSupporteYet: ctre._ctre.ErrorCode # value = ErrorCode.CascadedPIDNotSupporteYet
    ConfigFactoryDefaultRequiresHigherFirm: ctre._ctre.ErrorCode # value = ErrorCode.ConfigFactoryDefaultRequiresHigherFirm
    ConfigMotionSCurveRequiresHigherFirm: ctre._ctre.ErrorCode # value = ErrorCode.ConfigMotionSCurveRequiresHigherFirm
    ControlModeNotSupportedYet: ctre._ctre.ErrorCode # value = ErrorCode.ControlModeNotSupportedYet
    ControlModeNotValid: ctre._ctre.ErrorCode # value = ErrorCode.ControlModeNotValid
    CouldNotChangePeriod: ctre._ctre.ErrorCode # value = ErrorCode.CouldNotChangePeriod
    DistanceBetweenWheelsTooSmall: ctre._ctre.ErrorCode # value = ErrorCode.DistanceBetweenWheelsTooSmall
    DoubleVoltageCompensatingWPI: ctre._ctre.ErrorCode # value = ErrorCode.DoubleVoltageCompensatingWPI
    FeatureNotSupported: ctre._ctre.ErrorCode # value = ErrorCode.FeatureNotSupported
    FeatureRequiresHigherFirm: ctre._ctre.ErrorCode # value = ErrorCode.FeatureRequiresHigherFirm
    FeaturesNotAvailableYet: ctre._ctre.ErrorCode # value = ErrorCode.FeaturesNotAvailableYet
    FirmVersionCouldNotBeRetrieved: ctre._ctre.ErrorCode # value = ErrorCode.FirmVersionCouldNotBeRetrieved
    FirmwareTooOld: ctre._ctre.ErrorCode # value = ErrorCode.FirmwareTooOld
    FirwmwareNonFRC: ctre._ctre.ErrorCode # value = ErrorCode.FirwmwareNonFRC
    GENERAL_ERROR: ctre._ctre.ErrorCode # value = ErrorCode.GeneralError
    GEN_MODULE_ERROR: ctre._ctre.ErrorCode # value = ErrorCode.GEN_MODULE_ERROR
    GEN_PORT_ERROR: ctre._ctre.ErrorCode # value = ErrorCode.GEN_PORT_ERROR
    GainsAreNotSet: ctre._ctre.ErrorCode # value = ErrorCode.GainsAreNotSet
    GeneralError: ctre._ctre.ErrorCode # value = ErrorCode.GeneralError
    GeneralWarning: ctre._ctre.ErrorCode # value = ErrorCode.GeneralWarning
    IncompatibleMode: ctre._ctre.ErrorCode # value = ErrorCode.IncompatibleMode
    InvalidHandle: ctre._ctre.ErrorCode # value = ErrorCode.InvalidHandle
    InvalidOrchestraAction: ctre._ctre.ErrorCode # value = ErrorCode.InvalidOrchestraAction
    InvalidParamValue: ctre._ctre.ErrorCode # value = ErrorCode.InvalidParamValue
    LibraryCouldNotBeLoaded: ctre._ctre.ErrorCode # value = ErrorCode.LibraryCouldNotBeLoaded
    MODULE_NOT_INIT_GET_ERROR: ctre._ctre.ErrorCode # value = ErrorCode.MODULE_NOT_INIT_GET_ERROR
    MODULE_NOT_INIT_SET_ERROR: ctre._ctre.ErrorCode # value = ErrorCode.MODULE_NOT_INIT_SET_ERROR
    MissingRoutineInLibrary: ctre._ctre.ErrorCode # value = ErrorCode.MissingRoutineInLibrary
    MotProfFirmThreshold: ctre._ctre.ErrorCode # value = ErrorCode.MotProfFirmThreshold
    MotProfFirmThreshold2: ctre._ctre.ErrorCode # value = ErrorCode.MotProfFirmThreshold2
    MotorControllerFeatureRequiresHigherFirm: ctre._ctre.ErrorCode # value = ErrorCode.MotorControllerFeatureRequiresHigherFirm
    MusicFileInvalid: ctre._ctre.ErrorCode # value = ErrorCode.MusicFileInvalid
    MusicFileNotFound: ctre._ctre.ErrorCode # value = ErrorCode.MusicFileNotFound
    MusicFileTooNew: ctre._ctre.ErrorCode # value = ErrorCode.MusicFileTooNew
    MusicFileTooOld: ctre._ctre.ErrorCode # value = ErrorCode.MusicFileTooOld
    MusicFileWrongSize: ctre._ctre.ErrorCode # value = ErrorCode.MusicFileWrongSize
    MusicInterrupted: ctre._ctre.ErrorCode # value = ErrorCode.MusicInterrupted
    MusicNotSupported: ctre._ctre.ErrorCode # value = ErrorCode.MusicNotSupported
    NotAllPIDValuesUpdated: ctre._ctre.ErrorCode # value = ErrorCode.NotAllPIDValuesUpdated
    NotImplemented: ctre._ctre.ErrorCode # value = ErrorCode.NotImplemented
    OK: ctre._ctre.ErrorCode # value = ErrorCode.OK
    OKAY: ctre._ctre.ErrorCode # value = ErrorCode.OK
    PORT_MODULE_TYPE_MISMATCH: ctre._ctre.ErrorCode # value = ErrorCode.PORT_MODULE_TYPE_MISMATCH
    PulseWidthSensorNotPresent: ctre._ctre.ErrorCode # value = ErrorCode.PulseWidthSensorNotPresent
    RemoteSensorsNotSupportedYet: ctre._ctre.ErrorCode # value = ErrorCode.RemoteSensorsNotSupportedYet
    ResourceNotAvailable: ctre._ctre.ErrorCode # value = ErrorCode.ResourceNotAvailable
    RxTimeout: ctre._ctre.ErrorCode # value = ErrorCode.RxTimeout
    SIG_NOT_UPDATED: ctre._ctre.ErrorCode # value = ErrorCode.SIG_NOT_UPDATED
    SensorNotPresent: ctre._ctre.ErrorCode # value = ErrorCode.SensorNotPresent
    SigNotUpdated: ctre._ctre.ErrorCode # value = ErrorCode.SIG_NOT_UPDATED
    TalonFXFirmwarePreVBatDetect: ctre._ctre.ErrorCode # value = ErrorCode.TalonFXFirmwarePreVBatDetect
    TalonFeatureRequiresHigherFirm: ctre._ctre.ErrorCode # value = ErrorCode.MotorControllerFeatureRequiresHigherFirm
    TicksPerRevZero: ctre._ctre.ErrorCode # value = ErrorCode.TicksPerRevZero
    TxFailed: ctre._ctre.ErrorCode # value = ErrorCode.CAN_TX_FULL
    TxTimeout: ctre._ctre.ErrorCode # value = ErrorCode.TxTimeout
    UnexpectedArbId: ctre._ctre.ErrorCode # value = ErrorCode.UnexpectedArbId
    WheelRadiusTooSmall: ctre._ctre.ErrorCode # value = ErrorCode.WheelRadiusTooSmall
    WrongRemoteLimitSwitchSource: ctre._ctre.ErrorCode # value = ErrorCode.WrongRemoteLimitSwitchSource
    __members__: dict # value = {'OK': ErrorCode.OK, 'OKAY': ErrorCode.OK, 'CAN_MSG_STALE': ErrorCode.CAN_MSG_STALE, 'CAN_TX_FULL': ErrorCode.CAN_TX_FULL, 'TxFailed': ErrorCode.CAN_TX_FULL, 'InvalidParamValue': ErrorCode.InvalidParamValue, 'CAN_INVALID_PARAM': ErrorCode.InvalidParamValue, 'RxTimeout': ErrorCode.RxTimeout, 'CAN_MSG_NOT_FOUND': ErrorCode.RxTimeout, 'TxTimeout': ErrorCode.TxTimeout, 'CAN_NO_MORE_TX_JOBS': ErrorCode.TxTimeout, 'UnexpectedArbId': ErrorCode.UnexpectedArbId, 'CAN_NO_SESSIONS_AVAIL': ErrorCode.UnexpectedArbId, 'BufferFull': ErrorCode.BufferFull, 'CAN_OVERFLOW': ErrorCode.CAN_OVERFLOW, 'SensorNotPresent': ErrorCode.SensorNotPresent, 'FirmwareTooOld': ErrorCode.FirmwareTooOld, 'CouldNotChangePeriod': ErrorCode.CouldNotChangePeriod, 'BufferFailure': ErrorCode.BufferFailure, 'FirwmwareNonFRC': ErrorCode.FirwmwareNonFRC, 'GeneralError': ErrorCode.GeneralError, 'GENERAL_ERROR': ErrorCode.GeneralError, 'SIG_NOT_UPDATED': ErrorCode.SIG_NOT_UPDATED, 'SigNotUpdated': ErrorCode.SIG_NOT_UPDATED, 'NotAllPIDValuesUpdated': ErrorCode.NotAllPIDValuesUpdated, 'GEN_PORT_ERROR': ErrorCode.GEN_PORT_ERROR, 'PORT_MODULE_TYPE_MISMATCH': ErrorCode.PORT_MODULE_TYPE_MISMATCH, 'GEN_MODULE_ERROR': ErrorCode.GEN_MODULE_ERROR, 'MODULE_NOT_INIT_SET_ERROR': ErrorCode.MODULE_NOT_INIT_SET_ERROR, 'MODULE_NOT_INIT_GET_ERROR': ErrorCode.MODULE_NOT_INIT_GET_ERROR, 'WheelRadiusTooSmall': ErrorCode.WheelRadiusTooSmall, 'TicksPerRevZero': ErrorCode.TicksPerRevZero, 'DistanceBetweenWheelsTooSmall': ErrorCode.DistanceBetweenWheelsTooSmall, 'GainsAreNotSet': ErrorCode.GainsAreNotSet, 'WrongRemoteLimitSwitchSource': ErrorCode.WrongRemoteLimitSwitchSource, 'DoubleVoltageCompensatingWPI': ErrorCode.DoubleVoltageCompensatingWPI, 'IncompatibleMode': ErrorCode.IncompatibleMode, 'InvalidHandle': ErrorCode.InvalidHandle, 'FeatureRequiresHigherFirm': ErrorCode.FeatureRequiresHigherFirm, 'MotorControllerFeatureRequiresHigherFirm': ErrorCode.MotorControllerFeatureRequiresHigherFirm, 'TalonFeatureRequiresHigherFirm': ErrorCode.MotorControllerFeatureRequiresHigherFirm, 'ConfigFactoryDefaultRequiresHigherFirm': ErrorCode.ConfigFactoryDefaultRequiresHigherFirm, 'ConfigMotionSCurveRequiresHigherFirm': ErrorCode.ConfigMotionSCurveRequiresHigherFirm, 'TalonFXFirmwarePreVBatDetect': ErrorCode.TalonFXFirmwarePreVBatDetect, 'LibraryCouldNotBeLoaded': ErrorCode.LibraryCouldNotBeLoaded, 'MissingRoutineInLibrary': ErrorCode.MissingRoutineInLibrary, 'ResourceNotAvailable': ErrorCode.ResourceNotAvailable, 'MusicFileNotFound': ErrorCode.MusicFileNotFound, 'MusicFileWrongSize': ErrorCode.MusicFileWrongSize, 'MusicFileTooNew': ErrorCode.MusicFileTooNew, 'MusicFileInvalid': ErrorCode.MusicFileInvalid, 'InvalidOrchestraAction': ErrorCode.InvalidOrchestraAction, 'MusicFileTooOld': ErrorCode.MusicFileTooOld, 'MusicInterrupted': ErrorCode.MusicInterrupted, 'MusicNotSupported': ErrorCode.MusicNotSupported, 'PulseWidthSensorNotPresent': ErrorCode.PulseWidthSensorNotPresent, 'GeneralWarning': ErrorCode.GeneralWarning, 'FeatureNotSupported': ErrorCode.FeatureNotSupported, 'NotImplemented': ErrorCode.NotImplemented, 'FirmVersionCouldNotBeRetrieved': ErrorCode.FirmVersionCouldNotBeRetrieved, 'FeaturesNotAvailableYet': ErrorCode.FeaturesNotAvailableYet, 'ControlModeNotValid': ErrorCode.ControlModeNotValid, 'ControlModeNotSupportedYet': ErrorCode.ControlModeNotSupportedYet, 'CascadedPIDNotSupporteYet': ErrorCode.CascadedPIDNotSupporteYet, 'AuxiliaryPIDNotSupportedYet': ErrorCode.CascadedPIDNotSupporteYet, 'RemoteSensorsNotSupportedYet': ErrorCode.RemoteSensorsNotSupportedYet, 'MotProfFirmThreshold': ErrorCode.MotProfFirmThreshold, 'MotProfFirmThreshold2': ErrorCode.MotProfFirmThreshold2}
    pass
class Faults():
    """
    All the faults available to motor controllers
    """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates fault list with specified bit field of faults

        :param bits: bit field of faults to update with
        """
    @typing.overload
    def __init__(self, bits: int) -> None: ...
    def hasAnyFault(self) -> bool: 
        """
        :returns: true if any faults are tripped
        """
    def toBitfield(self) -> int: 
        """
        :returns: Current fault list as a bit field
        """
    def toString(self) -> str: 
        """
        :returns: string representation of current faults tripped
        """
    @property
    def APIError(self) -> bool:
        """
        API error detected.  Make sure API and firmware versions are compatible.

        :type: bool
        """
    @APIError.setter
    def APIError(self, arg0: bool) -> None:
        """
        API error detected.  Make sure API and firmware versions are compatible.
        """
    @property
    def ForwardLimitSwitch(self) -> bool:
        """
        Forward limit switch is tripped and device is trying to go forward
        Only trips when the device is limited

        :type: bool
        """
    @ForwardLimitSwitch.setter
    def ForwardLimitSwitch(self, arg0: bool) -> None:
        """
        Forward limit switch is tripped and device is trying to go forward
        Only trips when the device is limited
        """
    @property
    def ForwardSoftLimit(self) -> bool:
        """
        Sensor is beyond forward soft limit and device is trying to go forward
        Only trips when the device is limited

        :type: bool
        """
    @ForwardSoftLimit.setter
    def ForwardSoftLimit(self, arg0: bool) -> None:
        """
        Sensor is beyond forward soft limit and device is trying to go forward
        Only trips when the device is limited
        """
    @property
    def HardwareESDReset(self) -> bool:
        """
        Not used, @see ResetDuringEn

        :type: bool
        """
    @HardwareESDReset.setter
    def HardwareESDReset(self, arg0: bool) -> None:
        """
        Not used, @see ResetDuringEn
        """
    @property
    def HardwareFailure(self) -> bool:
        """
        Device detects hardware failure

        :type: bool
        """
    @HardwareFailure.setter
    def HardwareFailure(self, arg0: bool) -> None:
        """
        Device detects hardware failure
        """
    @property
    def RemoteLossOfSignal(self) -> bool:
        """
        Remote Sensor is no longer detected on bus

        :type: bool
        """
    @RemoteLossOfSignal.setter
    def RemoteLossOfSignal(self, arg0: bool) -> None:
        """
        Remote Sensor is no longer detected on bus
        """
    @property
    def ResetDuringEn(self) -> bool:
        """
        Device was powered-on or reset while robot is enabled.
        Check your breakers and wiring.

        :type: bool
        """
    @ResetDuringEn.setter
    def ResetDuringEn(self, arg0: bool) -> None:
        """
        Device was powered-on or reset while robot is enabled.
        Check your breakers and wiring.
        """
    @property
    def ReverseLimitSwitch(self) -> bool:
        """
        Reverse limit switch is tripped and device is trying to go reverse
        Only trips when the device is limited

        :type: bool
        """
    @ReverseLimitSwitch.setter
    def ReverseLimitSwitch(self, arg0: bool) -> None:
        """
        Reverse limit switch is tripped and device is trying to go reverse
        Only trips when the device is limited
        """
    @property
    def ReverseSoftLimit(self) -> bool:
        """
        Sensor is beyond reverse soft limit and device is trying to go reverse
        Only trips when the device is limited

        :type: bool
        """
    @ReverseSoftLimit.setter
    def ReverseSoftLimit(self, arg0: bool) -> None:
        """
        Sensor is beyond reverse soft limit and device is trying to go reverse
        Only trips when the device is limited
        """
    @property
    def SensorOutOfPhase(self) -> bool:
        """
        Device detects its sensor is out of phase

        :type: bool
        """
    @SensorOutOfPhase.setter
    def SensorOutOfPhase(self, arg0: bool) -> None:
        """
        Device detects its sensor is out of phase
        """
    @property
    def SensorOverflow(self) -> bool:
        """
        Device's sensor overflowed

        :type: bool
        """
    @SensorOverflow.setter
    def SensorOverflow(self, arg0: bool) -> None:
        """
        Device's sensor overflowed
        """
    @property
    def SupplyOverV(self) -> bool:
        """
        Supply is well above the rated voltage of the hardware. This fault is specific to Brushless.

        :type: bool
        """
    @SupplyOverV.setter
    def SupplyOverV(self, arg0: bool) -> None:
        """
        Supply is well above the rated voltage of the hardware. This fault is specific to Brushless.
        """
    @property
    def SupplyUnstable(self) -> bool:
        """
        Supply is rapidly fluctuating and unstable. This fault is specific to Brushless.

        :type: bool
        """
    @SupplyUnstable.setter
    def SupplyUnstable(self, arg0: bool) -> None:
        """
        Supply is rapidly fluctuating and unstable. This fault is specific to Brushless.
        """
    @property
    def UnderVoltage(self) -> bool:
        """
        Motor Controller is under 6.5V

        :type: bool
        """
    @UnderVoltage.setter
    def UnderVoltage(self, arg0: bool) -> None:
        """
        Motor Controller is under 6.5V
        """
    pass
class FeedbackDevice():
    """
    Choose the feedback device for a motor controller.
    Consult product specific documentation to determine what is available/supported.

    Members:

      QuadEncoder : Quadrature encoder

      IntegratedSensor : TalonFX supports an integrated sensor.

      Analog : Analog potentiometer/encoder

      Tachometer : Tachometer

      PulseWidthEncodedPosition : CTRE Mag Encoder in Relative mode or
    any other device that uses PWM to encode its output

      SensorSum : Sum0 + Sum1

      SensorDifference : Diff0 - Diff1

      RemoteSensor0 : Sensor configured in RemoteFilter0

      RemoteSensor1 : Sensor configured in RemoteFilter1

      None_ : Position and velocity will read 0.

      SoftwareEmulatedSensor : Motor Controller will fake a sensor based on applied motor output.

      CTRE_MagEncoder_Absolute : CTR mag encoder configured in absolute, is the same
    as a PWM sensor.

      CTRE_MagEncoder_Relative : CTR mag encoder configured in relative, is the same
    as an quadrature encoder sensor.
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Analog: ctre._ctre.FeedbackDevice # value = FeedbackDevice.Analog
    CTRE_MagEncoder_Absolute: ctre._ctre.FeedbackDevice # value = FeedbackDevice.PulseWidthEncodedPosition
    CTRE_MagEncoder_Relative: ctre._ctre.FeedbackDevice # value = FeedbackDevice.QuadEncoder
    IntegratedSensor: ctre._ctre.FeedbackDevice # value = FeedbackDevice.IntegratedSensor
    None_: ctre._ctre.FeedbackDevice # value = FeedbackDevice.None_
    PulseWidthEncodedPosition: ctre._ctre.FeedbackDevice # value = FeedbackDevice.PulseWidthEncodedPosition
    QuadEncoder: ctre._ctre.FeedbackDevice # value = FeedbackDevice.QuadEncoder
    RemoteSensor0: ctre._ctre.FeedbackDevice # value = FeedbackDevice.RemoteSensor0
    RemoteSensor1: ctre._ctre.FeedbackDevice # value = FeedbackDevice.RemoteSensor1
    SensorDifference: ctre._ctre.FeedbackDevice # value = FeedbackDevice.SensorDifference
    SensorSum: ctre._ctre.FeedbackDevice # value = FeedbackDevice.SensorSum
    SoftwareEmulatedSensor: ctre._ctre.FeedbackDevice # value = FeedbackDevice.SoftwareEmulatedSensor
    Tachometer: ctre._ctre.FeedbackDevice # value = FeedbackDevice.Tachometer
    __members__: dict # value = {'QuadEncoder': FeedbackDevice.QuadEncoder, 'IntegratedSensor': FeedbackDevice.IntegratedSensor, 'Analog': FeedbackDevice.Analog, 'Tachometer': FeedbackDevice.Tachometer, 'PulseWidthEncodedPosition': FeedbackDevice.PulseWidthEncodedPosition, 'SensorSum': FeedbackDevice.SensorSum, 'SensorDifference': FeedbackDevice.SensorDifference, 'RemoteSensor0': FeedbackDevice.RemoteSensor0, 'RemoteSensor1': FeedbackDevice.RemoteSensor1, 'None_': FeedbackDevice.None_, 'SoftwareEmulatedSensor': FeedbackDevice.SoftwareEmulatedSensor, 'CTRE_MagEncoder_Absolute': FeedbackDevice.PulseWidthEncodedPosition, 'CTRE_MagEncoder_Relative': FeedbackDevice.QuadEncoder}
    pass
class FeedbackDeviceRoutines():
    """
    Class to handle feedback device routines
    """
    def __init__(self) -> None: ...
    @staticmethod
    @typing.overload
    def toString(value: FeedbackDevice) -> str: 
        """
        Gets the string representation of selected feedback device

        :param value: feedback device to get string representation of

        :returns: String representation of selected feedback device

        Gets the string representation of selected feedback device

        :param value: feedback device to get string representation of

        :returns: String representation of selected feedback device

        Gets the string representation of selected feedback device

        :param value: feedback device to get string representation of

        :returns: String representation of selected feedback device

        Gets the string representation of selected remote feedback device

        :param value: remote feedback device to get string representation of

        :returns: String representation of selected remote feedback device
        """
    @staticmethod
    @typing.overload
    def toString(value: RemoteFeedbackDevice) -> str: ...
    @staticmethod
    @typing.overload
    def toString(value: TalonFXFeedbackDevice) -> str: ...
    @staticmethod
    @typing.overload
    def toString(value: TalonSRXFeedbackDevice) -> str: ...
    pass
class FilterConfigUtil():
    """
    Util class to help with filter configs
    """
    def __init__(self) -> None: ...
    @staticmethod
    def filterConfigurationDifferent(settings: FilterConfiguration) -> bool: ...
    @staticmethod
    def remoteSensorDeviceIDDifferent(settings: FilterConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    @staticmethod
    def remoteSensorSourceDifferent(settings: FilterConfiguration) -> bool: ...
    pass
class FilterConfiguration():
    """
    Configurations for filters
    """
    def __init__(self) -> None: ...
    @typing.overload
    def toString(self) -> str: 
        """
        :returns: string representation of currently selected configs



        :param prependString: String to prepend to all the configs

        :returns: string representation fo currently selected configs
        """
    @typing.overload
    def toString(self, prependString: str) -> str: ...
    @property
    def remoteSensorDeviceID(self) -> int:
        """
        Remote Sensor's device ID

        :type: int
        """
    @remoteSensorDeviceID.setter
    def remoteSensorDeviceID(self, arg0: int) -> None:
        """
        Remote Sensor's device ID
        """
    @property
    def remoteSensorSource(self) -> RemoteSensorSource:
        """
        The remote sensor device and signal type to bind.

        :type: RemoteSensorSource
        """
    @remoteSensorSource.setter
    def remoteSensorSource(self, arg0: RemoteSensorSource) -> None:
        """
        The remote sensor device and signal type to bind.
        """
    pass
class FollowerType():
    """
    Choose the type of follower

    Members:

      PercentOutput : Follow the percentOutput the master is using

      AuxOutput1 : Follow the auxiliary output the master is
    calculating. Used for 2-axis control.
    This typically means apply PID0 - PID1 from master.
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    AuxOutput1: ctre._ctre.FollowerType # value = FollowerType.AuxOutput1
    PercentOutput: ctre._ctre.FollowerType # value = FollowerType.PercentOutput
    __members__: dict # value = {'PercentOutput': FollowerType.PercentOutput, 'AuxOutput1': FollowerType.AuxOutput1}
    pass
class BaseMotorController(IMotorController, IFollower):
    """
    Base motor controller features for all CTRE CAN motor controllers.
    """
    def changeMotionControlFramePeriod(self, periodMs: int) -> ErrorCode: 
        """
        Calling application can opt to speed up the handshaking between the robot
        API and the controller to increase the download rate of the controller's Motion
        Profile. Ideally the period should be no more than half the period of a
        trajectory point.

        :param periodMs: The transmit period in ms.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def clearMotionProfileHasUnderrun(self, timeoutMs: int = 0) -> ErrorCode: 
        """
        Clear the "Has Underrun" flag. Typically this is called after application
        has confirmed an underrun had occured.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def clearMotionProfileTrajectories(self) -> ErrorCode: 
        """
        Clear the buffered motion profile in both controller's RAM (bottom), and in the
        API (top).
        """
    def clearStickyFaults(self, timeoutMs: int = 0) -> ErrorCode: 
        """
        Clears all sticky faults.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.

        :returns: Last Error Code generated by a function.
        """
    def configAllowableClosedloopError(self, slotIdx: int, allowableCloseLoopError: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the allowable closed-loop error in the given parameter slot.

        :param slotIdx:        Parameter slot for the constant.

        :param allowableCloseLoopError: Value of the allowable closed-loop error in sensor units (or sensor units per 100ms for velocity).

        :param timeoutMs:      Timeout value in ms. If nonzero, function will wait for
                               config success and report an error if it times out.
                               If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configAuxPIDPolarity(self, invert: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the Polarity of the Auxiliary PID (PID1).

        Standard Polarity:
        Primary Output = PID0 + PID1,
        Auxiliary Output = PID0 - PID1,

        Inverted Polarity:
        Primary Output = PID0 - PID1,
        Auxiliary Output = PID0 + PID1,

        :param invert: If true, use inverted PID1 output polarity.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.

        :returns: Error Code
        """
    def configClearPositionOnLimitF(self, clearPositionOnLimitF: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Enables clearing the position of the feedback sensor when the forward
        limit switch is triggered

        :param clearPositionOnLimitF: Whether clearing is enabled, defaults false

        :param timeoutMs:    Timeout value in ms. If nonzero, function will wait for
                             config success and report an error if it times out.
                             If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnLimitR(self, clearPositionOnLimitR: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Enables clearing the position of the feedback sensor when the reverse
        limit switch is triggered

        :param clearPositionOnLimitR: Whether clearing is enabled, defaults false

        :param timeoutMs:    Timeout value in ms. If nonzero, function will wait for
                             config success and report an error if it times out.
                             If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClearPositionOnQuadIdx(self, clearPositionOnQuadIdx: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Enables clearing the position of the feedback sensor when the quadrature index signal
        is detected

        :param clearPositionOnQuadIdx: Whether clearing is enabled, defaults false

        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.
                              If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClosedLoopPeakOutput(self, slotIdx: int, percentOut: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the peak closed-loop output.  This peak output is slot-specific and
        is applied to the output of the associated PID loop.
        This setting is seperate from the generic Peak Output setting.

        :param slotIdx: Parameter slot for the constant.

        :param percentOut: Peak Percent Output from 0 to 1.  This value is absolute and
                  the magnitude will apply in both forward and reverse directions.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClosedLoopPeriod(self, slotIdx: int, loopTimeMs: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the loop time (in milliseconds) of the PID closed-loop calculations.
        Default value is 1 ms.

        :param slotIdx: Parameter slot for the constant.

        :param loopTimeMs: Loop timing of the closed-loop calculations.  Minimum value of
                  1 ms, maximum of 64 ms.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configClosedloopRamp(self, secondsFromNeutralToFull: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the closed-loop ramp rate of throttle output.

        :param secondsFromNeutralToFull: Minimum desired time to go from neutral to full throttle. A
                                value of '0' will disable the ramp.

        :param timeoutMs:       Timeout value in ms. If nonzero, function will wait for
                                config success and report an error if it times out.
                                If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configFactoryDefault(self, timeoutMs: int = 50) -> ErrorCode: 
        """
        Revert all configurations to factory default values.
        Use this before your individual config* calls to avoid having to config every single param.

        Alternatively you can use the configAllSettings routine.

        :param timeoutMs: Timeout value in ms. Function will generate error if config is
                 not successful within timeout.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configFeedbackNotContinuous(self, feedbackNotContinuous: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Disables continuous tracking of the position for analog and pulse-width.
        If the signal goes from 4095 to 0 (pulse-width) a motor controller will continue to read 4096 by default.
        If overflow tracking is disabled, it will wrap to 0 (not continuous)

        If using pulse-width on CTRE Mag Encoder (within one rotation) or absolute analog sensor (within one rotation),
        setting feedbackNotContinuous to true is recommended, to prevent intermittent
        connections from causing sensor "jumps" of 4096 (or 1024 for analog) units.

        :param feedbackNotContinuous: True to disable the overflow tracking.

        :param timeoutMs:    Timeout value in ms. If nonzero, function will wait for
                             config success and report an error if it times out.
                             If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configForwardLimitSwitchSource(self, type: LimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-F pin of another Talon
        or CANifier.

        :param type:     Remote limit switch source. User can choose between a remote
                         Talon SRX, CANifier, or deactivate the feature.

        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                         setting matches the Phoenix Tuner drop down.

        :param deviceID: Device ID of remote source (Talon SRX or CANifier device ID).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                         success and report an error if it times out. If zero, no
                         blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Configures a limit switch for a local/remote source.

        For example, a CAN motor controller may need to monitor the Limit-R pin
        of another Talon, CANifier, or local Gadgeteer feedback connector.

        If the sensor is remote, a device ID of zero is assumed. If that's not
        desired, use the four parameter version of this function.

        :param type:     Limit switch source. User can choose
                         between the feedback connector, remote Talon SRX, CANifier, or
                         deactivate the feature.

        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                         setting matches the Phoenix Tuner drop down.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                         success and report an error if it times out. If zero, no
                         blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configForwardLimitSwitchSource(self, type: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode: ...
    def configForwardSoftLimitEnable(self, enable: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward soft limit enable.

        :param enable: Forward Sensor Position Limit Enable.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configForwardSoftLimitThreshold(self, forwardSensorLimit: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward soft limit threhold.

        :param forwardSensorLimit: Forward Sensor Position Limit (in raw sensor units).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configGetCustomParam(self, paramIndex: int, timeoutMs: int = 0) -> int: 
        """
        Gets the value of a custom parameter.

        :param paramIndex: Index of custom parameter [0,1].

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                  success and report an error if it times out. If zero, no
                  blocking or checking is performed.

        :returns: Value of the custom param.
        """
    @typing.overload
    def configGetParameter(self, param: ParamEnum, ordinal: int, timeoutMs: int = 0) -> float: 
        """
        Gets a parameter.

        :param param: Parameter enumeration.

        :param ordinal: Ordinal of parameter.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Value of parameter.

        Gets a parameter by passing an int by reference

        :param param: Parameter enumeration

        :param valueToSend: Value to send to parameter

        :param valueReceived: Reference to integer to receive

        :param subValue: SubValue of parameter

        :param ordinal: Ordinal of parameter

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                     config success and report an error if it times out.
                     If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configGetParameter(self, param: ParamEnum, valueToSend: int, valueReceived: int, subValue: int, ordinal: int, timeoutMs: int) -> ErrorCode: ...
    def configLimitSwitchDisableNeutralOnLOS(self, limitSwitchDisableNeutralOnLOS: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Disables limit switches triggering (if enabled) when the sensor is no longer detected.

        :param limitSwitchDisableNeutralOnLOS: disable triggering

        :param timeoutMs:             Timeout value in ms. If nonzero, function will wait for
                                      config success and report an error if it times out.
                                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMaxIntegralAccumulator(self, slotIdx: int, iaccum: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the maximum integral accumulator in the given parameter slot.

        :param slotIdx: Parameter slot for the constant.

        :param iaccum: Value of the maximum integral accumulator (closed loop error
                 units X 1ms).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionAcceleration(self, sensorUnitsPer100msPerSec: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the Motion Magic Acceleration. This is the target acceleration that
        the motion magic curve generator can use.

        :param sensorUnitsPer100msPerSec: Motion Magic Acceleration (in raw sensor units per 100 ms per
                                 second).

        :param timeoutMs:        Timeout value in ms. If nonzero, function will wait for config
                                 success and report an error if it times out. If zero, no
                                 blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionCruiseVelocity(self, sensorUnitsPer100ms: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the Motion Magic Cruise Velocity. This is the peak target velocity
        that the motion magic curve generator can use.

        :param sensorUnitsPer100ms: Motion Magic Cruise Velocity (in raw sensor units per 100 ms).

        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for config
                           success and report an error if it times out. If zero, no
                           blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionProfileTrajectoryInterpolationEnable(self, enable: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        When trajectory points are processed in the buffer, the motor controller can
        linearly interpolate additional trajectory points between the buffered
        points.  The time delta between these interpolated points is 1 ms.

        By default this feature is enabled.

        :param enable: Whether to enable the trajectory point interpolation feature.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionProfileTrajectoryPeriod(self, baseTrajDurationMs: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        When trajectory points are processed in the motion profile executer, the MPE determines
        how long to apply the active trajectory point by summing baseTrajDurationMs with the
        timeDur of the trajectory point (see TrajectoryPoint).

        This allows general selection of the execution rate of the points with 1ms resolution,
        while allowing some degree of change from point to point.

        :param baseTrajDurationMs: The base duration time of every trajectory point.
                          This is summed with the trajectory points unique timeDur.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotionSCurveStrength(self, curveStrength: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the Motion Magic S Curve Strength.
        Call this before using Motion Magic.
        Modifying this during a Motion Magic action should be avoided.

        :param curveStrength: 0 to use Trapezoidal Motion Profile. [1,8] for S-Curve (greater value yields greater smoothing).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                     success and report an error if it times out. If zero, no
                     blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configNeutralDeadband(self, percentDeadband: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the output deadband percentage.

        :param percentDeadband: Desired deadband percentage. Minimum is 0.1%, Maximum is 25%.
                       Pass 0.04 for 4% (factory default).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                       config success and report an error if it times out.
                       If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configNominalOutputForward(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward nominal output percentage.

        :param percentOut: Nominal (minimum) percent output. [0,+1]

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configNominalOutputReverse(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse nominal output percentage.

        :param percentOut: Nominal (minimum) percent output. [-1,0]

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configOpenloopRamp(self, secondsFromNeutralToFull: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the open-loop ramp rate of throttle output.

        :param secondsFromNeutralToFull: Minimum desired time to go from neutral to full throttle. A
                                value of '0' will disable the ramp.

        :param timeoutMs:       Timeout value in ms. If nonzero, function will wait for
                                config success and report an error if it times out.
                                If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPeakOutputForward(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward peak output percentage.

        :param percentOut: Desired peak output percentage. [0,1]

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPeakOutputReverse(self, percentOut: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse peak output percentage.

        :param percentOut: Desired peak output percentage.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPulseWidthPeriod_EdgesPerRot(self, pulseWidthPeriod_EdgesPerRot: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the edges per rotation of a pulse width sensor. (This should be set for
        tachometer use).

        :param pulseWidthPeriod_EdgesPerRot: edges per rotation

        :param timeoutMs:           Timeout value in ms. If nonzero, function will wait for
                                    config success and report an error if it times out.
                                    If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configPulseWidthPeriod_FilterWindowSz(self, pulseWidthPeriod_FilterWindowSz: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the number of samples to use in smoothing a pulse width sensor with a rolling
        average. Default is 1 (no smoothing).

        :param pulseWidthPeriod_FilterWindowSz: samples for rolling avg

        :param timeoutMs:              Timeout value in ms. If nonzero, function will wait for
                                       config success and report an error if it times out.
                                       If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configRemoteFeedbackFilter(self, canCoderRef: CANCoder, remoteOrdinal: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
        After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
        as a PID source for closed-loop features.

        :param deviceID:  The device ID of the remote sensor device.

        :param remoteSensorSource: The remote sensor device and signal type to bind.

        :param remoteOrdinal: 0 for configuring Remote Sensor 0,
                          1 for configuring Remote Sensor 1

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
        After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
        as a PID source for closed-loop features.

        :param canCoderRef: CANCoder device reference to use.

        :param remoteOrdinal: 0 for configuring Remote Sensor 0,
                     1 for configuring Remote Sensor 1

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                     config success and report an error if it times out.
                     If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configRemoteFeedbackFilter(self, deviceID: int, remoteSensorSource: RemoteSensorSource, remoteOrdinal: int, timeoutMs: int = 0) -> ErrorCode: ...
    def configRemoteSensorClosedLoopDisableNeutralOnLOS(self, remoteSensorClosedLoopDisableNeutralOnLOS: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Disables going to neutral (brake/coast) when a remote sensor is no longer detected.

        :param remoteSensorClosedLoopDisableNeutralOnLOS: disable going to neutral

        :param timeoutMs:                        Timeout value in ms. If nonzero, function will wait for
                                                 config success and report an error if it times out.
                                                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configReverseLimitSwitchSource(self, type: LimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-R pin of another Talon
        or CANifier.

        :param type:     Remote limit switch source. User can choose between a remote
                         Talon SRX, CANifier, or deactivate the feature.

        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                         setting matches the Phoenix Tuner drop down.

        :param deviceID: Device ID of remote source (Talon SRX or CANifier device ID).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                         success and report an error if it times out. If zero, no
                         blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Configures a limit switch for a local/remote source.

        For example, a CAN motor controller may need to monitor the Limit-R pin
        of another Talon, CANifier, or local Gadgeteer feedback connector.

        If the sensor is remote, a device ID of zero is assumed. If that's not
        desired, use the four parameter version of this function.

        :param type:     Limit switch source. User can choose
                         between the feedback connector, remote Talon SRX, CANifier, or
                         deactivate the feature.

        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                         setting matches the Phoenix Tuner drop down.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                         success and report an error if it times out. If zero, no
                         blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configReverseLimitSwitchSource(self, type: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode: ...
    def configReverseSoftLimitEnable(self, enable: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse soft limit enable.

        :param enable: Reverse Sensor Position Limit Enable.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configReverseSoftLimitThreshold(self, reverseSensorLimit: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse soft limit threshold.

        :param reverseSensorLimit: Reverse Sensor Position Limit (in raw sensor units).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                          config success and report an error if it times out.
                          If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSelectedFeedbackCoefficient(self, coefficient: float, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: 
        """
        The Feedback Coefficient is a scalar applied to the value of the
        feedback sensor.  Useful when you need to scale your sensor values
        within the closed-loop calculations.  Default value is 1.

        Selected Feedback Sensor register in firmware is the decoded sensor value
        multiplied by the Feedback Coefficient.

        :param coefficient: Feedback Coefficient value.  Maximum value of 1.
                   Resolution is 1/(2^16).  Cannot be 0.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                   config success and report an error if it times out.
                   If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: 
        """
        Select the remote feedback device for the motor controller.
        Most CTRE CAN motor controllers will support remote sensors over CAN.

        :param feedbackDevice: Remote Feedback Device to select.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                      config success and report an error if it times out.
                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Select the feedback device for the motor controller.

        :param feedbackDevice: Feedback Device to select.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                      config success and report an error if it times out.
                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def configSensorTerm(self, sensorTerm: SensorTerm, feedbackDevice: FeedbackDevice, timeoutMs: int = 0) -> ErrorCode: 
        """
        Select what sensor term should be bound to switch feedback device.
        Sensor Sum = Sensor Sum Term 0 - Sensor Sum Term 1
        Sensor Difference = Sensor Diff Term 0 - Sensor Diff Term 1
        The four terms are specified with this routine.  Then Sensor Sum/Difference
        can be selected for closed-looping.

        :param sensorTerm: Which sensor term to bind to a feedback source.

        :param feedbackDevice: The sensor signal to attach to sensorTerm.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                      config success and report an error if it times out.
                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Select what sensor term should be bound to switch feedback device.
        Sensor Sum = Sensor Sum Term 0 - Sensor Sum Term 1
        Sensor Difference = Sensor Diff Term 0 - Sensor Diff Term 1
        The four terms are specified with this routine.  Then Sensor Sum/Difference
        can be selected for closed-looping.

        :param sensorTerm: Which sensor term to bind to a feedback source.

        :param feedbackDevice: The sensor signal to attach to sensorTerm.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                      config success and report an error if it times out.
                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSensorTerm(self, sensorTerm: SensorTerm, feedbackDevice: RemoteFeedbackDevice, timeoutMs: int = 0) -> ErrorCode: ...
    def configSetCustomParam(self, newValue: int, paramIndex: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the value of a custom parameter. This is for arbitrary use.

        Sometimes it is necessary to save calibration/limit/target information in
        the device. Particularly if the device is part of a subsystem that can be
        replaced.

        :param newValue: Value for custom parameter.

        :param paramIndex: Index of custom parameter [0,1]

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                  success and report an error if it times out. If zero, no
                  blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSetParameter(self, param: ParamEnum, value: float, subValue: int, ordinal: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets a parameter. Generally this is not used. This can be utilized in -
        Using new features without updating API installation. - Errata
        workarounds to circumvent API implementation. - Allows for rapid testing
        / unit testing of firmware.

        :param param: Parameter enumeration.

        :param value: Value of parameter.

        :param subValue: Subvalue for parameter. Maximum value of 255.

        :param ordinal: Ordinal of parameter.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSoftLimitDisableNeutralOnLOS(self, softLimitDisableNeutralOnLOS: bool, timeoutMs: int = 0) -> ErrorCode: 
        """
        Disables soft limits triggering (if enabled) when the sensor is no longer detected.

        :param softLimitDisableNeutralOnLOS: disable triggering

        :param timeoutMs:           Timeout value in ms. If nonzero, function will wait for
                                    config success and report an error if it times out.
                                    If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementPeriod(self, period: VelocityMeasPeriod, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the period over which velocity measurements are taken.

        :param period: Desired period for the velocity measurement. @see
                 #VelocityMeasPeriod

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementWindow(self, windowSize: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the number of velocity samples used in the rolling average velocity
        measurement.

        :param windowSize: Number of samples in the rolling average of velocity
                  measurement. Valid values are 1,2,4,8,16,32. If another value
                  is specified, it will truncate to nearest support value.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                  success and report an error if it times out. If zero, no
                  blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVoltageCompSaturation(self, voltage: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the Voltage Compensation saturation voltage.

        :param voltage: This is the max voltage to apply to the hbridge when voltage
                 compensation is enabled.  For example, if 10 (volts) is specified
                 and a TalonSRX is commanded to 0.5 (PercentOutput, closed-loop, etc)
                 then the TalonSRX will attempt to apply a duty-cycle to produce 5V.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVoltageMeasurementFilter(self, filterWindowSamples: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the voltage measurement filter.

        :param filterWindowSamples: Number of samples in the rolling average of voltage
                           measurement.

        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_IntegralZone(self, slotIdx: int, izone: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the Integral Zone constant in the given parameter slot. If the
        (absolute) closed-loop error is outside of this zone, integral
        accumulator is automatically cleared. This ensures than integral wind up
        events will stop after the sensor gets far enough from its target.

        :param slotIdx: Parameter slot for the constant.

        :param izone: Value of the Integral Zone constant (closed loop error units X
                 1ms).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kD(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the 'D' constant in the given parameter slot.

        This is multiplied by derivative error (sensor units per PID loop, typically 1ms).
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '250' to get full output if derr is 4096u (Mag Encoder 1 rotation) per 1000 loops (typ 1 sec)

        :param slotIdx: Parameter slot for the constant.

        :param value: Value of the D constant.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kF(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the 'F' constant in the given parameter slot.

        See documentation for calculation details.
        If using velocity, motion magic, or motion profile,
        use (1023 * duty-cycle / sensor-velocity-sensor-units-per-100ms).

        :param slotIdx: Parameter slot for the constant.

        :param value: Value of the F constant.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kI(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the 'I' constant in the given parameter slot.
        This is multiplied by accumulated closed loop error in sensor units every PID Loop.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.00025' to get full output if err is 4096u for 1000 loops (accumulater holds 4,096,000),
        [which is equivalent to one CTRE mag encoder rotation for 1000 milliseconds].

        :param slotIdx: Parameter slot for the constant.

        :param value: Value of the I constant.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def config_kP(self, slotIdx: int, value: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the 'P' constant in the given parameter slot.
        This is multiplied by closed loop error in sensor units.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.25' to get full output if err is 4096u (Mag Encoder 1 rotation)

        :param slotIdx: Parameter slot for the constant.

        :param value: Value of the P constant.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @staticmethod
    def destroyAllMotControllers() -> None: 
        """
        Destructs all motor controller objects
        """
    def enableHeadingHold(self, enable: bool) -> None: 
        """
        Enables a future feature called "Heading Hold".
        For now this simply updates the CAN signal to the motor controller.
        Future firmware updates will use this.

        :param enable: true/false enable
              @deprecated This has been replaced with the 4 param Set.
        """
    def enableVoltageCompensation(self, enable: bool) -> None: 
        """
        Enables voltage compensation. If enabled, voltage compensation works in
        all control modes.

        Be sure to configure the saturation voltage before enabling this.

        :param enable: Enable state of voltage compensation.
        """
    @typing.overload
    def follow(self, masterToFollow: IMotorController) -> None: 
        """
        Set the control mode and output value so that this motor controller will
        follow another motor controller. Currently supports following Victor SPX
        and Talon SRX.

        :param masterToFollow: Motor Controller object to follow.

        :param followerType: Type of following control.  Use AuxOutput1 to follow the master
                      device's auxiliary output 1.
                      Use PercentOutput for standard follower mode.

        Set the control mode and output value so that this motor controller will
        follow another motor controller. Currently supports following Victor SPX
        and Talon SRX.
        """
    @typing.overload
    def follow(self, masterToFollow: IMotorController, followerType: FollowerType) -> None: ...
    def getActiveTrajectoryArbFeedFwd(self, pidIdx: int = 0) -> float: 
        """
        Gets the active trajectory arbitrary feedforward using
        MotionMagic/MotionProfile control modes.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: The Active Trajectory ArbFeedFwd in units of percent output
                  (where 0.01 is 1%).
        """
    def getActiveTrajectoryHeading(self) -> float: ...
    def getActiveTrajectoryPosition(self, pidIdx: int = 0) -> int: 
        """
        Gets the active trajectory target position using
        MotionMagic/MotionProfile control modes.

        :returns: The Active Trajectory Position in sensor units.
        """
    def getActiveTrajectoryVelocity(self, pidIdx: int = 0) -> int: 
        """
        Gets the active trajectory target velocity using
        MotionMagic/MotionProfile control modes.

        :returns: The Active Trajectory Velocity in sensor units per 100ms.
        """
    def getBaseID(self) -> int: ...
    def getBusVoltage(self) -> float: 
        """
        Gets the bus voltage seen by the device.

        :returns: The bus voltage value (in volts).
        """
    def getClosedLoopError(self, pidIdx: int = 0) -> int: 
        """
        Gets the closed-loop error. The units depend on which control mode is in
        use.

        If closed-loop is seeking a target sensor position, closed-loop error is the difference between target
        and current sensor value (in sensor units.  Example 4096 units per rotation for CTRE Mag Encoder).

        If closed-loop is seeking a target sensor velocity, closed-loop error is the difference between target
        and current sensor value (in sensor units per 100ms).

        If using motion profiling or Motion Magic, closed loop error is calculated against the current target,
        and not the "final" target at the end of the profile/movement.

        See Phoenix-Documentation information on units.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: Closed-loop error value.
        """
    def getClosedLoopTarget(self, pidIdx: int = 0) -> float: 
        """
        Gets the current target of a given closed loop.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: The closed loop target.
        """
    def getControlMode(self) -> ControlMode: 
        """
        :returns: control mode motor controller is in
        """
    def getDeviceID(self) -> int: 
        """
        Returns the Device ID

        :returns: Device number.
        """
    def getErrorDerivative(self, pidIdx: int = 0) -> float: 
        """
        Gets the derivative of the closed-loop error.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: The error derivative value.
        """
    def getFaults(self, toFill: Faults) -> ErrorCode: 
        """
        Polls the various fault flags.

        :param toFill: Caller's object to fill with latest fault flags.

        :returns: Last Error Code generated by a function.
        """
    def getFilterConfigs(self, Filter: FilterConfiguration, ordinal: int = 0, timeoutMs: int = 50) -> None: 
        """
        Gets all filter persistant settings.

        :param Filter: Object with all of the filter persistant settings

        :param ordinal: 0 for remote sensor 0 and 1 for remote sensor 1.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.
        """
    def getFirmwareVersion(self) -> int: 
        """
        Gets the firmware version of the device.

        :returns: Firmware version of device. For example: version 1-dot-2 is
                  0x0102.
        """
    def getHandle(self) -> capsule: 
        """
        :returns: CCI handle for child classes.
        """
    def getIntegralAccumulator(self, pidIdx: int = 0) -> float: 
        """
        Gets the iaccum value.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: Integral accumulator value (Closed-loop error X 1ms).
        """
    def getInverted(self) -> bool: 
        """
        :returns: invert setting of motor output.
        """
    def getLastError(self) -> ErrorCode: 
        """
        Gets the last error generated by this object. Not all functions return an
        error code but can potentially report errors. This function can be used
        to retrieve those error codes.

        :returns: Last Error Code generated by a function.
        """
    def getMotionProfileStatus(self, statusToFill: MotionProfileStatus) -> ErrorCode: 
        """
        Retrieve all status information.
        For best performance, Caller can snapshot all status information regarding the
        motion profile executer.

        :param statusToFill: Caller supplied object to fill.

                    The members are filled, as follows...

                    topBufferRem:	The available empty slots in the trajectory buffer.
                    The robot API holds a "top buffer" of trajectory points, so your applicaion
                    can dump several points at once.  The API will then stream them into the
                    low-level buffer, allowing the motor controller to act on them.

                    topBufferRem: The number of points in the top trajectory buffer.

                    btmBufferCnt: The number of points in the low level controller buffer.

                    hasUnderrun: 	Set if isUnderrun ever gets set.
                    Can be manually cleared by ClearMotionProfileHasUnderrun() or automatically cleared by StartMotionProfile().

                    isUnderrun:		This is set if controller needs to shift a point from its buffer into
                    the active trajectory point however
                    the buffer is empty.
                    This gets cleared automatically when is resolved.

                    activePointValid:	True if the active trajectory point is not empty, false otherwise. The members in activePoint are only valid if this signal is set.

                    isLast:	is set/cleared based on the MP executer's current
                    trajectory point's IsLast value.  This assumes
                    IsLast was set when PushMotionProfileTrajectory
                    was used to insert the currently processed trajectory
                    point.

                    profileSlotSelect: The currently processed trajectory point's
                    selected slot.  This can differ in the currently selected slot used
                    for Position and Velocity servo modes

                    outputEnable:		The current output mode of the motion profile
                    executer (disabled, enabled, or hold).  When changing the set()
                    value in MP mode, it's important to check this signal to
                    confirm the change takes effect before interacting with the top buffer.
        """
    def getMotionProfileTopLevelBufferCount(self) -> int: 
        """
        Retrieve just the buffer count for the api-level (top) buffer. This
        routine performs no CAN or data structure lookups, so its fast and ideal
        if caller needs to quickly poll the progress of trajectory points being
        emptied into controller's RAM. Otherwise just use GetMotionProfileStatus.

        :returns: number of trajectory points in the top buffer.
        """
    def getMotorOutputPercent(self) -> float: 
        """
        Gets the output percentage of the motor controller.

        :returns: Output of the motor controller (in percent).
        """
    def getMotorOutputVoltage(self) -> float: 
        """
        :returns: applied voltage to motor  in volts.
        """
    def getSelectedSensorPosition(self, pidIdx: int = 0) -> int: 
        """
        Get the selected sensor position (in raw sensor units).

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop. See
              Phoenix-Documentation for how to interpret.

        :returns: Position of selected sensor (in raw sensor units).
        """
    def getSelectedSensorVelocity(self, pidIdx: int = 0) -> int: 
        """
        Get the selected sensor velocity.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :returns: selected sensor (in raw sensor units) per 100ms.
                  See Phoenix-Documentation for how to interpret.
        """
    def getSlotConfigs(self, slot: SlotConfiguration, slotIdx: int = 0, timeoutMs: int = 50) -> None: 
        """
        Gets all slot persistant settings.

        :param slot: Object with all of the slot persistant settings

        :param slotIdx: Parameter slot for the constant.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.
        """
    @typing.overload
    def getStatusFramePeriod(self, frame: StatusFrame, timeoutMs: int = 0) -> int: 
        """
        Gets the period of the given status frame.

        :param frame: Frame to get the period of.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Period of the given status frame.

        Gets the period of the given status frame.

        :param frame: Frame to get the period of.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Period of the given status frame.
        """
    @typing.overload
    def getStatusFramePeriod(self, frame: StatusFrameEnhanced, timeoutMs: int = 0) -> int: ...
    def getStickyFaults(self, toFill: StickyFaults) -> ErrorCode: 
        """
        Polls the various sticky fault flags.

        :param toFill: Caller's object to fill with latest sticky fault flags.

        :returns: Last Error Code generated by a function.
        """
    def getTemperature(self) -> float: 
        """
        Gets the temperature of the motor controller.

        :returns: Temperature of the motor controller (in 'C)
        """
    def hasResetOccurred(self) -> bool: 
        """
        Returns true if the device has reset since last call.

        :returns: Has a Device Reset Occurred?
        """
    def isMotionProfileFinished(self) -> bool: 
        """
        Determine if running MP is complete.
        This requires using the StartMotionProfile routine to start the MP.
        That is because managing the trajectory points is now done in a background thread (if StartMotionProfile is called).

        If calling application uses the legacy API  (more-complex buffering API) from previous years, than this API will
        not return true.

        :returns: true if MP was started using StartMotionProfile, and it has completed execution (MPE is now in "hold").
        """
    def isMotionProfileTopLevelBufferFull(self) -> bool: 
        """
        Retrieve just the buffer full for the api-level (top) buffer. This
        routine performs no CAN or data structure lookups, so its fast and ideal
        if caller needs to quickly poll. Otherwise just use
        GetMotionProfileStatus.

        :returns: number of trajectory points in the top buffer.
        """
    def isVoltageCompensationEnabled(self) -> bool: 
        """
        Returns the enable state of Voltage Compensation that the caller has set.

        :returns: TRUE if voltage compensation is enabled.
        """
    def neutralOutput(self) -> None: 
        """
        Neutral the motor output by setting control mode to disabled.
        """
    def overrideLimitSwitchesEnable(self, enable: bool) -> None: 
        """
        Sets the enable state for limit switches.

        :param enable: Enable state for limit switches.
        """
    def overrideSoftLimitsEnable(self, enable: bool) -> None: 
        """
        Can be used to override-disable the soft limits.
        This function can be used to quickly disable soft limits without
        having to modify the persistent configuration.

        :param enable: Enable state for soft limit switches.
        """
    def processMotionProfileBuffer(self) -> None: 
        """
        This must be called periodically to funnel the trajectory points from the
        API's top level buffer to the controller's bottom level buffer. Recommendation
        is to call this twice as fast as the execution rate of the motion
        profile. So if MP is running with 20ms trajectory points, try calling
        this routine every 10ms. All motion profile functions are thread-safe
        through the use of a mutex, so there is no harm in having the caller
        utilize threading.
        """
    def pushMotionProfileTrajectory(self, trajPt: TrajectoryPoint) -> ErrorCode: 
        """
        Push another trajectory point into the top level buffer (which is emptied
        into the motor controller's bottom buffer as room allows).

        :param trajPt: to push into buffer.
              The members should be filled in with these values...

              targPos:  servo position in sensor units.
              targVel:  velocity to feed-forward in sensor units
              per 100ms.
              profileSlotSelect0  Which slot to get PIDF gains. PID is used for position servo. F is used
              as the Kv constant for velocity feed-forward. Typically this is hardcoded
              to the a particular slot, but you are free gain schedule if need be.
              Choose from [0,3]
              profileSlotSelect1 Which slot to get PIDF gains for auxiliary PId.
              This only has impact during MotionProfileArc Control mode.
              Choose from [0,1].
              isLastPoint  set to nonzero to signal motor controller to keep processing this
              trajectory point, instead of jumping to the next one
              when timeDurMs expires.  Otherwise MP executer will
              eventually see an empty buffer after the last point
              expires, causing it to assert the IsUnderRun flag.
              However this may be desired if calling application
              never wants to terminate the MP.
              zeroPos  set to nonzero to signal motor controller to "zero" the selected
              position sensor before executing this trajectory point.
              Typically the first point should have this set only thus
              allowing the remainder of the MP positions to be relative to
              zero.
              timeDur Duration to apply this trajectory pt.
              This time unit is ADDED to the exising base time set by
              configMotionProfileTrajectoryPeriod().

        :returns: CTR_OKAY if trajectory point push ok. ErrorCode if buffer is
                  full due to kMotionProfileTopBufferCapacity.
        """
    def selectDemandType(self, value: bool) -> None: 
        """
        For now this simply updates the CAN signal to the motor controller.
        Future firmware updates will use this to control advanced auxiliary loop behavior.

        :param value: @deprecated This has been replaced with the 4 param Set.
        """
    def selectProfileSlot(self, slotIdx: int, pidIdx: int) -> ErrorCode: 
        """
        Selects which profile slot to use for closed-loop control.

        :param slotIdx: Profile slot to select.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.
        """
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: 
        """
        Sets the appropriate output on the talon, depending on the mode.

        :param mode: The output mode to apply.
             In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
             In Current mode, output value is in amperes.
             In Velocity mode, output value is in position change / 100ms.
             In Position mode, output value is in encoder ticks or an analog value,
             depending on the sensor.
             In Follower mode, the output value is the integer device ID of the talon to
             duplicate.

        :param value: The setpoint value, as described above.


             Standard Driving Example:
             _talonLeft.set(ControlMode.PercentOutput, leftJoy);
             _talonRght.set(ControlMode.PercentOutput, rghtJoy);



        :param mode: Sets the appropriate output on the talon, depending on the mode.

        :param demand0: The output value to apply.
                   such as advanced feed forward and/or auxiliary close-looping in firmware.
                   In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                   In Current mode, output value is in amperes.
                   In Velocity mode, output value is in position change / 100ms.
                   In Position mode, output value is in encoder ticks or an analog value,
                   depending on the sensor. See
                   In Follower mode, the output value is the integer device ID of the talon to
                   duplicate.

        :param demand1Type: The demand type for demand1.
                   Neutral: Ignore demand1 and apply no change to the demand0 output.
                   AuxPID: Use demand1 to set the target for the auxiliary PID 1.  Auxiliary
                   PID is always executed as standard Position PID control.
                   ArbitraryFeedForward: Use demand1 as an arbitrary additive value to the
                   demand0 output.  In PercentOutput the demand0 output is the motor output,
                   and in closed-loop modes the demand0 output is the output of PID0.

        :param demand1: Supplmental output value.
                   AuxPID: Target position in Sensor Units
                   ArbitraryFeedForward: Percent Output between -1.0 and 1.0


                   Arcade Drive Example:
                   _talonLeft.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, +joyTurn);
                   _talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, -joyTurn);

                   Drive Straight Example:
                   Note: Selected Sensor Configuration is necessary for both PID0 and PID1.
                   _talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
                   _talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.AuxPID, desiredRobotHeading);

                   Drive Straight to a Distance Example:
                   Note: Other configurations (sensor selection, PID gains, etc.) need to be set.
                   _talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
                   _talonRght.set(ControlMode.MotionMagic, targetDistance, DemandType.AuxPID, desiredRobotHeading);
        """
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None: ...
    def setControlFramePeriod(self, frame: ControlFrame, periodMs: int) -> ErrorCode: 
        """
        Sets the period of the given control frame.

        :param frame: Frame whose period is to be changed.

        :param periodMs: Period in ms for the given frame.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setIntegralAccumulator(self, iaccum: float, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the integral accumulator. Typically this is used to clear/zero the
        integral accumulator, however some use cases may require seeding the
        accumulator for a faster response.

        :param iaccum: Value to set for the integral accumulator (closed loop error
                 units X 1ms).

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def setInverted(self, invert: bool) -> None: 
        """
        Inverts the hbridge output of the motor controller.

        This does not impact sensor phase and should not be used to correct sensor polarity.

        This will invert the hbridge output but NOT the LEDs.
        This ensures....
        - Green LEDs always represents positive request from robot-controller/closed-looping mode.
        - Green LEDs correlates to forward limit switch.
        - Green LEDs correlates to forward soft limit.

        :param invert: Invert state to set.

        Inverts the hbridge output of the motor controller in relation to the master if present

        This does not impact sensor phase and should not be used to correct sensor polarity.

        This will allow you to either:
        - Not invert the motor
        - Invert the motor
        - Always follow the master regardless of master's inversion
        - Always oppose the master regardless of master's inversion

        :param invertType: Invert state to set.
        """
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None: ...
    def setNeutralMode(self, neutralMode: NeutralMode) -> None: 
        """
        Sets the mode of operation during neutral throttle output.

        :param neutralMode: The desired mode of operation when the Controller output
                   throttle is neutral (ie brake/coast)
        """
    def setSelectedSensorPosition(self, sensorPos: int, pidIdx: int = 0, timeoutMs: int = 50) -> ErrorCode: 
        """
        Sets the sensor position to the given value.

        :param sensorPos: Position to set for the selected sensor (in raw sensor units).

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setSensorPhase(self, PhaseSensor: bool) -> None: 
        """
        Sets the phase of the sensor. Use when controller forward/reverse output
        doesn't correlate to appropriate forward/reverse reading of sensor.
        Pick a value so that positive PercentOutput yields a positive change in sensor.
        After setting this, user can freely call SetInverted() with any value.

        :param PhaseSensor: Indicates whether to invert the phase of the sensor.
        """
    @typing.overload
    def setStatusFramePeriod(self, frame: StatusFrame, periodMs: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the period of the given status frame.

        User ensure CAN Bus utilization is not high.

        This setting is not persistent and is lost when device is reset. If this
        is a concern, calling application can use HasResetOccurred() to determine if the
        status frame needs to be reconfigured.

        :param frame: Frame whose period is to be changed.

        :param periodMs: Period in ms for the given frame.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Sets the period of the given status frame.

        User ensure CAN Bus utilization is not high.

        This setting is not persistent and is lost when device is reset. If this
        is a concern, calling application can use HasResetOccurred() to determine if the
        status frame needs to be reconfigured.

        :param frame: Frame whose period is to be changed.

        :param periodMs: Period in ms for the given frame.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def setStatusFramePeriod(self, frame: StatusFrameEnhanced, periodMs: int, timeoutMs: int = 0) -> ErrorCode: ...
    def startMotionProfile(self, stream: BufferedTrajectoryPointStream, minBufferedPts: int, motionProfControlMode: ControlMode) -> ErrorCode: 
        """
        Simple one-shot firing of a complete MP.
        Starting in 2019, MPs can be fired by building a Buffered Trajectory Point Stream, and calling this routine.

        Once called, the motor controller software will automatically ...
        [1] Clear the firmware buffer of trajectory points.
        [2] Clear the underrun flags
        [3] Reset an index within the Buffered Trajectory Point Stream (so that the same profile can be run again and again).
        [4] Start a background thread to manage MP streaming (if not already running).
        [5a] If current control mode already matches motionProfControlMode, set MPE Output to "Hold".
        [5b] If current control mode does not matches motionProfControlMode, apply motionProfControlMode and set MPE Output to "Disable".
        [6] Stream the trajectory points into the device's firmware buffer.
        [7] Once motor controller has at least minBufferedPts worth in the firmware buffer, MP will automatically start (MPE Output set to "Enable").
        [8] Wait until MP finishes, then transitions the Motion Profile Executor's output to "Hold".
        [9] IsMotionProfileFinished() will now return true.

        Calling application can use IsMotionProfileFinished() to determine when internal state machine reaches [7].
        Calling application can cancel MP by calling set().  Otherwise do not call set() until MP has completed.

        The legacy API from previous years requires the calling application to pass points via the ProcessMotionProfileBuffer and PushMotionProfileTrajectory.
        This is no longer required if using this StartMotionProfile/IsMotionProfileFinished API.

        :param stream:       A buffer that will be used to stream the trajectory points.  Caller can fill this container with the entire trajectory point, regardless of size.

        :param minBufferedPts: Minimum number of firmware buffered points before starting MP.
                             Do not exceed device's firmware buffer capacity or MP will never fire (120 for Motion Profile, or 60 for Motion Profile Arc).
                             Recommendation value for this would be five to ten samples depending on timeDur of the trajectory point.

        :param motionProfControlMode: Pass MotionProfile or MotionProfileArc.

        :returns: nonzero error code if operation fails.
        """
    def valueUpdated(self) -> None: 
        """
        When master makes a device, this routine is called to signal the update.
        """
    pass
class IMotorControllerEnhanced(IMotorController, IFollower):
    """
    Interface for enhanced motor controllers
    """
    @typing.overload
    def configForwardLimitSwitchSource(self, type: LimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the forward limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-F pin of another Talon
        or CANifier.

        :param type:     Remote limit switch source. User can choose between a remote
                         Talon SRX, CANifier, or deactivate the feature.

        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                         setting matches the Phoenix Tuner drop down.

        :param deviceID: Device ID of remote source (Talon SRX or CANifier device ID).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                         success and report an error if it times out. If zero, no
                         blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Configures the forward limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-F pin of another Talon
        or CANifier.

        :param type:     Remote limit switch source. User can choose between a remote
                         Talon SRX, CANifier, or deactivate the feature.

        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                         setting matches the Phoenix Tuner drop down.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                         success and report an error if it times out. If zero, no
                         blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configForwardLimitSwitchSource(self, type: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def configReverseLimitSwitchSource(self, type: LimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the reverse limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-R pin of another Talon
        or CANifier.

        :param type:     Remote limit switch source. User can choose between a remote
                         Talon SRX, CANifier, or deactivate the feature.

        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                         setting matches the Phoenix Tuner drop down.

        :param deviceID: Device ID of remote source (Talon SRX or CANifier device ID).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                         success and report an error if it times out. If zero, no
                         blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Configures the reverse limit switch for a remote source. For example, a
        CAN motor controller may need to monitor the Limit-R pin of another Talon
        or CANifier.

        :param type:     Remote limit switch source. User can choose between a remote
                         Talon SRX, CANifier, or deactivate the feature.

        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                         setting matches the Phoenix Tuner drop down.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                         success and report an error if it times out. If zero, no
                         blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configReverseLimitSwitchSource(self, type: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: 
        """
        Select the feedback device for the motor controller.

        :param feedbackDevice: Feedback Device to select.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                      config success and report an error if it times out.
                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Select the feedback device for the motor controller.

        :param feedbackDevice: Feedback Device to select.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                      config success and report an error if it times out.
                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    def configVelocityMeasurementPeriod(self, period: VelocityMeasPeriod, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the period over which velocity measurements are taken.

        :param period: Desired period for the velocity measurement. @see
                 com.ctre.phoenix.motorcontrol.VelocityMeasPeriod

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementWindow(self, windowSize: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the number of velocity samples used in the rolling average velocity
        measurement.

        :param windowSize: Number of samples in the rolling average of velocity
                  measurement. Valid values are 1,2,4,8,16,32. If another value
                  is specified, it will truncate to nearest support value.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                  success and report an error if it times out. If zero, no
                  blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getOutputCurrent(self) -> float: 
        """
        Gets the output current of the motor controller.
        In the case of TalonSRX class, this routine returns supply current for legacy reasons.  In order to get the "true" output current, call GetStatorCurrent().
        In the case of TalonFX class, this routine returns the true output stator current.

        [[deprecated("Use GetStatorCurrent/GetSupplyCurrent instead.")]]

        :returns: The output current (in amps).
        """
    @typing.overload
    def getStatusFramePeriod(self, frame: StatusFrame, timeoutMs: int = 0) -> int: 
        """
        Gets the period of the given status frame.

        :param frame: Frame to get the period of.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Period of the given status frame.

        Gets the period of the given status frame.

        :param frame: Frame to get the period of.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Period of the given status frame.
        """
    @typing.overload
    def getStatusFramePeriod(self, frame: StatusFrameEnhanced, timeoutMs: int = 0) -> int: ...
    @typing.overload
    def setStatusFramePeriod(self, frame: StatusFrame, periodMs: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the period of the given status frame.

        User ensure CAN Bus utilization is not high.

        This setting is not persistent and is lost when device is reset. If this
        is a concern, calling application can use HasResetOccurred() to determine if the
        status frame needs to be reconfigured.

        :param frame: Frame whose period is to be changed.

        :param periodMs: Period in ms for the given frame.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Sets the period of the given status frame.

        User ensure CAN Bus utilization is not high.

        This setting is not persistent and is lost when device is reset. If this
        is a concern, calling application can use HasResetOccurred() to determine if the
        status frame needs to be reconfigured.

        :param frame: Frame whose period is to be changed.

        :param periodMs: Period in ms for the given frame.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def setStatusFramePeriod(self, frame: StatusFrameEnhanced, periodMs: int, timeoutMs: int = 0) -> ErrorCode: ...
    pass
class BaseTalon(BaseMotorController, IMotorControllerEnhanced, IMotorController, IFollower):
    """
    CTRE Talon SRX Motor Controller when used on CAN Bus.
    """
    @typing.overload
    def configForwardLimitSwitchSource(self, limitSwitchSource: LimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures a limit switch for a local/remote source.

        For example, a CAN motor controller may need to monitor the Limit-R pin
        of another Talon, CANifier, or local Gadgeteer feedback connector.

        If the sensor is remote, a device ID of zero is assumed.
        If that's not desired, use the four parameter version of this function.

        :param limitSwitchSource: Limit switch source.
                         User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature.

        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This setting
                         matches the Phoenix Tuner drop down.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                         config success and report an error if it times out.
                         If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Configures a limit switch for a local/remote source.

        For example, a CAN motor controller may need to monitor the Limit-R pin
        of another Talon, CANifier, or local Gadgeteer feedback connector.

        If the sensor is remote, a device ID of zero is assumed.
        If that's not desired, use the four parameter version of this function.

        :param limitSwitchSource: Limit switch source.
                         User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature.

        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This setting
                         matches the Phoenix Tuner drop down.

        :param deviceID: Device ID of remote source (Talon SRX or CANifier device ID).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                         config success and report an error if it times out.
                         If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configForwardLimitSwitchSource(self, limitSwitchSource: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def configReverseLimitSwitchSource(self, limitSwitchSource: LimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures a limit switch for a local/remote source.

        For example, a CAN motor controller may need to monitor the Limit-R pin
        of another Talon, CANifier, or local Gadgeteer feedback connector.

        If the sensor is remote, a device ID of zero is assumed. If that's not
        desired, use the four parameter version of this function.

        :param limitSwitchSource: Limit switch source. @see #LimitSwitchSource User can choose
                         between the feedback connector, remote Talon SRX, CANifier, or
                         deactivate the feature.

        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                         setting matches the Phoenix Tuner drop down.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                         success and report an error if it times out. If zero, no
                         blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Configures a limit switch for a local/remote source.

        For example, a CAN motor controller may need to monitor the Limit-R pin
        of another Talon, CANifier, or local Gadgeteer feedback connector.

        If the sensor is remote, a device ID of zero is assumed. If that's not
        desired, use the four parameter version of this function.

        :param limitSwitchSource: Limit switch source. @see #LimitSwitchSource User can choose
                         between the feedback connector, remote Talon SRX, CANifier, or
                         deactivate the feature.

        :param normalOpenOrClose: Setting for normally open, normally closed, or disabled. This
                         setting matches the Phoenix Tuner drop down.

        :param deviceID: Device ID of remote source (Talon SRX or CANifier device ID).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                         success and report an error if it times out. If zero, no
                         blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configReverseLimitSwitchSource(self, limitSwitchSource: RemoteLimitSwitchSource, normalOpenOrClose: LimitSwitchNormal, deviceID: int, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: 
        """
        Select the remote feedback device for the motor controller.
        Most CTRE CAN motor controllers will support remote sensors over CAN.

        :param feedbackDevice: Remote Feedback Device to select.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                      config success and report an error if it times out.
                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Select the remote feedback device for the motor controller.
        Most CTRE CAN motor controllers will support remote sensors over CAN.

        :param feedbackDevice: Remote Feedback Device to select.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                      config success and report an error if it times out.
                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    def configSupplyCurrentLimit(self, currLimitConfigs: SupplyCurrentLimitConfiguration, timeoutMs: int = 0) -> ErrorCode: ...
    def configVelocityMeasurementPeriod(self, period: VelocityMeasPeriod, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configures the period of each velocity sample.
        Every 1ms a position value is sampled, and the delta between that sample
        and the position sampled kPeriod ms ago is inserted into a filter.
        kPeriod is configured with this function.

        :param period: Desired period for the velocity measurement. @see
                 #VelocityMeasPeriod

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configVelocityMeasurementWindow(self, windowSize: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the number of velocity samples used in the rolling average velocity
        measurement.

        :param windowSize: Number of samples in the rolling average of velocity
                  measurement. Valid values are 1,2,4,8,16,32. If another
                  value is specified, it will truncate to nearest support value.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getOutputCurrent(self) -> float: 
        """
        Gets the output current of the motor controller.
        In the case of TalonSRX class, this routine returns supply current for legacy reasons.  In order to get the "true" output current, call GetStatorCurrent().
        In the case of TalonFX class, this routine returns the true output stator current.

        [[deprecated("Use GetStatorCurrent/GetSupplyCurrent instead.")]]

        :returns: The output current (in amps).
        """
    def getStatorCurrent(self) -> float: 
        """
        Gets the stator/output current of the motor controller.

        :returns: The stator/output current (in amps).
        """
    @typing.overload
    def getStatusFramePeriod(self, frame: StatusFrame, timeoutMs: int = 0) -> int: 
        """
        Gets the period of the given status frame.

        :param frame: Frame to get the period of.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Period of the given status frame.

        Gets the period of the given status frame.

        :param frame: Frame to get the period of.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Period of the given status frame.
        """
    @typing.overload
    def getStatusFramePeriod(self, frame: StatusFrameEnhanced, timeoutMs: int = 0) -> int: ...
    def getSupplyCurrent(self) -> float: 
        """
        Gets the supply/input current of the motor controller.

        :returns: The supply/input current (in amps).
        """
    def isFwdLimitSwitchClosed(self) -> int: ...
    def isRevLimitSwitchClosed(self) -> int: ...
    @typing.overload
    def setStatusFramePeriod(self, frame: StatusFrame, periodMs: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the period of the given status frame.

        User ensure CAN Bus utilization is not high.

        This setting is not persistent and is lost when device is reset.
        If this is a concern, calling application can use HasResetOccurred()
        to determine if the status frame needs to be reconfigured.

        :param frame: Frame whose period is to be changed.

        :param periodMs: Period in ms for the given frame.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Sets the period of the given status frame.

        User ensure CAN Bus utilization is not high.

        This setting is not persistent and is lost when device is reset.
        If this is a concern, calling application can use HasResetOccurred()
        to determine if the status frame needs to be reconfigured.

        :param frame: Frame whose period is to be changed.

        :param periodMs: Period in ms for the given frame.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def setStatusFramePeriod(self, frame: StatusFrameEnhanced, periodMs: int, timeoutMs: int = 0) -> ErrorCode: ...
    pass
class InvertType():
    """
    Choose the invert type of the motor controller.
    None is the equivalent of SetInverted(false), where positive request yields positive voltage on M+.
    InvertMotorOutput is the equivelant of SetInverted(true), where positive request yields positive voltage on M-.
    FollowMaster/OpposeMaster will match/oppose a master Talon/Victor.  This requires device to be configured as a follower.

    Members:

      None_ : //!< Same as SetInverted(false)

      InvertMotorOutput : //!< Same as SetInverted(true)

      FollowMaster : //!< Follow the invert of the master this MC is following.

      OpposeMaster : //!< Opposite of the invert of the master this MC is following.
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    FollowMaster: ctre._ctre.InvertType # value = InvertType.FollowMaster
    InvertMotorOutput: ctre._ctre.InvertType # value = InvertType.InvertMotorOutput
    None_: ctre._ctre.InvertType # value = InvertType.None_
    OpposeMaster: ctre._ctre.InvertType # value = InvertType.OpposeMaster
    __members__: dict # value = {'None_': InvertType.None_, 'InvertMotorOutput': InvertType.InvertMotorOutput, 'FollowMaster': InvertType.FollowMaster, 'OpposeMaster': InvertType.OpposeMaster}
    pass
class LimitSwitchNormal():
    """
    Choose whether the limit switch is normally
    open or normally closed

    Members:

      NormallyOpen : Limit Switch is tripped when
    the circuit is closed

      NormallyClosed : Limit Switch is tripped when
    the circuit is open

      Disabled : Limit switch is disabled
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Disabled: ctre._ctre.LimitSwitchNormal # value = LimitSwitchNormal.Disabled
    NormallyClosed: ctre._ctre.LimitSwitchNormal # value = LimitSwitchNormal.NormallyClosed
    NormallyOpen: ctre._ctre.LimitSwitchNormal # value = LimitSwitchNormal.NormallyOpen
    __members__: dict # value = {'NormallyOpen': LimitSwitchNormal.NormallyOpen, 'NormallyClosed': LimitSwitchNormal.NormallyClosed, 'Disabled': LimitSwitchNormal.Disabled}
    pass
class LimitSwitchRoutines():
    """
    Class to handle various functions regarding limit switches
    """
    def __init__(self) -> None: ...
    @staticmethod
    def isRemote(limitSwitchSource: LimitSwitchSource) -> bool: 
        """
        Checks if a limit switch is one of the remote values
        (i.e. RemoteTalonSRX or RemoteCANifier)

        :param limitSwitchSource: limitSwitchSource to check

        :returns: true if it's a remote limit switch source
        """
    @staticmethod
    def promote(limitSwitchSource: RemoteLimitSwitchSource) -> LimitSwitchSource: 
        """
        Takes a RemoteLimitSwitchSource and brings it up to a LimitSwitchSource

        :param limitSwitchSource: LimitSwitchSource to promote

        :returns: promoted limitSwitchSource
        """
    @staticmethod
    @typing.overload
    def toString(value: LimitSwitchNormal) -> str: 
        """
        :param value: LimitSwitchSource to get the string value of

        :returns: string representation of value



        :param value: LimitSwitchSource to get the string value of

        :returns: string representation of value



        :param value: LimitSwitchNormal to get the string value of

        :returns: string representation of value
        """
    @staticmethod
    @typing.overload
    def toString(value: LimitSwitchSource) -> str: ...
    @staticmethod
    @typing.overload
    def toString(value: RemoteLimitSwitchSource) -> str: ...
    pass
class LimitSwitchSource():
    """
    Limit switch source enum

    Members:

      FeedbackConnector : Limit switch directly connected to motor controller

      RemoteTalonSRX : Use Limit switch connected to TalonSRX on CAN

      RemoteCANifier : User Limit switch connected to CANifier

      Deactivated : Don't use a limit switch
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Deactivated: ctre._ctre.LimitSwitchSource # value = LimitSwitchSource.Deactivated
    FeedbackConnector: ctre._ctre.LimitSwitchSource # value = LimitSwitchSource.FeedbackConnector
    RemoteCANifier: ctre._ctre.LimitSwitchSource # value = LimitSwitchSource.RemoteCANifier
    RemoteTalonSRX: ctre._ctre.LimitSwitchSource # value = LimitSwitchSource.RemoteTalonSRX
    __members__: dict # value = {'FeedbackConnector': LimitSwitchSource.FeedbackConnector, 'RemoteTalonSRX': LimitSwitchSource.RemoteTalonSRX, 'RemoteCANifier': LimitSwitchSource.RemoteCANifier, 'Deactivated': LimitSwitchSource.Deactivated}
    pass
class MagnetFieldStrength():
    """
    Indicates the magnet field strength of a magnet-based sensor

    Members:

      Invalid_Unknown : Magnet Field strength cannot be determined

      BadRange_RedLED : Magnet field is far too low (too far) or far too high (too close).

      Adequate_OrangeLED : Magnet field is adequate, sensor can be used in this range with slightly reduced accuracy.

      Good_GreenLED : Magnet field is ideal
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Adequate_OrangeLED: ctre._ctre.MagnetFieldStrength # value = MagnetFieldStrength.Adequate_OrangeLED
    BadRange_RedLED: ctre._ctre.MagnetFieldStrength # value = MagnetFieldStrength.BadRange_RedLED
    Good_GreenLED: ctre._ctre.MagnetFieldStrength # value = MagnetFieldStrength.Good_GreenLED
    Invalid_Unknown: ctre._ctre.MagnetFieldStrength # value = MagnetFieldStrength.Invalid_Unknown
    __members__: dict # value = {'Invalid_Unknown': MagnetFieldStrength.Invalid_Unknown, 'BadRange_RedLED': MagnetFieldStrength.BadRange_RedLED, 'Adequate_OrangeLED': MagnetFieldStrength.Adequate_OrangeLED, 'Good_GreenLED': MagnetFieldStrength.Good_GreenLED}
    pass
class MotionProfileStatus():
    """
    Motion Profile Status
    This is simply a data transer object.
    """
    def __init__(self) -> None: ...
    @property
    def activePointValid(self) -> bool:
        """
        True if the active trajectory point is not empty, false otherwise.
        The members in activePoint are only valid if this signal is set.

        :type: bool
        """
    @activePointValid.setter
    def activePointValid(self, arg0: bool) -> None:
        """
        True if the active trajectory point is not empty, false otherwise.
        The members in activePoint are only valid if this signal is set.
        """
    @property
    def btmBufferCnt(self) -> int:
        """
        The number of points in the low level Talon/Victor buffer.

        :type: int
        """
    @btmBufferCnt.setter
    def btmBufferCnt(self, arg0: int) -> None:
        """
        The number of points in the low level Talon/Victor buffer.
        """
    @property
    def hasUnderrun(self) -> bool:
        """
        Set if isUnderrun ever gets set.
        Can be manually cleared by ClearMotionProfileHasUnderrun() or automatically cleared by StartMotionProfile().
        @see clearMotionProfileHasUnderrun()

        :type: bool
        """
    @hasUnderrun.setter
    def hasUnderrun(self, arg0: bool) -> None:
        """
        Set if isUnderrun ever gets set.
        Can be manually cleared by ClearMotionProfileHasUnderrun() or automatically cleared by StartMotionProfile().
        @see clearMotionProfileHasUnderrun()
        """
    @property
    def isLast(self) -> bool:
        """
        True if the active trajectory point is the last point of the profile

        :type: bool
        """
    @isLast.setter
    def isLast(self, arg0: bool) -> None:
        """
        True if the active trajectory point is the last point of the profile
        """
    @property
    def isUnderrun(self) -> bool:
        """
        This is set if Talon/Victor needs to shift a point from its buffer into
        the active trajectory point however the buffer is empty. This gets cleared
        automatically when is resolved.

        :type: bool
        """
    @isUnderrun.setter
    def isUnderrun(self, arg0: bool) -> None:
        """
        This is set if Talon/Victor needs to shift a point from its buffer into
        the active trajectory point however the buffer is empty. This gets cleared
        automatically when is resolved.
        """
    @property
    def outputEnable(self) -> SetValueMotionProfile:
        """
        The current output mode of the motion profile executer (disabled, enabled, or hold).
        When changing the set() value in MP mode, it's important to check this signal to
        confirm the change takes effect before interacting with the top buffer.

        :type: SetValueMotionProfile
        """
    @outputEnable.setter
    def outputEnable(self, arg0: SetValueMotionProfile) -> None:
        """
        The current output mode of the motion profile executer (disabled, enabled, or hold).
        When changing the set() value in MP mode, it's important to check this signal to
        confirm the change takes effect before interacting with the top buffer.
        """
    @property
    def profileSlotSelect0(self) -> int:
        """
        The selected PID[0] profile slot of current profile

        :type: int
        """
    @profileSlotSelect0.setter
    def profileSlotSelect0(self, arg0: int) -> None:
        """
        The selected PID[0] profile slot of current profile
        """
    @property
    def profileSlotSelect1(self) -> int:
        """
        The selected auxiliary PID[1] profile slot of current profile

        :type: int
        """
    @profileSlotSelect1.setter
    def profileSlotSelect1(self, arg0: int) -> None:
        """
        The selected auxiliary PID[1] profile slot of current profile
        """
    @property
    def timeDurMs(self) -> int:
        """
        The applied duration of the active trajectory point

        :type: int
        """
    @timeDurMs.setter
    def timeDurMs(self, arg0: int) -> None:
        """
        The applied duration of the active trajectory point
        """
    @property
    def topBufferCnt(self) -> int:
        """
        The number of points in the top trajectory buffer.

        :type: int
        """
    @topBufferCnt.setter
    def topBufferCnt(self, arg0: int) -> None:
        """
        The number of points in the top trajectory buffer.
        """
    @property
    def topBufferRem(self) -> int:
        """
        The available empty slots in the trajectory buffer.

        The robot API holds a "top buffer" of trajectory points, so your applicaion
        can dump several points at once.  The API will then stream them into the Talon's
        low-level buffer, allowing the Talon to act on them.

        :type: int
        """
    @topBufferRem.setter
    def topBufferRem(self, arg0: int) -> None:
        """
        The available empty slots in the trajectory buffer.

        The robot API holds a "top buffer" of trajectory points, so your applicaion
        can dump several points at once.  The API will then stream them into the Talon's
        low-level buffer, allowing the Talon to act on them.
        """
    pass
class MotorCommutation():
    """
    Choose the type of motor commutation.  This is for products that support selectable commutation strategies.

    Members:

      Trapezoidal : //!< Trapezoidal Commutation
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Trapezoidal: ctre._ctre.MotorCommutation # value = MotorCommutation.Trapezoidal
    __members__: dict # value = {'Trapezoidal': MotorCommutation.Trapezoidal}
    pass
class NeutralMode():
    """
    Choose the neutral mode for a motor controller

    Members:

      EEPROMSetting : Use the NeutralMode that is set in the MC's persistent storage.

      Coast : When commanded to neutral, motor leads are set to high-impedance, allowing mechanism to coast.

      Brake : When commanded to neutral, motor leads are commonized electrically to reduce motion.
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Brake: ctre._ctre.NeutralMode # value = NeutralMode.Brake
    Coast: ctre._ctre.NeutralMode # value = NeutralMode.Coast
    EEPROMSetting: ctre._ctre.NeutralMode # value = NeutralMode.EEPROMSetting
    __members__: dict # value = {'EEPROMSetting': NeutralMode.EEPROMSetting, 'Coast': NeutralMode.Coast, 'Brake': NeutralMode.Brake}
    pass
class Orchestra():
    """
    An Orchestra is used to play music through Talon FX motor controllers.
    It uses a "Chirp" (.chrp) music file that can be generated using Phoenix Tuner.

    Chirp files are generated from standard MIDI files.
    Each Talon FX can only play a single track within the music file.
    For multi-track files, multiple Talon FXs are needed.
    ie, The first track will be played through the first Talon FX added,
    the second track will be played through the second Talon FX added, etc.

    Any Chirp file located in the src/main/deploy directory of your FRC project
    will automatically be copied to the roboRIO on code deploy.

    To use the Orchestra:
    - Add the Talon FXs to be used as instruments
    - Load the Chirp file to be played using the LoadMusic routine.

    Once ready, the Orchestra can be controlled using standard
    play/pause/stop routines.

    New music files can be loaded at any time.

    The robot must be enabled to play music.

    Calling set on any of the TalonFX instruments while the orchestra is
    playing will pause the orchestra.
    """
    def __init__(self) -> None: 
        """
        Constructor for an Orchestra Object.
        Call AddInstrument after this to add the instruments.
        """
    def addInstrument(self, instrument: TalonFX) -> ErrorCode: 
        """
        Adds another instrument to the orchestra.

        :param instrument: TalonFX to add to orchestra

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def clearInstruments(self) -> ErrorCode: 
        """
        Clears all instruments in the orchestra.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def isPlaying(self) -> bool: 
        """
        Returns whether the current track is actively playing or not

        :returns: True if playing, false otherwise
        """
    def loadMusic(self, filePath: str) -> ErrorCode: 
        """
        Loads a Chirp file at the specified file path.

        If the Chirp file is inside your "src/main/deploy" directory
        this file will be automatically deployed to a default directory in
        the RoboRIO when you deploy code. For these files, the name and file
        extension is sufficient.

        Use Tuner to create a Chirp file.

        :param filepath: The path to the Chirp File.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def pause(self) -> ErrorCode: 
        """
        Pauses the music file that's loaded.
        This saves the current position in the track, so it can be resumed later.
        Pausing while stopped is an invalid request.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def play(self) -> ErrorCode: 
        """
        Plays the music file that's loaded.
        If the player is paused, this will resume.
        This will also resume a song if the orchestra was interrupted.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def stop(self) -> ErrorCode: 
        """
        Stops the music file that's loaded.
        This resets the current position in the track to the start.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    pass
class ParamEnum():
    """
    Signal enumeration for generic signal access.

    Members:

      eOnBoot_BrakeMode

      eQuadFilterEn

      eQuadIdxPolarity

      eMotionProfileHasUnderrunErr

      eMotionProfileTrajectoryPointDurationMs

      eMotionProfileTrajectoryInterpolDis

      eStatusFramePeriod

      eOpenloopRamp

      eClosedloopRamp

      eNeutralDeadband

      ePeakPosOutput

      eNominalPosOutput

      ePeakNegOutput

      eNominalNegOutput

      eProfileParamSlot_P

      eProfileParamSlot_I

      eProfileParamSlot_D

      eProfileParamSlot_F

      eProfileParamSlot_IZone

      eProfileParamSlot_AllowableErr

      eProfileParamSlot_MaxIAccum

      eProfileParamSlot_PeakOutput

      eClearPositionOnLimitF

      eClearPositionOnLimitR

      eClearPositionOnQuadIdx

      eClearPosOnLimitF

      eClearPosOnLimitR

      eClearPositionOnIdx

      eSampleVelocityPeriod

      eSampleVelocityWindow

      eFeedbackSensorType

      eSelectedSensorPosition

      eFeedbackNotContinuous

      eRemoteSensorSource

      eRemoteSensorDeviceID

      eSensorTerm

      eRemoteSensorClosedLoopDisableNeutralOnLOS

      ePIDLoopPolarity

      ePIDLoopPeriod

      eSelectedSensorCoefficient

      eForwardSoftLimitThreshold

      eReverseSoftLimitThreshold

      eForwardSoftLimitEnable

      eReverseSoftLimitEnable

      eNominalBatteryVoltage

      eBatteryVoltageFilterSize

      eContinuousCurrentLimitAmps

      ePeakCurrentLimitMs

      ePeakCurrentLimitAmps

      eCurrLimit_Amps

      eCurrThres_Amps

      eCurrEnable

      eCurrThres_Ms

      eClosedLoopIAccum

      eCustomParam

      eStickyFaults

      eAnalogPosition

      eQuadraturePosition

      ePulseWidthPosition

      eIntegratedSensor

      eMotMag_Accel

      eMotMag_VelCruise

      eMotMag_SCurveLevel

      eLimitSwitchSource

      eLimitSwitchNormClosedAndDis

      eLimitSwitchDisableNeutralOnLOS

      eLimitSwitchRemoteDevID

      eSoftLimitDisableNeutralOnLOS

      ePulseWidthPeriod_EdgesPerRot

      ePulseWidthPeriod_FilterWindowSz

      eYawOffset

      eCompassOffset

      eBetaGain

      eEnableCompassFusion

      eGyroNoMotionCal

      eEnterCalibration

      eFusedHeadingOffset

      eStatusFrameRate

      eAccumZ

      eTempCompDisable

      eMotionMeas_tap_threshX

      eMotionMeas_tap_threshY

      eMotionMeas_tap_threshZ

      eMotionMeas_tap_count

      eMotionMeas_tap_time

      eMotionMeas_tap_time_multi

      eMotionMeas_shake_reject_thresh

      eMotionMeas_shake_reject_time

      eMotionMeas_shake_reject_timeout

      eUnitString

      eFeedbackTimeBase

      eDefaultConfig

      eFastWriteCount

      eWriteCount

      eReserved1

      eMotorCommutation

      eSensorInitStrategy

      eSensorDirection

      eMagnetOffset

      eSensorSync

      eAbsSensorRange
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    __members__: dict # value = {'eOnBoot_BrakeMode': ParamEnum.eOnBoot_BrakeMode, 'eQuadFilterEn': ParamEnum.eQuadFilterEn, 'eQuadIdxPolarity': ParamEnum.eQuadIdxPolarity, 'eMotionProfileHasUnderrunErr': ParamEnum.eMotionProfileHasUnderrunErr, 'eMotionProfileTrajectoryPointDurationMs': ParamEnum.eMotionProfileTrajectoryPointDurationMs, 'eMotionProfileTrajectoryInterpolDis': ParamEnum.eMotionProfileTrajectoryInterpolDis, 'eStatusFramePeriod': ParamEnum.eStatusFramePeriod, 'eOpenloopRamp': ParamEnum.eOpenloopRamp, 'eClosedloopRamp': ParamEnum.eClosedloopRamp, 'eNeutralDeadband': ParamEnum.eNeutralDeadband, 'ePeakPosOutput': ParamEnum.ePeakPosOutput, 'eNominalPosOutput': ParamEnum.eNominalPosOutput, 'ePeakNegOutput': ParamEnum.ePeakNegOutput, 'eNominalNegOutput': ParamEnum.eNominalNegOutput, 'eProfileParamSlot_P': ParamEnum.eProfileParamSlot_P, 'eProfileParamSlot_I': ParamEnum.eProfileParamSlot_I, 'eProfileParamSlot_D': ParamEnum.eProfileParamSlot_D, 'eProfileParamSlot_F': ParamEnum.eProfileParamSlot_F, 'eProfileParamSlot_IZone': ParamEnum.eProfileParamSlot_IZone, 'eProfileParamSlot_AllowableErr': ParamEnum.eProfileParamSlot_AllowableErr, 'eProfileParamSlot_MaxIAccum': ParamEnum.eProfileParamSlot_MaxIAccum, 'eProfileParamSlot_PeakOutput': ParamEnum.eProfileParamSlot_PeakOutput, 'eClearPositionOnLimitF': ParamEnum.eClearPositionOnLimitF, 'eClearPositionOnLimitR': ParamEnum.eClearPositionOnLimitR, 'eClearPositionOnQuadIdx': ParamEnum.eClearPositionOnQuadIdx, 'eClearPosOnLimitF': ParamEnum.eClearPositionOnLimitF, 'eClearPosOnLimitR': ParamEnum.eClearPositionOnLimitR, 'eClearPositionOnIdx': ParamEnum.eClearPositionOnQuadIdx, 'eSampleVelocityPeriod': ParamEnum.eSampleVelocityPeriod, 'eSampleVelocityWindow': ParamEnum.eSampleVelocityWindow, 'eFeedbackSensorType': ParamEnum.eFeedbackSensorType, 'eSelectedSensorPosition': ParamEnum.eSelectedSensorPosition, 'eFeedbackNotContinuous': ParamEnum.eFeedbackNotContinuous, 'eRemoteSensorSource': ParamEnum.eRemoteSensorSource, 'eRemoteSensorDeviceID': ParamEnum.eRemoteSensorDeviceID, 'eSensorTerm': ParamEnum.eSensorTerm, 'eRemoteSensorClosedLoopDisableNeutralOnLOS': ParamEnum.eRemoteSensorClosedLoopDisableNeutralOnLOS, 'ePIDLoopPolarity': ParamEnum.ePIDLoopPolarity, 'ePIDLoopPeriod': ParamEnum.ePIDLoopPeriod, 'eSelectedSensorCoefficient': ParamEnum.eSelectedSensorCoefficient, 'eForwardSoftLimitThreshold': ParamEnum.eForwardSoftLimitThreshold, 'eReverseSoftLimitThreshold': ParamEnum.eReverseSoftLimitThreshold, 'eForwardSoftLimitEnable': ParamEnum.eForwardSoftLimitEnable, 'eReverseSoftLimitEnable': ParamEnum.eReverseSoftLimitEnable, 'eNominalBatteryVoltage': ParamEnum.eNominalBatteryVoltage, 'eBatteryVoltageFilterSize': ParamEnum.eBatteryVoltageFilterSize, 'eContinuousCurrentLimitAmps': ParamEnum.eContinuousCurrentLimitAmps, 'ePeakCurrentLimitMs': ParamEnum.ePeakCurrentLimitMs, 'ePeakCurrentLimitAmps': ParamEnum.ePeakCurrentLimitAmps, 'eCurrLimit_Amps': ParamEnum.eContinuousCurrentLimitAmps, 'eCurrThres_Amps': ParamEnum.ePeakCurrentLimitAmps, 'eCurrEnable': ParamEnum.eCurrEnable, 'eCurrThres_Ms': ParamEnum.eCurrThres_Ms, 'eClosedLoopIAccum': ParamEnum.eClosedLoopIAccum, 'eCustomParam': ParamEnum.eCustomParam, 'eStickyFaults': ParamEnum.eStickyFaults, 'eAnalogPosition': ParamEnum.eAnalogPosition, 'eQuadraturePosition': ParamEnum.eQuadraturePosition, 'ePulseWidthPosition': ParamEnum.ePulseWidthPosition, 'eIntegratedSensor': ParamEnum.eIntegratedSensor, 'eMotMag_Accel': ParamEnum.eMotMag_Accel, 'eMotMag_VelCruise': ParamEnum.eMotMag_VelCruise, 'eMotMag_SCurveLevel': ParamEnum.eMotMag_SCurveLevel, 'eLimitSwitchSource': ParamEnum.eLimitSwitchSource, 'eLimitSwitchNormClosedAndDis': ParamEnum.eLimitSwitchNormClosedAndDis, 'eLimitSwitchDisableNeutralOnLOS': ParamEnum.eLimitSwitchDisableNeutralOnLOS, 'eLimitSwitchRemoteDevID': ParamEnum.eLimitSwitchRemoteDevID, 'eSoftLimitDisableNeutralOnLOS': ParamEnum.eSoftLimitDisableNeutralOnLOS, 'ePulseWidthPeriod_EdgesPerRot': ParamEnum.ePulseWidthPeriod_EdgesPerRot, 'ePulseWidthPeriod_FilterWindowSz': ParamEnum.ePulseWidthPeriod_FilterWindowSz, 'eYawOffset': ParamEnum.eYawOffset, 'eCompassOffset': ParamEnum.eCompassOffset, 'eBetaGain': ParamEnum.eBetaGain, 'eEnableCompassFusion': ParamEnum.eEnableCompassFusion, 'eGyroNoMotionCal': ParamEnum.eGyroNoMotionCal, 'eEnterCalibration': ParamEnum.eEnterCalibration, 'eFusedHeadingOffset': ParamEnum.eFusedHeadingOffset, 'eStatusFrameRate': ParamEnum.eStatusFrameRate, 'eAccumZ': ParamEnum.eAccumZ, 'eTempCompDisable': ParamEnum.eTempCompDisable, 'eMotionMeas_tap_threshX': ParamEnum.eMotionMeas_tap_threshX, 'eMotionMeas_tap_threshY': ParamEnum.eMotionMeas_tap_threshY, 'eMotionMeas_tap_threshZ': ParamEnum.eMotionMeas_tap_threshZ, 'eMotionMeas_tap_count': ParamEnum.eMotionMeas_tap_count, 'eMotionMeas_tap_time': ParamEnum.eMotionMeas_tap_time, 'eMotionMeas_tap_time_multi': ParamEnum.eMotionMeas_tap_time_multi, 'eMotionMeas_shake_reject_thresh': ParamEnum.eMotionMeas_shake_reject_thresh, 'eMotionMeas_shake_reject_time': ParamEnum.eMotionMeas_shake_reject_time, 'eMotionMeas_shake_reject_timeout': ParamEnum.eMotionMeas_shake_reject_timeout, 'eUnitString': ParamEnum.eUnitString, 'eFeedbackTimeBase': ParamEnum.eFeedbackTimeBase, 'eDefaultConfig': ParamEnum.eDefaultConfig, 'eFastWriteCount': ParamEnum.eFastWriteCount, 'eWriteCount': ParamEnum.eWriteCount, 'eReserved1': ParamEnum.eReserved1, 'eMotorCommutation': ParamEnum.eMotorCommutation, 'eSensorInitStrategy': ParamEnum.eSensorInitStrategy, 'eSensorDirection': ParamEnum.eSensorDirection, 'eMagnetOffset': ParamEnum.eMagnetOffset, 'eSensorSync': ParamEnum.eSensorSync, 'eAbsSensorRange': ParamEnum.eAbsSensorRange}
    eAbsSensorRange: ctre._ctre.ParamEnum # value = ParamEnum.eAbsSensorRange
    eAccumZ: ctre._ctre.ParamEnum # value = ParamEnum.eAccumZ
    eAnalogPosition: ctre._ctre.ParamEnum # value = ParamEnum.eAnalogPosition
    eBatteryVoltageFilterSize: ctre._ctre.ParamEnum # value = ParamEnum.eBatteryVoltageFilterSize
    eBetaGain: ctre._ctre.ParamEnum # value = ParamEnum.eBetaGain
    eClearPosOnLimitF: ctre._ctre.ParamEnum # value = ParamEnum.eClearPositionOnLimitF
    eClearPosOnLimitR: ctre._ctre.ParamEnum # value = ParamEnum.eClearPositionOnLimitR
    eClearPositionOnIdx: ctre._ctre.ParamEnum # value = ParamEnum.eClearPositionOnQuadIdx
    eClearPositionOnLimitF: ctre._ctre.ParamEnum # value = ParamEnum.eClearPositionOnLimitF
    eClearPositionOnLimitR: ctre._ctre.ParamEnum # value = ParamEnum.eClearPositionOnLimitR
    eClearPositionOnQuadIdx: ctre._ctre.ParamEnum # value = ParamEnum.eClearPositionOnQuadIdx
    eClosedLoopIAccum: ctre._ctre.ParamEnum # value = ParamEnum.eClosedLoopIAccum
    eClosedloopRamp: ctre._ctre.ParamEnum # value = ParamEnum.eClosedloopRamp
    eCompassOffset: ctre._ctre.ParamEnum # value = ParamEnum.eCompassOffset
    eContinuousCurrentLimitAmps: ctre._ctre.ParamEnum # value = ParamEnum.eContinuousCurrentLimitAmps
    eCurrEnable: ctre._ctre.ParamEnum # value = ParamEnum.eCurrEnable
    eCurrLimit_Amps: ctre._ctre.ParamEnum # value = ParamEnum.eContinuousCurrentLimitAmps
    eCurrThres_Amps: ctre._ctre.ParamEnum # value = ParamEnum.ePeakCurrentLimitAmps
    eCurrThres_Ms: ctre._ctre.ParamEnum # value = ParamEnum.eCurrThres_Ms
    eCustomParam: ctre._ctre.ParamEnum # value = ParamEnum.eCustomParam
    eDefaultConfig: ctre._ctre.ParamEnum # value = ParamEnum.eDefaultConfig
    eEnableCompassFusion: ctre._ctre.ParamEnum # value = ParamEnum.eEnableCompassFusion
    eEnterCalibration: ctre._ctre.ParamEnum # value = ParamEnum.eEnterCalibration
    eFastWriteCount: ctre._ctre.ParamEnum # value = ParamEnum.eFastWriteCount
    eFeedbackNotContinuous: ctre._ctre.ParamEnum # value = ParamEnum.eFeedbackNotContinuous
    eFeedbackSensorType: ctre._ctre.ParamEnum # value = ParamEnum.eFeedbackSensorType
    eFeedbackTimeBase: ctre._ctre.ParamEnum # value = ParamEnum.eFeedbackTimeBase
    eForwardSoftLimitEnable: ctre._ctre.ParamEnum # value = ParamEnum.eForwardSoftLimitEnable
    eForwardSoftLimitThreshold: ctre._ctre.ParamEnum # value = ParamEnum.eForwardSoftLimitThreshold
    eFusedHeadingOffset: ctre._ctre.ParamEnum # value = ParamEnum.eFusedHeadingOffset
    eGyroNoMotionCal: ctre._ctre.ParamEnum # value = ParamEnum.eGyroNoMotionCal
    eIntegratedSensor: ctre._ctre.ParamEnum # value = ParamEnum.eIntegratedSensor
    eLimitSwitchDisableNeutralOnLOS: ctre._ctre.ParamEnum # value = ParamEnum.eLimitSwitchDisableNeutralOnLOS
    eLimitSwitchNormClosedAndDis: ctre._ctre.ParamEnum # value = ParamEnum.eLimitSwitchNormClosedAndDis
    eLimitSwitchRemoteDevID: ctre._ctre.ParamEnum # value = ParamEnum.eLimitSwitchRemoteDevID
    eLimitSwitchSource: ctre._ctre.ParamEnum # value = ParamEnum.eLimitSwitchSource
    eMagnetOffset: ctre._ctre.ParamEnum # value = ParamEnum.eMagnetOffset
    eMotMag_Accel: ctre._ctre.ParamEnum # value = ParamEnum.eMotMag_Accel
    eMotMag_SCurveLevel: ctre._ctre.ParamEnum # value = ParamEnum.eMotMag_SCurveLevel
    eMotMag_VelCruise: ctre._ctre.ParamEnum # value = ParamEnum.eMotMag_VelCruise
    eMotionMeas_shake_reject_thresh: ctre._ctre.ParamEnum # value = ParamEnum.eMotionMeas_shake_reject_thresh
    eMotionMeas_shake_reject_time: ctre._ctre.ParamEnum # value = ParamEnum.eMotionMeas_shake_reject_time
    eMotionMeas_shake_reject_timeout: ctre._ctre.ParamEnum # value = ParamEnum.eMotionMeas_shake_reject_timeout
    eMotionMeas_tap_count: ctre._ctre.ParamEnum # value = ParamEnum.eMotionMeas_tap_count
    eMotionMeas_tap_threshX: ctre._ctre.ParamEnum # value = ParamEnum.eMotionMeas_tap_threshX
    eMotionMeas_tap_threshY: ctre._ctre.ParamEnum # value = ParamEnum.eMotionMeas_tap_threshY
    eMotionMeas_tap_threshZ: ctre._ctre.ParamEnum # value = ParamEnum.eMotionMeas_tap_threshZ
    eMotionMeas_tap_time: ctre._ctre.ParamEnum # value = ParamEnum.eMotionMeas_tap_time
    eMotionMeas_tap_time_multi: ctre._ctre.ParamEnum # value = ParamEnum.eMotionMeas_tap_time_multi
    eMotionProfileHasUnderrunErr: ctre._ctre.ParamEnum # value = ParamEnum.eMotionProfileHasUnderrunErr
    eMotionProfileTrajectoryInterpolDis: ctre._ctre.ParamEnum # value = ParamEnum.eMotionProfileTrajectoryInterpolDis
    eMotionProfileTrajectoryPointDurationMs: ctre._ctre.ParamEnum # value = ParamEnum.eMotionProfileTrajectoryPointDurationMs
    eMotorCommutation: ctre._ctre.ParamEnum # value = ParamEnum.eMotorCommutation
    eNeutralDeadband: ctre._ctre.ParamEnum # value = ParamEnum.eNeutralDeadband
    eNominalBatteryVoltage: ctre._ctre.ParamEnum # value = ParamEnum.eNominalBatteryVoltage
    eNominalNegOutput: ctre._ctre.ParamEnum # value = ParamEnum.eNominalNegOutput
    eNominalPosOutput: ctre._ctre.ParamEnum # value = ParamEnum.eNominalPosOutput
    eOnBoot_BrakeMode: ctre._ctre.ParamEnum # value = ParamEnum.eOnBoot_BrakeMode
    eOpenloopRamp: ctre._ctre.ParamEnum # value = ParamEnum.eOpenloopRamp
    ePIDLoopPeriod: ctre._ctre.ParamEnum # value = ParamEnum.ePIDLoopPeriod
    ePIDLoopPolarity: ctre._ctre.ParamEnum # value = ParamEnum.ePIDLoopPolarity
    ePeakCurrentLimitAmps: ctre._ctre.ParamEnum # value = ParamEnum.ePeakCurrentLimitAmps
    ePeakCurrentLimitMs: ctre._ctre.ParamEnum # value = ParamEnum.ePeakCurrentLimitMs
    ePeakNegOutput: ctre._ctre.ParamEnum # value = ParamEnum.ePeakNegOutput
    ePeakPosOutput: ctre._ctre.ParamEnum # value = ParamEnum.ePeakPosOutput
    eProfileParamSlot_AllowableErr: ctre._ctre.ParamEnum # value = ParamEnum.eProfileParamSlot_AllowableErr
    eProfileParamSlot_D: ctre._ctre.ParamEnum # value = ParamEnum.eProfileParamSlot_D
    eProfileParamSlot_F: ctre._ctre.ParamEnum # value = ParamEnum.eProfileParamSlot_F
    eProfileParamSlot_I: ctre._ctre.ParamEnum # value = ParamEnum.eProfileParamSlot_I
    eProfileParamSlot_IZone: ctre._ctre.ParamEnum # value = ParamEnum.eProfileParamSlot_IZone
    eProfileParamSlot_MaxIAccum: ctre._ctre.ParamEnum # value = ParamEnum.eProfileParamSlot_MaxIAccum
    eProfileParamSlot_P: ctre._ctre.ParamEnum # value = ParamEnum.eProfileParamSlot_P
    eProfileParamSlot_PeakOutput: ctre._ctre.ParamEnum # value = ParamEnum.eProfileParamSlot_PeakOutput
    ePulseWidthPeriod_EdgesPerRot: ctre._ctre.ParamEnum # value = ParamEnum.ePulseWidthPeriod_EdgesPerRot
    ePulseWidthPeriod_FilterWindowSz: ctre._ctre.ParamEnum # value = ParamEnum.ePulseWidthPeriod_FilterWindowSz
    ePulseWidthPosition: ctre._ctre.ParamEnum # value = ParamEnum.ePulseWidthPosition
    eQuadFilterEn: ctre._ctre.ParamEnum # value = ParamEnum.eQuadFilterEn
    eQuadIdxPolarity: ctre._ctre.ParamEnum # value = ParamEnum.eQuadIdxPolarity
    eQuadraturePosition: ctre._ctre.ParamEnum # value = ParamEnum.eQuadraturePosition
    eRemoteSensorClosedLoopDisableNeutralOnLOS: ctre._ctre.ParamEnum # value = ParamEnum.eRemoteSensorClosedLoopDisableNeutralOnLOS
    eRemoteSensorDeviceID: ctre._ctre.ParamEnum # value = ParamEnum.eRemoteSensorDeviceID
    eRemoteSensorSource: ctre._ctre.ParamEnum # value = ParamEnum.eRemoteSensorSource
    eReserved1: ctre._ctre.ParamEnum # value = ParamEnum.eReserved1
    eReverseSoftLimitEnable: ctre._ctre.ParamEnum # value = ParamEnum.eReverseSoftLimitEnable
    eReverseSoftLimitThreshold: ctre._ctre.ParamEnum # value = ParamEnum.eReverseSoftLimitThreshold
    eSampleVelocityPeriod: ctre._ctre.ParamEnum # value = ParamEnum.eSampleVelocityPeriod
    eSampleVelocityWindow: ctre._ctre.ParamEnum # value = ParamEnum.eSampleVelocityWindow
    eSelectedSensorCoefficient: ctre._ctre.ParamEnum # value = ParamEnum.eSelectedSensorCoefficient
    eSelectedSensorPosition: ctre._ctre.ParamEnum # value = ParamEnum.eSelectedSensorPosition
    eSensorDirection: ctre._ctre.ParamEnum # value = ParamEnum.eSensorDirection
    eSensorInitStrategy: ctre._ctre.ParamEnum # value = ParamEnum.eSensorInitStrategy
    eSensorSync: ctre._ctre.ParamEnum # value = ParamEnum.eSensorSync
    eSensorTerm: ctre._ctre.ParamEnum # value = ParamEnum.eSensorTerm
    eSoftLimitDisableNeutralOnLOS: ctre._ctre.ParamEnum # value = ParamEnum.eSoftLimitDisableNeutralOnLOS
    eStatusFramePeriod: ctre._ctre.ParamEnum # value = ParamEnum.eStatusFramePeriod
    eStatusFrameRate: ctre._ctre.ParamEnum # value = ParamEnum.eStatusFrameRate
    eStickyFaults: ctre._ctre.ParamEnum # value = ParamEnum.eStickyFaults
    eTempCompDisable: ctre._ctre.ParamEnum # value = ParamEnum.eTempCompDisable
    eUnitString: ctre._ctre.ParamEnum # value = ParamEnum.eUnitString
    eWriteCount: ctre._ctre.ParamEnum # value = ParamEnum.eWriteCount
    eYawOffset: ctre._ctre.ParamEnum # value = ParamEnum.eYawOffset
    pass
class PigeonIMU(CANBusAddressable):
    """
    Pigeon IMU Class.
    Class supports communicating over CANbus and over ribbon-cable (CAN Talon SRX).
    """
    class CalibrationMode():
        """
        Various calibration modes supported by Pigeon.

        Note that you can instead use Phoenix Tuner to accomplish certain calibrations.

        Members:

          BootTareGyroAccel : Boot-Calibrate the pigeon

          Temperature : Temperature-Calibrate the pigeon

          Magnetometer12Pt : Magnetometer-Calibrate the pigeon using the 12pt process

          Magnetometer360 : Magnetometer-Calibrate the pigeon using 360 turns

          Accelerometer : Calibrate the pigeon accelerometer
        """
        def __eq__(self, arg0: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, arg0: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, arg0: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, arg0: int) -> None: ...
        @property
        def name(self) -> None:
            """
            :type: None
            """
        Accelerometer: ctre._ctre.PigeonIMU.CalibrationMode # value = CalibrationMode.Accelerometer
        BootTareGyroAccel: ctre._ctre.PigeonIMU.CalibrationMode # value = CalibrationMode.BootTareGyroAccel
        Magnetometer12Pt: ctre._ctre.PigeonIMU.CalibrationMode # value = CalibrationMode.Magnetometer12Pt
        Magnetometer360: ctre._ctre.PigeonIMU.CalibrationMode # value = CalibrationMode.Magnetometer360
        Temperature: ctre._ctre.PigeonIMU.CalibrationMode # value = CalibrationMode.Temperature
        __members__: dict # value = {'BootTareGyroAccel': CalibrationMode.BootTareGyroAccel, 'Temperature': CalibrationMode.Temperature, 'Magnetometer12Pt': CalibrationMode.Magnetometer12Pt, 'Magnetometer360': CalibrationMode.Magnetometer360, 'Accelerometer': CalibrationMode.Accelerometer}
        pass
    class FusionStatus():
        """
        Data object for holding fusion information.
        """
        def __init__(self) -> None: ...
        @property
        def bIsFusing(self) -> bool:
            """
            Whether the pigeon is fusing

            :type: bool
            """
        @bIsFusing.setter
        def bIsFusing(self, arg0: bool) -> None:
            """
            Whether the pigeon is fusing
            """
        @property
        def bIsValid(self) -> bool:
            """
            Whether the fusion is valid

            :type: bool
            """
        @bIsValid.setter
        def bIsValid(self, arg0: bool) -> None:
            """
            Whether the fusion is valid
            """
        @property
        def description(self) -> str:
            """
            Description of fusion status

            :type: str
            """
        @description.setter
        def description(self, arg0: str) -> None:
            """
            Description of fusion status
            """
        @property
        def heading(self) -> float:
            """
            Fused Heading

            :type: float
            """
        @heading.setter
        def heading(self, arg0: float) -> None:
            """
            Fused Heading
            """
        @property
        def lastError(self) -> int:
            """
            Same as GetLastError()

            :type: int
            """
        @lastError.setter
        def lastError(self, arg0: int) -> None:
            """
            Same as GetLastError()
            """
        pass
    class GeneralStatus():
        """
        Data object for status on current calibration and general status.

        Pigeon has many calibration modes supported for a variety of uses.
        The modes generally collects and saves persistently information that makes
        the Pigeon signals more accurate.  This includes collecting temperature, gyro, accelerometer,
        and compass information.

        For FRC use-cases, typically compass and temperature calibration is not required.

        Additionally when motion driver software in the Pigeon boots, it will perform a fast boot calibration
        to initially bias gyro and setup accelerometer.

        These modes can be enabled with the EnterCalibration mode.

        When a calibration mode is entered, caller can expect...

        - PigeonState to reset to Initializing and bCalIsBooting is set to true.  Pigeon LEDs will blink the boot pattern.
        This is similar to the normal boot cal, however it can an additional ~30 seconds since calibration generally
        requires more information.
        currentMode will reflect the user's selected calibration mode.

        - PigeonState will eventually settle to UserCalibration and Pigeon LEDs will show cal specific blink patterns.
        bCalIsBooting is now false.

        - Follow the instructions in the Pigeon User Manual to meet the calibration specific requirements.
        When finished calibrationError will update with the result.
        Pigeon will solid-fill LEDs with red (for failure) or green (for success) for ~5 seconds.
        Pigeon then perform boot-cal to cleanly apply the newly saved calibration data.
        """
        def __init__(self) -> None: ...
        @property
        def bCalIsBooting(self) -> bool:
            """
            After caller requests a calibration mode, pigeon will perform a boot-cal before
            entering the requested mode.  During this period, this flag is set to true.

            :type: bool
            """
        @bCalIsBooting.setter
        def bCalIsBooting(self, arg0: bool) -> None:
            """
            After caller requests a calibration mode, pigeon will perform a boot-cal before
            entering the requested mode.  During this period, this flag is set to true.
            """
        @property
        def calibrationError(self) -> int:
            """
            The error code for the last calibration mode.
            Zero represents a successful cal (with solid green LEDs at end of cal)
            and nonzero is a failed calibration (with solid red LEDs at end of cal).
            Different calibration

            :type: int
            """
        @calibrationError.setter
        def calibrationError(self, arg0: int) -> None:
            """
            The error code for the last calibration mode.
            Zero represents a successful cal (with solid green LEDs at end of cal)
            and nonzero is a failed calibration (with solid red LEDs at end of cal).
            Different calibration
            """
        @property
        def currentMode(self) -> PigeonIMU.CalibrationMode:
            """
            The currently applied calibration mode if state is in UserCalibration or if bCalIsBooting is true.
            Otherwise it holds the last selected calibration mode (when calibrationError was updated).

            :type: PigeonIMU.CalibrationMode
            """
        @currentMode.setter
        def currentMode(self, arg0: PigeonIMU.CalibrationMode) -> None:
            """
            The currently applied calibration mode if state is in UserCalibration or if bCalIsBooting is true.
            Otherwise it holds the last selected calibration mode (when calibrationError was updated).
            """
        @property
        def description(self) -> str:
            """
            general string description of current status

            :type: str
            """
        @description.setter
        def description(self, arg0: str) -> None:
            """
            general string description of current status
            """
        @property
        def lastError(self) -> int:
            """
            Same as GetLastError()

            :type: int
            """
        @lastError.setter
        def lastError(self, arg0: int) -> None:
            """
            Same as GetLastError()
            """
        @property
        def noMotionBiasCount(self) -> int:
            """
            Number of times the Pigeon has automatically rebiased the gyro.
            This counter overflows from 15 -> 0 with no cap.

            :type: int
            """
        @noMotionBiasCount.setter
        def noMotionBiasCount(self, arg0: int) -> None:
            """
            Number of times the Pigeon has automatically rebiased the gyro.
            This counter overflows from 15 -> 0 with no cap.
            """
        @property
        def state(self) -> PigeonIMU.PigeonState:
            """
            The current state of the motion driver.  This reflects if the sensor signals are accurate.
            Most calibration modes will force Pigeon to reinit the motion driver.

            :type: PigeonIMU.PigeonState
            """
        @state.setter
        def state(self, arg0: PigeonIMU.PigeonState) -> None:
            """
            The current state of the motion driver.  This reflects if the sensor signals are accurate.
            Most calibration modes will force Pigeon to reinit the motion driver.
            """
        @property
        def tempC(self) -> float:
            """
            Temperature in Celsius

            :type: float
            """
        @tempC.setter
        def tempC(self, arg0: float) -> None:
            """
            Temperature in Celsius
            """
        @property
        def tempCompensationCount(self) -> int:
            """
            Number of times the Pigeon has temperature compensated the various signals.
            This counter overflows from 15 -> 0 with no cap.

            :type: int
            """
        @tempCompensationCount.setter
        def tempCompensationCount(self, arg0: int) -> None:
            """
            Number of times the Pigeon has temperature compensated the various signals.
            This counter overflows from 15 -> 0 with no cap.
            """
        @property
        def upTimeSec(self) -> int:
            """
            Number of seconds Pigeon has been up (since boot).
            This register is reset on power boot or processor reset.
            Register is capped at 255 seconds with no wrap around.

            :type: int
            """
        @upTimeSec.setter
        def upTimeSec(self, arg0: int) -> None:
            """
            Number of seconds Pigeon has been up (since boot).
            This register is reset on power boot or processor reset.
            Register is capped at 255 seconds with no wrap around.
            """
        pass
    class PigeonState():
        """
        Overall state of the Pigeon.

        Members:

          NoComm : No communications with Pigeon

          Initializing : Pigeon is initializing

          Ready : Pigeon is ready

          UserCalibration : Pigeon is calibrating due to user
        """
        def __eq__(self, arg0: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __init__(self, arg0: int) -> None: ...
        def __int__(self) -> int: ...
        def __ne__(self, arg0: object) -> bool: ...
        def __repr__(self) -> str: ...
        def __setstate__(self, arg0: int) -> None: ...
        @property
        def name(self) -> None:
            """
            :type: None
            """
        Initializing: ctre._ctre.PigeonIMU.PigeonState # value = PigeonState.Initializing
        NoComm: ctre._ctre.PigeonIMU.PigeonState # value = PigeonState.NoComm
        Ready: ctre._ctre.PigeonIMU.PigeonState # value = PigeonState.Ready
        UserCalibration: ctre._ctre.PigeonIMU.PigeonState # value = PigeonState.UserCalibration
        __members__: dict # value = {'NoComm': PigeonState.NoComm, 'Initializing': PigeonState.Initializing, 'Ready': PigeonState.Ready, 'UserCalibration': PigeonState.UserCalibration}
        pass
    @typing.overload
    def __init__(self, deviceNumber: int) -> None: 
        """
        Create a Pigeon object that communicates with Pigeon on CAN Bus.

        :param deviceNumber: CAN Device Id of Pigeon [0,62]

        Create a Pigeon object that communciates with Pigeon through the
        Gadgeteer ribbon cable connected to a Talon on CAN Bus.

        :param talonSrx: Object for the TalonSRX connected via ribbon cable.
        """
    @typing.overload
    def __init__(self, talonSrx: TalonSRX) -> None: ...
    def addFusedHeading(self, angleDeg: float, timeoutMs: int = 0) -> int: 
        """
        Atomically add to the Fused Heading register.

        :param angleDeg: Degrees to add to the Fused Heading register.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def addYaw(self, angleDeg: float, timeoutMs: int = 0) -> int: 
        """
        Atomically add to the Yaw register.

        :param angleDeg: Degrees to add to the Yaw register.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def clearStickyFaults(self, timeoutMs: int = 0) -> ErrorCode: 
        """
        Clears the Sticky Faults

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configAllSettings(self, allConfigs: PigeonIMUConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures all persistent settings.

        :param allConfigs: Object with all of the persistant settings

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configFactoryDefault(self, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures all persistent settings to defaults.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configGetCustomParam(self, paramIndex: int, timeoutMs: int = 0) -> int: 
        """
        Gets the value of a custom parameter. This is for arbitrary use.

        Sometimes it is necessary to save calibration/declination/offset
        information in the device. Particularly if the
        device is part of a subsystem that can be replaced.

        :param paramIndex: Index of custom parameter. [0-1]

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Value of the custom param.
        """
    @typing.overload
    def configGetParameter(self, param: ParamEnum, ordinal: int, timeoutMs: int = 0) -> float: 
        """
        Gets a parameter. Generally this is not used.
        This can be utilized in
        - Using new features without updating API installation.
        - Errata workarounds to circumvent API implementation.
        - Allows for rapid testing / unit testing of firmware.

        :param param: Parameter enumeration.

        :param ordinal: Ordinal of parameter.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Value of parameter.

        Gets a parameter by passing an int by reference

        :param param: Parameter enumeration

        :param valueToSend: Value to send to parameter

        :param valueReceived: Reference to integer to receive

        :param subValue: SubValue of parameter

        :param ordinal: Ordinal of parameter

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                     config success and report an error if it times out.
                     If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configGetParameter(self, param: ParamEnum, valueToSend: int, valueReceived: int, subValue: int, ordinal: int, timeoutMs: int) -> ErrorCode: ...
    def configSetCustomParam(self, newValue: int, paramIndex: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the value of a custom parameter. This is for arbitrary use.

        Sometimes it is necessary to save calibration/declination/offset
        information in the device. Particularly if the
        device is part of a subsystem that can be replaced.

        :param newValue: Value for custom parameter.

        :param paramIndex: Index of custom parameter. [0-1]

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSetParameter(self, param: ParamEnum, value: float, subValue: int, ordinal: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets a parameter. Generally this is not used.
        This can be utilized in
        - Using new features without updating API installation.
        - Errata workarounds to circumvent API implementation.
        - Allows for rapid testing / unit testing of firmware.

        :param param: Parameter enumeration.

        :param value: Value of parameter.

        :param subValue: Subvalue for parameter. Maximum value of 255.

        :param ordinal: Ordinal of parameter.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configTemperatureCompensationEnable(self, bTempCompEnable: bool, timeoutMs: int = 0) -> int: 
        """
        @deprecated use setTemperatureCompensationDisable instead
        This was done to better match with the lower level API.
        NOTE: this isn't a persistant config, every boot temperature
        compensation will be enabled
        This was also done so the default value for the paramter is false instead of true.
        Enable/Disable Temp compensation. Pigeon defaults with this on at boot.

        :param bTempCompEnable: Set to "True" to enable temperature compensation.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                       config success and report an error if it times out.
                       If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @staticmethod
    def destroyAllPigeonIMUs() -> None: 
        """
        Destructs all pigeon objects
        """
    def enterCalibrationMode(self, calMode: PigeonIMU.CalibrationMode, timeoutMs: int = 0) -> int: 
        """
        Enters the Calbration mode.  See the Pigeon IMU documentation for More
        information on Calibration.

        Note that you can instead use Phoenix Tuner to accomplish this.
        Note you should NOT be calling this during normal robot operation.

        :param calMode: Calibration to execute

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def get6dQuaternion(self) -> typing.Tuple[int, typing.List[float[4]]]: 
        """
        Get 6d Quaternion data.

        :param wxyz: Array to fill with quaternion data w[0], x[1], y[2], z[3]

        :returns: The last ErrorCode generated.
        """
    def getAbsoluteCompassHeading(self) -> float: 
        """
        Get the absolute compass heading.

        :returns: compass heading [0,360) degrees.
        """
    def getAccelerometerAngles(self) -> typing.Tuple[int, typing.List[float[3]]]: 
        """
        Get Accelerometer tilt angles.

        :param tiltAngles: Array to fill with x[0], y[1], and z[2] angles in degrees.

        :returns: The last ErrorCode generated.
        """
    def getAccumGyro(self) -> typing.Tuple[int, typing.List[float[3]]]: 
        """
        Get AccumGyro data.
        AccumGyro is the integrated gyro value on each axis.

        :param xyz_deg: Array to fill with x[0], y[1], and z[2] AccumGyro data

        :returns: The last ErrorCode generated.
        """
    def getAllConfigs(self, allConfigs: PigeonIMUConfiguration, timeoutMs: int = 50) -> None: 
        """
        Gets all persistant settings.

        :param allConfigs: Object with all of the persistant settings

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.
        """
    def getBiasedAccelerometer(self) -> typing.Tuple[int, typing.List[int[3]]]: 
        """
        Get Biased Accelerometer data.

        :param ba_xyz: Array to fill with x[0], y[1], and z[2] data.
              These are in fixed point notation Q2.14.  eg. 16384 = 1G

        :returns: The last ErrorCode generated.
        """
    def getBiasedMagnetometer(self) -> typing.Tuple[int, typing.List[int[3]]]: 
        """
        Get Biased Magnetometer data.

        :param bm_xyz: Array to fill with x[0], y[1], and z[2] data
              Number is equal to 0.6 microTeslas per unit.

        :returns: The last ErrorCode generated.
        """
    def getCompassFieldStrength(self) -> float: 
        """
        Gets the compass' measured magnetic field strength.

        :returns: field strength in Microteslas (uT).
        """
    def getCompassHeading(self) -> float: 
        """
        Get the continuous compass heading.

        :returns: continuous compass heading [-23040, 23040) degrees. Use
                  SetCompassHeading to modify the wrap-around portion.
        """
    def getFaults(self, toFill: PigeonIMU_Faults) -> ErrorCode: 
        """
        Gets the fault status

        :param toFill: Container for fault statuses.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getFirmVers(self) -> int: 
        """
        :returns: firmware version of Pigeon
        """
    def getFirmwareVersion(self) -> int: 
        """
        Gets the firmware version of the device.

        :returns: param holds the firmware version of the device. Device must be powered
                  cycled at least once.
        """
    @typing.overload
    def getFusedHeading(self) -> float: 
        """
        Get the current Fusion Status (including fused heading)

        :param status: object reference to fill with fusion status flags.
              Caller may pass null if flags are not needed.

        :returns: The fused heading in degrees.

        Gets the Fused Heading

        :returns: The fused heading in degrees.
        """
    @typing.overload
    def getFusedHeading(self, status: PigeonIMU.FusionStatus) -> float: ...
    def getGeneralStatus(self, statusToFill: PigeonIMU.GeneralStatus) -> int: 
        """
        Get the status of the current (or previousley complete) calibration.

        :param out: statusToFill Container for the status information.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getLastError(self) -> ErrorCode: 
        """
        Call GetLastError() generated by this object.
        Not all functions return an error code but can
        potentially report errors.

        This function can be used to retrieve those error codes.

        :returns: The last ErrorCode generated.
        """
    def getLowLevelHandle(self) -> capsule: 
        """
        :returns: Pigeon resource handle.
        """
    def getRawGyro(self) -> typing.Tuple[int, typing.List[float[3]]]: 
        """
        Get Raw Gyro data.

        :param xyz_dps: Array to fill with x[0], y[1], and z[2] data in degrees per second.

        :returns: The last ErrorCode generated.
        """
    def getRawMagnetometer(self) -> typing.Tuple[int, typing.List[int[3]]]: 
        """
        Get Raw Magnetometer data.

        :param rm_xyz: Array to fill with x[0], y[1], and z[2] data
              Number is equal to 0.6 microTeslas per unit.

        :returns: The last ErrorCode generated.
        """
    def getResetCount(self) -> int: 
        """
        :returns: number of times Pigeon Reset
        """
    def getResetFlags(self) -> int: 
        """
        :returns: Reset flags for Pigeon
        """
    def getState(self) -> PigeonIMU.PigeonState: 
        """
        Gets the current Pigeon state

        :returns: PigeonState enum
        """
    def getStatusFramePeriod(self, frame: PigeonIMU_StatusFrame, timeoutMs: int = 0) -> int: 
        """
        Gets the period of the given status frame.

        :param frame: Frame to get the period of.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Period of the given status frame.
        """
    def getStickyFaults(self, toFill: PigeonIMU_StickyFaults) -> ErrorCode: 
        """
        Gets the sticky fault status

        :param toFill: Container for sticky fault statuses.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getTemp(self) -> float: 
        """
        Gets the temperature of the pigeon.

        :returns: Temperature in ('C)
        """
    def getUpTime(self) -> int: 
        """
        Gets the current Pigeon uptime.

        :returns: How long has Pigeon been running in whole seconds. Value caps at
                  255.
        """
    def getYawPitchRoll(self) -> typing.Tuple[int, typing.List[float[3]]]: 
        """
        Get Yaw, Pitch, and Roll data.

        :param ypr: Array to fill with yaw[0], pitch[1], and roll[2] data.
           Yaw is within [-368,640, +368,640] degrees.
           Pitch is within [-90,+90] degrees.
           Roll is within [-90,+90] degrees.

        :returns: The last ErrorCode generated.
        """
    def hasResetOccurred(self) -> bool: 
        """
        :returns: true iff a reset has occurred since last call.
        """
    def setAccumZAngle(self, angleDeg: float, timeoutMs: int = 0) -> int: 
        """
        Sets the AccumZAngle.

        :param angleDeg: Degrees to set AccumZAngle to.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setCompassAngle(self, angleDeg: float, timeoutMs: int = 0) -> int: 
        """
        Sets the compass angle. Although compass is absolute [0,360) degrees, the
        continuous compass register holds the wrap-arounds.

        :param angleDeg: Degrees to set continuous compass angle to.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setCompassDeclination(self, angleDegOffset: float, timeoutMs: int = 0) -> int: 
        """
        Set the declination for compass. Declination is the difference between
        Earth Magnetic north, and the geographic "True North".

        :param angleDegOffset: Degrees to set Compass Declination to.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                      config success and report an error if it times out.
                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setControlFramePeriod(self, frame: PigeonIMU_ControlFrame, periodMs: int) -> ErrorCode: 
        """
        Sets the period of the given control frame.

        :param frame: Frame whose period is to be changed.

        :param periodMs: Period in ms for the given frame.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setFusedHeading(self, angleDeg: float, timeoutMs: int = 0) -> int: 
        """
        Sets the Fused Heading to the specified value.

        :param angleDeg: New fused-heading in degrees [+/- 23,040 degrees]

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setFusedHeadingToCompass(self, timeoutMs: int = 0) -> int: 
        """
        Sets the Fused Heading register to match the current compass value.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setStatusFramePeriod(self, statusFrame: PigeonIMU_StatusFrame, periodMs: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the period of the given status frame.

        :param statusFrame: Frame whose period is to be changed.

        :param periodMs: Period in ms for the given frame.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                   config success and report an error if it times out.
                   If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setTemperatureCompensationDisable(self, bTempCompDisable: bool, timeoutMs: int = 0) -> int: 
        """
        Disable/Enable Temp compensation. Pigeon has this on/False at boot.

        :param bTempCompDisable: Set to "False" to enable temperature compensation.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                        config success and report an error if it times out.
                        If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setYaw(self, angleDeg: float, timeoutMs: int = 0) -> int: 
        """
        Sets the Yaw register to the specified value.

        :param angleDeg: Degree of Yaw  [+/- 368,640 degrees]

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def setYawToCompass(self, timeoutMs: int = 0) -> int: 
        """
        Sets the Yaw register to match the current compass value.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @staticmethod
    @typing.overload
    def toString(cm: PigeonIMU.CalibrationMode) -> str: 
        """
        Gets the string representation of a PigeonState

        :param state: PigeonState to get the string representation of

        :returns: string representation of specified PigeonState

        Gets the string representation of a CalibrationMode

        :param cm: CalibrationMode to get the string representation of

        :returns: string representation of specified CalibrationMode
        """
    @staticmethod
    @typing.overload
    def toString(state: PigeonIMU.PigeonState) -> str: ...
    pass
class PigeonIMUConfigUtils():
    """
    Util class to help with Pigeon configurations
    """
    def __init__(self) -> None: ...
    @staticmethod
    def customParam0Different(settings: PigeonIMUConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    @staticmethod
    def customParam1Different(settings: PigeonIMUConfiguration) -> bool: ...
    pass
class PigeonIMUConfiguration(CustomParamConfiguration):
    """
    Configurables available to Pigeon
    """
    def __init__(self) -> None: ...
    @typing.overload
    def toString(self) -> str: 
        """
        :returns: String representation of configs



        :param prependString: String to prepend to configs

        :returns: String representation of configs
        """
    @typing.overload
    def toString(self, prependString: str) -> str: ...
    pass
class PigeonIMU_ControlFrame():
    """
    Enumerated type for status frame types.

    Members:

      PigeonIMU_CondStatus_Control_1
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    PigeonIMU_CondStatus_Control_1: ctre._ctre.PigeonIMU_ControlFrame # value = PigeonIMU_ControlFrame.PigeonIMU_CondStatus_Control_1
    __members__: dict # value = {'PigeonIMU_CondStatus_Control_1': PigeonIMU_ControlFrame.PigeonIMU_CondStatus_Control_1}
    pass
class PigeonIMU_Faults():
    """
    Faults available to Pigeon (Currently has none)
    """
    @typing.overload
    def __init__(self) -> None: 
        """
        Updates current fault list with specified bit field of faults

        :param bits: bit field of faults to update with
        """
    @typing.overload
    def __init__(self, bits: int) -> None: ...
    def hasAnyFault(self) -> bool: 
        """
        :returns: true if any faults are tripped
        """
    def toBitfield(self) -> int: 
        """
        :returns: Current fault list as a bit field
        """
    pass
class PigeonIMU_StatusFrame():
    """
    Enumerated type for status frame types.

    Members:

      PigeonIMU_CondStatus_1_General

      PigeonIMU_CondStatus_9_SixDeg_YPR

      PigeonIMU_CondStatus_6_SensorFusion

      PigeonIMU_CondStatus_11_GyroAccum

      PigeonIMU_CondStatus_2_GeneralCompass

      PigeonIMU_CondStatus_3_GeneralAccel

      PigeonIMU_CondStatus_10_SixDeg_Quat

      PigeonIMU_RawStatus_4_Mag

      PigeonIMU_BiasedStatus_2_Gyro

      PigeonIMU_BiasedStatus_4_Mag

      PigeonIMU_BiasedStatus_6_Accel
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    PigeonIMU_BiasedStatus_2_Gyro: ctre._ctre.PigeonIMU_StatusFrame # value = PigeonIMU_StatusFrame.PigeonIMU_BiasedStatus_2_Gyro
    PigeonIMU_BiasedStatus_4_Mag: ctre._ctre.PigeonIMU_StatusFrame # value = PigeonIMU_StatusFrame.PigeonIMU_RawStatus_4_Mag
    PigeonIMU_BiasedStatus_6_Accel: ctre._ctre.PigeonIMU_StatusFrame # value = PigeonIMU_StatusFrame.PigeonIMU_BiasedStatus_6_Accel
    PigeonIMU_CondStatus_10_SixDeg_Quat: ctre._ctre.PigeonIMU_StatusFrame # value = PigeonIMU_StatusFrame.PigeonIMU_CondStatus_10_SixDeg_Quat
    PigeonIMU_CondStatus_11_GyroAccum: ctre._ctre.PigeonIMU_StatusFrame # value = PigeonIMU_StatusFrame.PigeonIMU_CondStatus_11_GyroAccum
    PigeonIMU_CondStatus_1_General: ctre._ctre.PigeonIMU_StatusFrame # value = PigeonIMU_StatusFrame.PigeonIMU_CondStatus_1_General
    PigeonIMU_CondStatus_2_GeneralCompass: ctre._ctre.PigeonIMU_StatusFrame # value = PigeonIMU_StatusFrame.PigeonIMU_CondStatus_2_GeneralCompass
    PigeonIMU_CondStatus_3_GeneralAccel: ctre._ctre.PigeonIMU_StatusFrame # value = PigeonIMU_StatusFrame.PigeonIMU_CondStatus_3_GeneralAccel
    PigeonIMU_CondStatus_6_SensorFusion: ctre._ctre.PigeonIMU_StatusFrame # value = PigeonIMU_StatusFrame.PigeonIMU_CondStatus_6_SensorFusion
    PigeonIMU_CondStatus_9_SixDeg_YPR: ctre._ctre.PigeonIMU_StatusFrame # value = PigeonIMU_StatusFrame.PigeonIMU_CondStatus_9_SixDeg_YPR
    PigeonIMU_RawStatus_4_Mag: ctre._ctre.PigeonIMU_StatusFrame # value = PigeonIMU_StatusFrame.PigeonIMU_RawStatus_4_Mag
    __members__: dict # value = {'PigeonIMU_CondStatus_1_General': PigeonIMU_StatusFrame.PigeonIMU_CondStatus_1_General, 'PigeonIMU_CondStatus_9_SixDeg_YPR': PigeonIMU_StatusFrame.PigeonIMU_CondStatus_9_SixDeg_YPR, 'PigeonIMU_CondStatus_6_SensorFusion': PigeonIMU_StatusFrame.PigeonIMU_CondStatus_6_SensorFusion, 'PigeonIMU_CondStatus_11_GyroAccum': PigeonIMU_StatusFrame.PigeonIMU_CondStatus_11_GyroAccum, 'PigeonIMU_CondStatus_2_GeneralCompass': PigeonIMU_StatusFrame.PigeonIMU_CondStatus_2_GeneralCompass, 'PigeonIMU_CondStatus_3_GeneralAccel': PigeonIMU_StatusFrame.PigeonIMU_CondStatus_3_GeneralAccel, 'PigeonIMU_CondStatus_10_SixDeg_Quat': PigeonIMU_StatusFrame.PigeonIMU_CondStatus_10_SixDeg_Quat, 'PigeonIMU_RawStatus_4_Mag': PigeonIMU_StatusFrame.PigeonIMU_RawStatus_4_Mag, 'PigeonIMU_BiasedStatus_2_Gyro': PigeonIMU_StatusFrame.PigeonIMU_BiasedStatus_2_Gyro, 'PigeonIMU_BiasedStatus_4_Mag': PigeonIMU_StatusFrame.PigeonIMU_RawStatus_4_Mag, 'PigeonIMU_BiasedStatus_6_Accel': PigeonIMU_StatusFrame.PigeonIMU_BiasedStatus_6_Accel}
    pass
class PigeonIMU_StickyFaults():
    """
    Sticky faults available to Pigeon
    """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates fault list with specified bit field of faults

        :param bits: bit field of faults to update with
        """
    @typing.overload
    def __init__(self, bits: int) -> None: ...
    def hasAnyFault(self) -> bool: 
        """
        :returns: true if any faults are tripped
        """
    def toBitfield(self) -> int: 
        """
        :returns: Current fault list as a bit field
        """
    pass
class RemoteFeedbackDevice():
    """
    Choose the remote feedback device for a motor controller.

    Members:

      FactoryDefaultOff : [[deprecated("Use None instead.")]]
    Factory default setting for non-enhanced motor controllers

      SensorSum : Use Sum0 + Sum1

      SensorDifference : Use Diff0 - Diff1

      RemoteSensor0 : Use the sensor configured
    in filter0

      RemoteSensor1 : Use the sensor configured
    in filter1

      None_ : Position and velocity will read 0.

      SoftwareEmulatedSensor : Motor Controller will fake a sensor based on applied motor output.
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    FactoryDefaultOff: ctre._ctre.RemoteFeedbackDevice # value = RemoteFeedbackDevice.FactoryDefaultOff
    None_: ctre._ctre.RemoteFeedbackDevice # value = RemoteFeedbackDevice.None_
    RemoteSensor0: ctre._ctre.RemoteFeedbackDevice # value = RemoteFeedbackDevice.RemoteSensor0
    RemoteSensor1: ctre._ctre.RemoteFeedbackDevice # value = RemoteFeedbackDevice.RemoteSensor1
    SensorDifference: ctre._ctre.RemoteFeedbackDevice # value = RemoteFeedbackDevice.SensorDifference
    SensorSum: ctre._ctre.RemoteFeedbackDevice # value = RemoteFeedbackDevice.SensorSum
    SoftwareEmulatedSensor: ctre._ctre.RemoteFeedbackDevice # value = RemoteFeedbackDevice.SoftwareEmulatedSensor
    __members__: dict # value = {'FactoryDefaultOff': RemoteFeedbackDevice.FactoryDefaultOff, 'SensorSum': RemoteFeedbackDevice.SensorSum, 'SensorDifference': RemoteFeedbackDevice.SensorDifference, 'RemoteSensor0': RemoteFeedbackDevice.RemoteSensor0, 'RemoteSensor1': RemoteFeedbackDevice.RemoteSensor1, 'None_': RemoteFeedbackDevice.None_, 'SoftwareEmulatedSensor': RemoteFeedbackDevice.SoftwareEmulatedSensor}
    pass
class RemoteLimitSwitchSource():
    """
    Remote Limit switch source enum

    Members:

      FactoryDefaultOff : Don't use limit switch, this is the factory default value

      RemoteTalonSRX : Use Limit switch connected to TalonSRX on CAN

      RemoteCANifier : User Limit switch connected to CANifier

      Deactivated : Don't use a limit switch
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Deactivated: ctre._ctre.RemoteLimitSwitchSource # value = RemoteLimitSwitchSource.Deactivated
    FactoryDefaultOff: ctre._ctre.RemoteLimitSwitchSource # value = RemoteLimitSwitchSource.FactoryDefaultOff
    RemoteCANifier: ctre._ctre.RemoteLimitSwitchSource # value = RemoteLimitSwitchSource.RemoteCANifier
    RemoteTalonSRX: ctre._ctre.RemoteLimitSwitchSource # value = RemoteLimitSwitchSource.RemoteTalonSRX
    __members__: dict # value = {'FactoryDefaultOff': RemoteLimitSwitchSource.FactoryDefaultOff, 'RemoteTalonSRX': RemoteLimitSwitchSource.RemoteTalonSRX, 'RemoteCANifier': RemoteLimitSwitchSource.RemoteCANifier, 'Deactivated': RemoteLimitSwitchSource.Deactivated}
    pass
class RemoteSensorSource():
    """
    Choose the remote sensor source for a motor controller

    Members:

      Off : Don't use a sensor

      TalonSRX_SelectedSensor : Use a sensor connected to
    a TalonSRX and configured on
    the TalonSRX

      Pigeon_Yaw : Use a CAN Pigeon's Yaw value

      Pigeon_Pitch : Use a CAN Pigeon's Pitch value

      Pigeon_Roll : Use a CAN Pigeon's Roll value

      CANifier_Quadrature : Use a quadrature sensor
    connected to a CANifier

      CANifier_PWMInput0 : Use a PWM sensor connected
    to CANifier's PWM0

      CANifier_PWMInput1 : Use a PWM sensor connected
    to CANifier's PWM1

      CANifier_PWMInput2 : Use a PWM sensor connected
    to CANifier's PWM2

      CANifier_PWMInput3 : Use a PWM sensor connected
    to CANifier's PWM3

      GadgeteerPigeon_Yaw : Use the yaw value of a pigeon
    connected to a talon over ribbon cable

      GadgeteerPigeon_Pitch : Use the pitch value of a pigeon
    connected to a talon over ribbon cable

      GadgeteerPigeon_Roll : Use the roll value of a pigeon
    connected to a talon over ribbon cable

      CANCoder : Use CANCoder

      TalonFX_SelectedSensor : Use a sensor connected to
    a TalonFX and configured on
    the TalonFX
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    CANCoder: ctre._ctre.RemoteSensorSource # value = RemoteSensorSource.CANCoder
    CANifier_PWMInput0: ctre._ctre.RemoteSensorSource # value = RemoteSensorSource.CANifier_PWMInput0
    CANifier_PWMInput1: ctre._ctre.RemoteSensorSource # value = RemoteSensorSource.CANifier_PWMInput1
    CANifier_PWMInput2: ctre._ctre.RemoteSensorSource # value = RemoteSensorSource.CANifier_PWMInput2
    CANifier_PWMInput3: ctre._ctre.RemoteSensorSource # value = RemoteSensorSource.CANifier_PWMInput3
    CANifier_Quadrature: ctre._ctre.RemoteSensorSource # value = RemoteSensorSource.CANifier_Quadrature
    GadgeteerPigeon_Pitch: ctre._ctre.RemoteSensorSource # value = RemoteSensorSource.GadgeteerPigeon_Pitch
    GadgeteerPigeon_Roll: ctre._ctre.RemoteSensorSource # value = RemoteSensorSource.GadgeteerPigeon_Roll
    GadgeteerPigeon_Yaw: ctre._ctre.RemoteSensorSource # value = RemoteSensorSource.GadgeteerPigeon_Yaw
    Off: ctre._ctre.RemoteSensorSource # value = RemoteSensorSource.Off
    Pigeon_Pitch: ctre._ctre.RemoteSensorSource # value = RemoteSensorSource.Pigeon_Pitch
    Pigeon_Roll: ctre._ctre.RemoteSensorSource # value = RemoteSensorSource.Pigeon_Roll
    Pigeon_Yaw: ctre._ctre.RemoteSensorSource # value = RemoteSensorSource.Pigeon_Yaw
    TalonFX_SelectedSensor: ctre._ctre.RemoteSensorSource # value = RemoteSensorSource.TalonSRX_SelectedSensor
    TalonSRX_SelectedSensor: ctre._ctre.RemoteSensorSource # value = RemoteSensorSource.TalonSRX_SelectedSensor
    __members__: dict # value = {'Off': RemoteSensorSource.Off, 'TalonSRX_SelectedSensor': RemoteSensorSource.TalonSRX_SelectedSensor, 'Pigeon_Yaw': RemoteSensorSource.Pigeon_Yaw, 'Pigeon_Pitch': RemoteSensorSource.Pigeon_Pitch, 'Pigeon_Roll': RemoteSensorSource.Pigeon_Roll, 'CANifier_Quadrature': RemoteSensorSource.CANifier_Quadrature, 'CANifier_PWMInput0': RemoteSensorSource.CANifier_PWMInput0, 'CANifier_PWMInput1': RemoteSensorSource.CANifier_PWMInput1, 'CANifier_PWMInput2': RemoteSensorSource.CANifier_PWMInput2, 'CANifier_PWMInput3': RemoteSensorSource.CANifier_PWMInput3, 'GadgeteerPigeon_Yaw': RemoteSensorSource.GadgeteerPigeon_Yaw, 'GadgeteerPigeon_Pitch': RemoteSensorSource.GadgeteerPigeon_Pitch, 'GadgeteerPigeon_Roll': RemoteSensorSource.GadgeteerPigeon_Roll, 'CANCoder': RemoteSensorSource.CANCoder, 'TalonFX_SelectedSensor': RemoteSensorSource.TalonSRX_SelectedSensor}
    pass
class RemoteSensorSourceRoutines():
    """
    Class used to get string representation of a remote sensor source
    """
    def __init__(self) -> None: ...
    @staticmethod
    def toString(value: RemoteSensorSource) -> str: 
        """
        Get string representation of specified remote sensor source

        :param value: remote sensor source to get string of

        :returns: string representation of specified remote sensor source
        """
    pass
class SensorCollection():
    """
    Collection of sensors available to a motor controller.

    For best performance and update-rate,
    we recommend using the configSelectedFeedbackSensor() and getSelectedSensor*() routines.
    However there are occasions where accessing raw sensor values may be useful or convenient.
    Particularly if you are seeding one sensor based on another, or need to circumvent sensor-phase.

    Use the getSensorCollection() routine inside your motor controller to create a sensor collection.
    """
    def __init__(self, motorController: BaseTalon) -> None: 
        """
        Constructor for SensorCollection

        :param motorController: Talon Motor Controller to connect Collection to
        """
    def getAnalogIn(self) -> int: ...
    def getAnalogInRaw(self) -> int: ...
    def getAnalogInVel(self) -> int: ...
    def getPinStateQuadA(self) -> int: ...
    def getPinStateQuadB(self) -> int: ...
    def getPinStateQuadIdx(self) -> int: ...
    def getPulseWidthPosition(self) -> int: ...
    def getPulseWidthRiseToFallUs(self) -> int: ...
    def getPulseWidthRiseToRiseUs(self) -> int: ...
    def getPulseWidthVelocity(self) -> int: ...
    def getQuadraturePosition(self) -> int: ...
    def getQuadratureVelocity(self) -> int: ...
    def isFwdLimitSwitchClosed(self) -> int: ...
    def isRevLimitSwitchClosed(self) -> int: ...
    def setAnalogPosition(self, newPosition: int, timeoutMs: int = 0) -> ErrorCode: ...
    def setPulseWidthPosition(self, newPosition: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets pulse width position.

        :param newPosition: The position value to apply to the sensor.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                   config success and report an error if it times out.
                   If zero, no blocking or checking is performed.

        :returns: an ErrErrorCode
        """
    def setQuadraturePosition(self, newPosition: int, timeoutMs: int = 0) -> ErrorCode: ...
    def syncQuadratureWithPulseWidth(self, bookend0: int, bookend1: int, bCrossZeroOnInterval: bool, offset: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    pass
class SensorInitializationStrategy():
    """
    Enum for how CANCoder should initialize its position register on boot.

    Members:

      BootToZero : On boot up, set position to zero.

      BootToAbsolutePosition : On boot up, sync to the Absolute Position signal.  The Absolute position signal will be signed according to the selected Absolute Sensor Range.
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    BootToAbsolutePosition: ctre._ctre.SensorInitializationStrategy # value = SensorInitializationStrategy.BootToAbsolutePosition
    BootToZero: ctre._ctre.SensorInitializationStrategy # value = SensorInitializationStrategy.BootToZero
    __members__: dict # value = {'BootToZero': SensorInitializationStrategy.BootToZero, 'BootToAbsolutePosition': SensorInitializationStrategy.BootToAbsolutePosition}
    pass
class SensorInitializationStrategyRoutines():
    """
    Class to handle routines specific to VelocityMeasPeriod
    """
    def __init__(self) -> None: ...
    @staticmethod
    def toString(value: SensorInitializationStrategy) -> str: 
        """
        String representation of specified SensorInitializationStrategy

        :param value: CANCoderVelocityMeasPeriod to convert to a string

        :returns: string representation of SensorInitializationStrategy
        """
    pass
class SensorTerm():
    """
    Choose the sensor term for a motor controller

    Members:

      Sum0 : Choose Sum0 for a term

      Sum1 : Choose Sum1 for a term

      Diff0 : Choose Diff0 for a term

      Diff1 : Choose Diff1 for a term
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Diff0: ctre._ctre.SensorTerm # value = SensorTerm.Diff0
    Diff1: ctre._ctre.SensorTerm # value = SensorTerm.Diff1
    Sum0: ctre._ctre.SensorTerm # value = SensorTerm.Sum0
    Sum1: ctre._ctre.SensorTerm # value = SensorTerm.Sum1
    __members__: dict # value = {'Sum0': SensorTerm.Sum0, 'Sum1': SensorTerm.Sum1, 'Diff0': SensorTerm.Diff0, 'Diff1': SensorTerm.Diff1}
    pass
class SensorTermRoutines():
    """
    Class to handle routines specific to SensorTerm
    """
    def __init__(self) -> None: ...
    @staticmethod
    def toString(value: SensorTerm) -> str: 
        """
        Gets the string representation of specified SensorTerm value

        :param value: SensorTerm to get string representation of

        :returns: string representation of specified SensorTerm
        """
    pass
class SensorTimeBase():
    """
    Velocity Measurement Periods

    Members:

      Per100Ms_Legacy : Legacy Mode

      PerSecond : Per-Second Velocities

      PerMinute : Per-Minute Velocities
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Per100Ms_Legacy: ctre._ctre.SensorTimeBase # value = SensorTimeBase.Per100Ms_Legacy
    PerMinute: ctre._ctre.SensorTimeBase # value = SensorTimeBase.PerMinute
    PerSecond: ctre._ctre.SensorTimeBase # value = SensorTimeBase.PerSecond
    __members__: dict # value = {'Per100Ms_Legacy': SensorTimeBase.Per100Ms_Legacy, 'PerSecond': SensorTimeBase.PerSecond, 'PerMinute': SensorTimeBase.PerMinute}
    pass
class SensorTimeBaseRoutines():
    """
    Class to handle routines specific to SensorTimeBase
    """
    def __init__(self) -> None: ...
    @staticmethod
    def toString(value: SensorTimeBase) -> str: 
        """
        String representation of specified SensorTimeBase

        :param value: SensorTimeBase to convert to a string

        :returns: string representation of SensorTimeBase
        """
    pass
class SensorVelocityMeasPeriod():
    """
    Enumerate filter periods for any sensor that measures velocity.

    Members:

      Period_1Ms : 1ms velocity measurement period

      Period_2Ms : 2ms velocity measurement period

      Period_5Ms : 5ms velocity measurement period

      Period_10Ms : 10ms velocity measurement period

      Period_20Ms : 20ms velocity measurement period

      Period_25Ms : 25ms velocity measurement period

      Period_50Ms : 50ms velocity measurement period

      Period_100Ms : 100ms velocity measurement period
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Period_100Ms: ctre._ctre.SensorVelocityMeasPeriod # value = SensorVelocityMeasPeriod.Period_100Ms
    Period_10Ms: ctre._ctre.SensorVelocityMeasPeriod # value = SensorVelocityMeasPeriod.Period_10Ms
    Period_1Ms: ctre._ctre.SensorVelocityMeasPeriod # value = SensorVelocityMeasPeriod.Period_1Ms
    Period_20Ms: ctre._ctre.SensorVelocityMeasPeriod # value = SensorVelocityMeasPeriod.Period_20Ms
    Period_25Ms: ctre._ctre.SensorVelocityMeasPeriod # value = SensorVelocityMeasPeriod.Period_25Ms
    Period_2Ms: ctre._ctre.SensorVelocityMeasPeriod # value = SensorVelocityMeasPeriod.Period_2Ms
    Period_50Ms: ctre._ctre.SensorVelocityMeasPeriod # value = SensorVelocityMeasPeriod.Period_50Ms
    Period_5Ms: ctre._ctre.SensorVelocityMeasPeriod # value = SensorVelocityMeasPeriod.Period_5Ms
    __members__: dict # value = {'Period_1Ms': SensorVelocityMeasPeriod.Period_1Ms, 'Period_2Ms': SensorVelocityMeasPeriod.Period_2Ms, 'Period_5Ms': SensorVelocityMeasPeriod.Period_5Ms, 'Period_10Ms': SensorVelocityMeasPeriod.Period_10Ms, 'Period_20Ms': SensorVelocityMeasPeriod.Period_20Ms, 'Period_25Ms': SensorVelocityMeasPeriod.Period_25Ms, 'Period_50Ms': SensorVelocityMeasPeriod.Period_50Ms, 'Period_100Ms': SensorVelocityMeasPeriod.Period_100Ms}
    pass
class SensorVelocityMeasPeriodRoutines():
    """
    Class to handle routines specific to VelocityMeasPeriod
    """
    def __init__(self) -> None: ...
    @staticmethod
    def toString(value: SensorVelocityMeasPeriod) -> str: 
        """
        String representation of specified CANCoderVelocityMeasPeriod

        :param value: CANCoderVelocityMeasPeriod to convert to a string

        :returns: string representation of CANCoderVelocityMeasPeriod
        """
    pass
class SetValueMotionProfile():
    """
    Members:

      Disable

      Enable

      Hold
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Disable: ctre._ctre.SetValueMotionProfile # value = SetValueMotionProfile.Disable
    Enable: ctre._ctre.SetValueMotionProfile # value = SetValueMotionProfile.Enable
    Hold: ctre._ctre.SetValueMotionProfile # value = SetValueMotionProfile.Hold
    __members__: dict # value = {'Disable': SetValueMotionProfile.Disable, 'Enable': SetValueMotionProfile.Enable, 'Hold': SetValueMotionProfile.Hold}
    pass
class SlotConfigUtil():
    """
    Util Class to help with slot configs
    """
    @staticmethod
    def KDDifferent(settings: SlotConfiguration) -> bool: ...
    @staticmethod
    def KFDifferent(settings: SlotConfiguration) -> bool: ...
    @staticmethod
    def KIDifferent(settings: SlotConfiguration) -> bool: ...
    @staticmethod
    def KPDifferent(settings: SlotConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    def __init__(self) -> None: ...
    @staticmethod
    def allowableClosedloopErrorDifferent(settings: SlotConfiguration) -> bool: ...
    @staticmethod
    def closedLoopPeakOutputDifferent(settings: SlotConfiguration) -> bool: ...
    @staticmethod
    def closedLoopPeriodDifferent(settings: SlotConfiguration) -> bool: ...
    @staticmethod
    def integralZoneDifferent(settings: SlotConfiguration) -> bool: ...
    @staticmethod
    def maxIntegralAccumulatorDifferent(settings: SlotConfiguration) -> bool: ...
    pass
class SlotConfiguration():
    """
    Configurables available to a slot
    """
    def __init__(self) -> None: ...
    @typing.overload
    def toString(self) -> str: 
        """
        :returns: String representation of configs



        :param prependString: String to prepend to configs

        :returns: String representation of configs
        """
    @typing.overload
    def toString(self, prependString: str) -> str: ...
    @property
    def allowableClosedloopError(self) -> int:
        """
        Allowable closed loop error to neutral (in native units)

        :type: int
        """
    @allowableClosedloopError.setter
    def allowableClosedloopError(self, arg0: int) -> None:
        """
        Allowable closed loop error to neutral (in native units)
        """
    @property
    def closedLoopPeakOutput(self) -> float:
        """
        Peak output from closed loop [0,1]

        :type: float
        """
    @closedLoopPeakOutput.setter
    def closedLoopPeakOutput(self, arg0: float) -> None:
        """
        Peak output from closed loop [0,1]
        """
    @property
    def closedLoopPeriod(self) -> int:
        """
        Desired period of closed loop [1,64]ms

        :type: int
        """
    @closedLoopPeriod.setter
    def closedLoopPeriod(self, arg0: int) -> None:
        """
        Desired period of closed loop [1,64]ms
        """
    @property
    def integralZone(self) -> int:
        """
        Integral zone (in native units)

        If the (absolute) closed-loop error is outside of this zone, integral
        accumulator is automatically cleared. This ensures than integral wind up
        events will stop after the sensor gets far enough from its target.

        :type: int
        """
    @integralZone.setter
    def integralZone(self, arg0: int) -> None:
        """
        Integral zone (in native units)

        If the (absolute) closed-loop error is outside of this zone, integral
        accumulator is automatically cleared. This ensures than integral wind up
        events will stop after the sensor gets far enough from its target.
        """
    @property
    def kD(self) -> float:
        """
        D Gain

        This is multiplied by derivative error (sensor units per PID loop, typically 1ms).
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '250' to get full output if derr is 4096u (Mag Encoder 1 rotation) per 1000 loops (typ 1 sec)

        :type: float
        """
    @kD.setter
    def kD(self, arg0: float) -> None:
        """
        D Gain

        This is multiplied by derivative error (sensor units per PID loop, typically 1ms).
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '250' to get full output if derr is 4096u (Mag Encoder 1 rotation) per 1000 loops (typ 1 sec)
        """
    @property
    def kF(self) -> float:
        """
        F Gain

        See documentation for calculation details.
        If using velocity, motion magic, or motion profile,
        use (1023 * duty-cycle / sensor-velocity-sensor-units-per-100ms).

        :type: float
        """
    @kF.setter
    def kF(self, arg0: float) -> None:
        """
        F Gain

        See documentation for calculation details.
        If using velocity, motion magic, or motion profile,
        use (1023 * duty-cycle / sensor-velocity-sensor-units-per-100ms).
        """
    @property
    def kI(self) -> float:
        """
        I Gain

        This is multiplied by accumulated closed loop error in sensor units every PID Loop.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.00025' to get full output if err is 4096u for 1000 loops (accumulater holds 4,096,000),
        [which is equivalent to one CTRE mag encoder rotation for 1000 milliseconds].

        :type: float
        """
    @kI.setter
    def kI(self, arg0: float) -> None:
        """
        I Gain

        This is multiplied by accumulated closed loop error in sensor units every PID Loop.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.00025' to get full output if err is 4096u for 1000 loops (accumulater holds 4,096,000),
        [which is equivalent to one CTRE mag encoder rotation for 1000 milliseconds].
        """
    @property
    def kP(self) -> float:
        """
        P Gain

        This is multiplied by closed loop error in sensor units.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.25' to get full output if err is 4096u (Mag Encoder 1 rotation)

        :type: float
        """
    @kP.setter
    def kP(self, arg0: float) -> None:
        """
        P Gain

        This is multiplied by closed loop error in sensor units.
        Note the closed loop output interprets a final value of 1023 as full output.
        So use a gain of '0.25' to get full output if err is 4096u (Mag Encoder 1 rotation)
        """
    @property
    def maxIntegralAccumulator(self) -> float:
        """
        Max integral accumulator (in native units)

        :type: float
        """
    @maxIntegralAccumulator.setter
    def maxIntegralAccumulator(self, arg0: float) -> None:
        """
        Max integral accumulator (in native units)
        """
    pass
class StatorCurrentLimitConfiguration():
    """
    Describes the desired stator current limiting behavior.
    """
    @typing.overload
    def __init__(self) -> None: 
        """
        Default c'tor.  Because currentLimit is zero, limiting id disabled.
        """
    @typing.overload
    def __init__(self, doubleArray: float, doubleArraySz: int) -> None: ...
    @typing.overload
    def __init__(self, enable: bool, currentLimit: float, triggerThresholdCurrent: float, triggerThresholdTime: float) -> None: ...
    def deserialize(self, doubles: float, doubleCnt: int) -> None: ...
    def equals(self, rhs: StatorCurrentLimitConfiguration) -> bool: ...
    def toArray(self) -> typing.List[float]: ...
    def toString(self) -> str: 
        """
        :returns: string representation of current faults tripped
        """
    @property
    def currentLimit(self) -> float:
        """
        The "holding" current (amperes) to limit to when feature is activated.

        :type: float
        """
    @currentLimit.setter
    def currentLimit(self, arg0: float) -> None:
        """
        The "holding" current (amperes) to limit to when feature is activated.
        """
    @property
    def enable(self) -> bool:
        """
        True/False to enable/disable limit feature.

        :type: bool
        """
    @enable.setter
    def enable(self, arg0: bool) -> None:
        """
        True/False to enable/disable limit feature.
        """
    @property
    def triggerThresholdCurrent(self) -> float:
        """
        Current must exceed this threshold (amperes) before limiting occurs.
        If this value is less than currentLimit, then currentLimit is used as the threshold.

        :type: float
        """
    @triggerThresholdCurrent.setter
    def triggerThresholdCurrent(self, arg0: float) -> None:
        """
        Current must exceed this threshold (amperes) before limiting occurs.
        If this value is less than currentLimit, then currentLimit is used as the threshold.
        """
    @property
    def triggerThresholdTime(self) -> float:
        """
        How long current must exceed threshold (seconds) before limiting occurs.

        :type: float
        """
    @triggerThresholdTime.setter
    def triggerThresholdTime(self, arg0: float) -> None:
        """
        How long current must exceed threshold (seconds) before limiting occurs.
        """
    pass
class StatusFrame():
    """
    The different status frames available to motor controllers

    Members:

      Status_1_General_ : General Status

      Status_2_Feedback0_ : Main controller feedback

      Status_4_AinTempVbat_ : Analog sensor, motor controller
    temperature, and voltage at input leads

      Status_6_Misc_ : Miscellaneous signals

      Status_7_CommStatus_ : Communication status to controller

      Status_9_MotProfBuffer_ : Motion profile buffer status

      Status_10_MotionMagic_ : Old name for Status 10.
    Use @see #Status_10_Targets instead.

      Status_10_Targets_ : Correct name for Status 10.
    Functionally equivalent to @see #Status_10_MotionMagic

      Status_12_Feedback1_ : Secondary controller feedback

      Status_13_Base_PIDF0_ : Base PID

      Status_14_Turn_PIDF1_ : Auxiliary PID

      Status_15_FirmareApiStatus_ : Firmware & API status information

      Status_17_Targets1_ : MotionProfile Targets for Auxiliary PID1.
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Status_10_MotionMagic_: ctre._ctre.StatusFrame # value = StatusFrame.Status_10_MotionMagic_
    Status_10_Targets_: ctre._ctre.StatusFrame # value = StatusFrame.Status_10_MotionMagic_
    Status_12_Feedback1_: ctre._ctre.StatusFrame # value = StatusFrame.Status_12_Feedback1_
    Status_13_Base_PIDF0_: ctre._ctre.StatusFrame # value = StatusFrame.Status_13_Base_PIDF0_
    Status_14_Turn_PIDF1_: ctre._ctre.StatusFrame # value = StatusFrame.Status_14_Turn_PIDF1_
    Status_15_FirmareApiStatus_: ctre._ctre.StatusFrame # value = StatusFrame.Status_15_FirmareApiStatus_
    Status_17_Targets1_: ctre._ctre.StatusFrame # value = StatusFrame.Status_17_Targets1_
    Status_1_General_: ctre._ctre.StatusFrame # value = StatusFrame.Status_1_General_
    Status_2_Feedback0_: ctre._ctre.StatusFrame # value = StatusFrame.Status_2_Feedback0_
    Status_4_AinTempVbat_: ctre._ctre.StatusFrame # value = StatusFrame.Status_4_AinTempVbat_
    Status_6_Misc_: ctre._ctre.StatusFrame # value = StatusFrame.Status_6_Misc_
    Status_7_CommStatus_: ctre._ctre.StatusFrame # value = StatusFrame.Status_7_CommStatus_
    Status_9_MotProfBuffer_: ctre._ctre.StatusFrame # value = StatusFrame.Status_9_MotProfBuffer_
    __members__: dict # value = {'Status_1_General_': StatusFrame.Status_1_General_, 'Status_2_Feedback0_': StatusFrame.Status_2_Feedback0_, 'Status_4_AinTempVbat_': StatusFrame.Status_4_AinTempVbat_, 'Status_6_Misc_': StatusFrame.Status_6_Misc_, 'Status_7_CommStatus_': StatusFrame.Status_7_CommStatus_, 'Status_9_MotProfBuffer_': StatusFrame.Status_9_MotProfBuffer_, 'Status_10_MotionMagic_': StatusFrame.Status_10_MotionMagic_, 'Status_10_Targets_': StatusFrame.Status_10_MotionMagic_, 'Status_12_Feedback1_': StatusFrame.Status_12_Feedback1_, 'Status_13_Base_PIDF0_': StatusFrame.Status_13_Base_PIDF0_, 'Status_14_Turn_PIDF1_': StatusFrame.Status_14_Turn_PIDF1_, 'Status_15_FirmareApiStatus_': StatusFrame.Status_15_FirmareApiStatus_, 'Status_17_Targets1_': StatusFrame.Status_17_Targets1_}
    pass
class StatusFrameEnhanced():
    """
    The different status frames available to enhanced motor controllers

    Members:

      Status_1_General : General Status

      Status_2_Feedback0 : Feedback for selected sensor on primary PID[0].

      Status_4_AinTempVbat : Analog sensor, motor controller
    temperature, and voltage at input leads

      Status_6_Misc : Miscellaneous signals

      Status_7_CommStatus : Communication status

      Status_9_MotProfBuffer : Motion profile buffer status

      Status_10_MotionMagic : Old name for Status 10.
    Use @see #Status_10_Targets instead.

      Status_10_Targets : Correct name for Status 10.
    Functionally equivalent to @see #Status_10_MotionMagic

      Status_12_Feedback1 : Feedback for selected sensor on aux PID[1].

      Status_13_Base_PIDF0 : Primary PID

      Status_14_Turn_PIDF1 : Auxiliary PID

      Status_15_FirmareApiStatus : Firmware & API status information

      Status_17_Targets1 : MotionProfile Targets for Auxiliary PID1.

      Status_3_Quadrature : Quadrature sensor

      Status_8_PulseWidth : Pulse width sensor

      Status_11_UartGadgeteer : Gadgeteer status

      Status_Brushless_Current : Brushless Current Status.
    Includes Stator and Supply Current for Talon FX.
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Status_10_MotionMagic: ctre._ctre.StatusFrameEnhanced # value = StatusFrameEnhanced.Status_10_MotionMagic
    Status_10_Targets: ctre._ctre.StatusFrameEnhanced # value = StatusFrameEnhanced.Status_10_MotionMagic
    Status_11_UartGadgeteer: ctre._ctre.StatusFrameEnhanced # value = StatusFrameEnhanced.Status_11_UartGadgeteer
    Status_12_Feedback1: ctre._ctre.StatusFrameEnhanced # value = StatusFrameEnhanced.Status_12_Feedback1
    Status_13_Base_PIDF0: ctre._ctre.StatusFrameEnhanced # value = StatusFrameEnhanced.Status_13_Base_PIDF0
    Status_14_Turn_PIDF1: ctre._ctre.StatusFrameEnhanced # value = StatusFrameEnhanced.Status_14_Turn_PIDF1
    Status_15_FirmareApiStatus: ctre._ctre.StatusFrameEnhanced # value = StatusFrameEnhanced.Status_15_FirmareApiStatus
    Status_17_Targets1: ctre._ctre.StatusFrameEnhanced # value = StatusFrameEnhanced.Status_17_Targets1
    Status_1_General: ctre._ctre.StatusFrameEnhanced # value = StatusFrameEnhanced.Status_1_General
    Status_2_Feedback0: ctre._ctre.StatusFrameEnhanced # value = StatusFrameEnhanced.Status_2_Feedback0
    Status_3_Quadrature: ctre._ctre.StatusFrameEnhanced # value = StatusFrameEnhanced.Status_3_Quadrature
    Status_4_AinTempVbat: ctre._ctre.StatusFrameEnhanced # value = StatusFrameEnhanced.Status_4_AinTempVbat
    Status_6_Misc: ctre._ctre.StatusFrameEnhanced # value = StatusFrameEnhanced.Status_6_Misc
    Status_7_CommStatus: ctre._ctre.StatusFrameEnhanced # value = StatusFrameEnhanced.Status_7_CommStatus
    Status_8_PulseWidth: ctre._ctre.StatusFrameEnhanced # value = StatusFrameEnhanced.Status_8_PulseWidth
    Status_9_MotProfBuffer: ctre._ctre.StatusFrameEnhanced # value = StatusFrameEnhanced.Status_9_MotProfBuffer
    Status_Brushless_Current: ctre._ctre.StatusFrameEnhanced # value = StatusFrameEnhanced.Status_Brushless_Current
    __members__: dict # value = {'Status_1_General': StatusFrameEnhanced.Status_1_General, 'Status_2_Feedback0': StatusFrameEnhanced.Status_2_Feedback0, 'Status_4_AinTempVbat': StatusFrameEnhanced.Status_4_AinTempVbat, 'Status_6_Misc': StatusFrameEnhanced.Status_6_Misc, 'Status_7_CommStatus': StatusFrameEnhanced.Status_7_CommStatus, 'Status_9_MotProfBuffer': StatusFrameEnhanced.Status_9_MotProfBuffer, 'Status_10_MotionMagic': StatusFrameEnhanced.Status_10_MotionMagic, 'Status_10_Targets': StatusFrameEnhanced.Status_10_MotionMagic, 'Status_12_Feedback1': StatusFrameEnhanced.Status_12_Feedback1, 'Status_13_Base_PIDF0': StatusFrameEnhanced.Status_13_Base_PIDF0, 'Status_14_Turn_PIDF1': StatusFrameEnhanced.Status_14_Turn_PIDF1, 'Status_15_FirmareApiStatus': StatusFrameEnhanced.Status_15_FirmareApiStatus, 'Status_17_Targets1': StatusFrameEnhanced.Status_17_Targets1, 'Status_3_Quadrature': StatusFrameEnhanced.Status_3_Quadrature, 'Status_8_PulseWidth': StatusFrameEnhanced.Status_8_PulseWidth, 'Status_11_UartGadgeteer': StatusFrameEnhanced.Status_11_UartGadgeteer, 'Status_Brushless_Current': StatusFrameEnhanced.Status_Brushless_Current}
    pass
class StatusFrameRoutines():
    """
    Class to allow conversion from StatusFrame to EnhancedStatusFrame
    """
    def __init__(self) -> None: ...
    def promote(self, statusFrame: StatusFrame) -> StatusFrameEnhanced: 
        """
        Converts a status frame to an enhanced status frame

        :param statusFrame: frame to convert

        :returns: enhanced status frame version of statusFrame
        """
    pass
class StickyFaults():
    """
    All the sticky faults available to motor controllers
    """
    @typing.overload
    def __init__(self) -> None: 
        """
        Creates fault list with specified bit field of faults

        :param bits: bit field of faults to update with
        """
    @typing.overload
    def __init__(self, bits: int) -> None: ...
    def hasAnyFault(self) -> bool: 
        """
        :returns: true if any faults are tripped
        """
    def toBitfield(self) -> int: 
        """
        :returns: Current fault list as a bit field
        """
    def toString(self) -> str: 
        """
        :returns: string representation of current faults tripped
        """
    @property
    def APIError(self) -> bool:
        """
        Device detects an API error

        :type: bool
        """
    @APIError.setter
    def APIError(self, arg0: bool) -> None:
        """
        Device detects an API error
        """
    @property
    def ForwardLimitSwitch(self) -> bool:
        """
        Forward limit switch is tripped and device is trying to go forward
        Only trips when the device is limited

        :type: bool
        """
    @ForwardLimitSwitch.setter
    def ForwardLimitSwitch(self, arg0: bool) -> None:
        """
        Forward limit switch is tripped and device is trying to go forward
        Only trips when the device is limited
        """
    @property
    def ForwardSoftLimit(self) -> bool:
        """
        Sensor is beyond forward soft limit and device is trying to go forward
        Only trips when the device is limited

        :type: bool
        """
    @ForwardSoftLimit.setter
    def ForwardSoftLimit(self, arg0: bool) -> None:
        """
        Sensor is beyond forward soft limit and device is trying to go forward
        Only trips when the device is limited
        """
    @property
    def HardwareESDReset(self) -> bool:
        """
        Not used, @see #ResetDuringEn

        :type: bool
        """
    @HardwareESDReset.setter
    def HardwareESDReset(self, arg0: bool) -> None:
        """
        Not used, @see #ResetDuringEn
        """
    @property
    def RemoteLossOfSignal(self) -> bool:
        """
        Remote Sensor is no longer detected on bus

        :type: bool
        """
    @RemoteLossOfSignal.setter
    def RemoteLossOfSignal(self, arg0: bool) -> None:
        """
        Remote Sensor is no longer detected on bus
        """
    @property
    def ResetDuringEn(self) -> bool:
        """
        Device was powered-on or reset while robot is enabled.
        Check your breakers and wiring.

        :type: bool
        """
    @ResetDuringEn.setter
    def ResetDuringEn(self, arg0: bool) -> None:
        """
        Device was powered-on or reset while robot is enabled.
        Check your breakers and wiring.
        """
    @property
    def ReverseLimitSwitch(self) -> bool:
        """
        Reverse limit switch is tripped and device is trying to go reverse
        Only trips when the device is limited

        :type: bool
        """
    @ReverseLimitSwitch.setter
    def ReverseLimitSwitch(self, arg0: bool) -> None:
        """
        Reverse limit switch is tripped and device is trying to go reverse
        Only trips when the device is limited
        """
    @property
    def ReverseSoftLimit(self) -> bool:
        """
        Sensor is beyond reverse soft limit and device is trying to go reverse
        Only trips when the device is limited

        :type: bool
        """
    @ReverseSoftLimit.setter
    def ReverseSoftLimit(self, arg0: bool) -> None:
        """
        Sensor is beyond reverse soft limit and device is trying to go reverse
        Only trips when the device is limited
        """
    @property
    def SensorOutOfPhase(self) -> bool:
        """
        Device detects its sensor is out of phase

        :type: bool
        """
    @SensorOutOfPhase.setter
    def SensorOutOfPhase(self, arg0: bool) -> None:
        """
        Device detects its sensor is out of phase
        """
    @property
    def SensorOverflow(self) -> bool:
        """
        Device's sensor overflowed

        :type: bool
        """
    @SensorOverflow.setter
    def SensorOverflow(self, arg0: bool) -> None:
        """
        Device's sensor overflowed
        """
    @property
    def SupplyOverV(self) -> bool:
        """
        Supply is well above the rated voltage of the hardware. This fault is specific to Brushless.

        :type: bool
        """
    @SupplyOverV.setter
    def SupplyOverV(self, arg0: bool) -> None:
        """
        Supply is well above the rated voltage of the hardware. This fault is specific to Brushless.
        """
    @property
    def SupplyUnstable(self) -> bool:
        """
        Supply is rapidly fluctuating and unstable. This fault is specific to Brushless.

        :type: bool
        """
    @SupplyUnstable.setter
    def SupplyUnstable(self, arg0: bool) -> None:
        """
        Supply is rapidly fluctuating and unstable. This fault is specific to Brushless.
        """
    @property
    def UnderVoltage(self) -> bool:
        """
        Motor Controller is under 6.5V

        :type: bool
        """
    @UnderVoltage.setter
    def UnderVoltage(self, arg0: bool) -> None:
        """
        Motor Controller is under 6.5V
        """
    pass
class SupplyCurrentLimitConfiguration():
    """
    Describes the desired stator current limiting behavior.
    """
    @typing.overload
    def __init__(self) -> None: 
        """
        Default c'tor.  Because currentLimit is zero, limiting is disabled.
        """
    @typing.overload
    def __init__(self, doubleArray: float, doubleArraySz: int) -> None: ...
    @typing.overload
    def __init__(self, enable: bool, currentLimit: float, triggerThresholdCurrent: float, triggerThresholdTime: float) -> None: ...
    def deserialize(self, doubles: float, doubleCnt: int) -> None: ...
    def equals(self, rhs: SupplyCurrentLimitConfiguration) -> bool: ...
    def toArray(self) -> typing.List[float]: ...
    def toString(self) -> str: 
        """
        :returns: string representation of current faults tripped
        """
    @property
    def currentLimit(self) -> float:
        """
        The "holding" current (amperes) to limit to when feature is activated.

        :type: float
        """
    @currentLimit.setter
    def currentLimit(self, arg0: float) -> None:
        """
        The "holding" current (amperes) to limit to when feature is activated.
        """
    @property
    def enable(self) -> bool:
        """
        True/False to enable/disable limit feature.

        :type: bool
        """
    @enable.setter
    def enable(self, arg0: bool) -> None:
        """
        True/False to enable/disable limit feature.
        """
    @property
    def triggerThresholdCurrent(self) -> float:
        """
        Current must exceed this threshold (amperes) before limiting occurs.
        If this value is less than currentLimit, then currentLimit is used as the threshold.

        :type: float
        """
    @triggerThresholdCurrent.setter
    def triggerThresholdCurrent(self, arg0: float) -> None:
        """
        Current must exceed this threshold (amperes) before limiting occurs.
        If this value is less than currentLimit, then currentLimit is used as the threshold.
        """
    @property
    def triggerThresholdTime(self) -> float:
        """
        How long current must exceed threshold (seconds) before limiting occurs.

        :type: float
        """
    @triggerThresholdTime.setter
    def triggerThresholdTime(self, arg0: float) -> None:
        """
        How long current must exceed threshold (seconds) before limiting occurs.
        """
    pass
class TalonFX(BaseTalon, BaseMotorController, IMotorControllerEnhanced, IMotorController, IFollower):
    """
    CTRE Talon FX Motor Controller when used on CAN Bus.
    """
    def __init__(self, deviceNumber: int) -> None: 
        """
        Constructor for a Talon

        :param deviceNumber: CAN Device ID of TalonFX
        """
    def configAllSettings(self, allConfigs: TalonFXConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures all persistent settings.

        :param allConfigs: Object with all of the persistant settings

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configGetMotorCommutation(self, motorCommutation: MotorCommutation, timeoutMs: int = 0) -> ErrorCode: 
        """
        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out.

        :returns: The motor commutation type.
        """
    def configGetStatorCurrentLimit(self, currLimitConfigsToFill: StatorCurrentLimitConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Gets the stator (output) current limit configuration.

        :param currLimitConfigsToFill: Configuration object to fill with read values.

        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configGetSupplyCurrentLimit(self, currLimitConfigsToFill: SupplyCurrentLimitConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Gets the supply current limit configuration.

        :param currLimitConfigsToFill: Configuration object to fill with read values.

        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configIntegratedSensorAbsoluteRange(self, absoluteSensorRange: AbsoluteSensorRange, timeoutMs: int = 0) -> ErrorCode: 
        """
        Sets the signage and range of the "Absolute Position" signal.
        Choose unsigned for an absolute range of [0,+1) rotations, [0,360) deg, etc...
        Choose signed for an absolute range of [-0.5,+0.5) rotations, [-180,+180) deg, etc...

        :param absoluteSensorRange: Desired Sign/Range for the absolute position register.

        :param timeoutMs:  Timeout value in ms. If nonzero, function will wait for
                           config success and report an error if it times out.
                           If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configIntegratedSensorInitializationStrategy(self, initializationStrategy: SensorInitializationStrategy, timeoutMs: int = 0) -> ErrorCode: 
        """
        Pick the strategy on how to initialize the integrated sensor absolute position register.  Depending on the mechanism,
        it may be desirable to auto set the Position register to match the Absolute Position (swerve for example).
        Or it may be desired to zero the sensor on boot (drivetrain translation sensor or a relative servo).

        TIP: Tuner's self-test feature will report what the boot sensor value will be in the event the product is reset.

        :param initializationStrategy: The sensor initialization strategy to use.  This will impact the behavior the next time product boots up.

        :param timeoutMs:     Timeout value in ms. If nonzero, function will wait for
                              config success and report an error if it times out.
                              If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configIntegratedSensorOffset(self, offsetDegrees: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Adjusts the zero point for the absolute position register.
        The absolute position of the sensor will always have a discontinuity (360 -> 0 deg) or (+180 -> -180)
        and a hard-limited mechanism may have such a discontinuity in its functional range.
        In which case use this config to move the discontinuity outside of the function range.

        :param offsetDegrees: Offset in degrees (unit string and coefficient DO NOT apply for this config).

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                     config success and report an error if it times out.
                     If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configMotorCommutation(self, motorCommutation: MotorCommutation, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configure the motor commutation type.

        :param motorCommutation: Motor Commutation Type.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                        success and report an error if it times out. If zero, no
                        blocking or checking is performed.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: 
        """
        Select the feedback device for the motor controller.

        :param feedbackDevice: Talon FX Feedback Device to select.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                      config success and report an error if it times out.
                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: TalonFXFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    def configStatorCurrentLimit(self, currLimitConfigs: StatorCurrentLimitConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures the stator (output) current limit.

        :param currLimitCfg: Current limit configuration

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                    config success and report an error if it times out.
                    If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configSupplyCurrentLimit(self, currLimitConfigs: SupplyCurrentLimitConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures the supply-side current limit.

        :param currLimitCfg: Current limit configuration

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                    config success and report an error if it times out.
                    If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configurePID(self, pid: TalonFXPIDSetConfiguration, pidIdx: int = 0, timeoutMs: int = 50) -> ErrorCode: 
        """
        Sets all PID persistant settings.

        :param pid: Object with all of the PID set persistant settings

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.
        """
    def getAllConfigs(self, allConfigs: TalonFXConfiguration, timeoutMs: int = 50) -> None: 
        """
        Gets all persistant settings.

        :param allConfigs: Object with all of the persistant settings

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.
        """
    def getPIDConfigs(self, pid: TalonFXPIDSetConfiguration, pidIdx: int = 0, timeoutMs: int = 50) -> None: 
        """
        Gets all PID set persistant settings.

        :param pid: Object with all of the PID set persistant settings

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.
        """
    def getSensorCollection(self) -> TalonFXSensorCollection: 
        """
        :returns: object that can get/set individual RAW sensor values.
        """
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: 
        """
        Sets the appropriate output on the talon, depending on the mode.

        :param mode: The output mode to apply.
             In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
             In Current mode, output value is in amperes.
             In Velocity mode, output value is in position change / 100ms.
             In Position mode, output value is in encoder ticks or an analog value,
             depending on the sensor.
             In Follower mode, the output value is the integer device ID of the talon to
             duplicate.

        :param value: The setpoint value, as described above.


             Standard Driving Example:
             _talonLeft.set(ControlMode.PercentOutput, leftJoy);
             _talonRght.set(ControlMode.PercentOutput, rghtJoy);



        :param mode: Sets the appropriate output on the talon, depending on the mode.

        :param demand0: The output value to apply.
                   such as advanced feed forward and/or auxiliary close-looping in firmware.
                   In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                   In Current mode, output value is in amperes.
                   In Velocity mode, output value is in position change / 100ms.
                   In Position mode, output value is in encoder ticks or an analog value,
                   depending on the sensor. See
                   In Follower mode, the output value is the integer device ID of the talon to
                   duplicate.

        :param demand1Type: The demand type for demand1.
                   Neutral: Ignore demand1 and apply no change to the demand0 output.
                   AuxPID: Use demand1 to set the target for the auxiliary PID 1.  Auxiliary
                   PID is always executed as standard Position PID control.
                   ArbitraryFeedForward: Use demand1 as an arbitrary additive value to the
                   demand0 output.  In PercentOutput the demand0 output is the motor output,
                   and in closed-loop modes the demand0 output is the output of PID0.

        :param demand1: Supplmental output value.
                   AuxPID: Target position in Sensor Units
                   ArbitraryFeedForward: Percent Output between -1.0 and 1.0


                   Arcade Drive Example:
                   _talonLeft.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, +joyTurn);
                   _talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, -joyTurn);

                   Drive Straight Example:
                   Note: Selected Sensor Configuration is necessary for both PID0 and PID1.
                   _talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
                   _talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.AuxPID, desiredRobotHeading);

                   Drive Straight to a Distance Example:
                   Note: Other configurations (sensor selection, PID gains, etc.) need to be set.
                   _talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
                   _talonRght.set(ControlMode.MotionMagic, targetDistance, DemandType.AuxPID, desiredRobotHeading);
        """
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None: ...
    @typing.overload
    def set(self, mode: TalonFXControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    @typing.overload
    def set(self, mode: TalonFXControlMode, value: float) -> None: ...
    @typing.overload
    def setInverted(self, bInvert: bool) -> None: 
        """
        Inverts the hbridge output of the motor controller in relation to the master if present

        This does not impact sensor phase and should not be used to correct sensor polarity.

        This will allow you to either:
        - Not invert the motor
        - Invert the motor
        - Always follow the master regardless of master's inversion
        - Always oppose the master regardless of master's inversion

        :param invertType: Invert state to set.
        """
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None: ...
    @typing.overload
    def setInverted(self, invertType: TalonFXInvertType) -> None: ...
    pass
class TalonFXConfigUtil():
    """
    Util class to help with talon configs
    """
    def __init__(self) -> None: ...
    @staticmethod
    def absoluteSensorRangeDifferent(settings: TalonFXConfiguration) -> bool: ...
    @staticmethod
    def initializationStrategyDifferent(settings: TalonFXConfiguration) -> bool: ...
    @staticmethod
    def integratedSensorOffsetDegreesDifferent(settings: TalonFXConfiguration) -> bool: ...
    @staticmethod
    def motorCommutationDifferent(settings: TalonFXConfiguration) -> bool: ...
    @staticmethod
    def statorCurrentDurationDifferent(settings: TalonFXConfiguration) -> bool: ...
    @staticmethod
    def supplyCurrentLimitDifferent(settings: TalonFXConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    pass
class TalonFXConfiguration(BaseTalonConfiguration, BaseMotorControllerConfiguration, CustomParamConfiguration):
    """
    Configurables available to TalonFX
    """
    def __init__(self) -> None: ...
    @typing.overload
    def toString(self) -> str: 
        """
        :returns: String representation of all the configs



        :param prependString: String to prepend to all the configs

        :returns: String representation of all the configs
        """
    @typing.overload
    def toString(self, prependString: str) -> str: ...
    @property
    def absoluteSensorRange(self) -> AbsoluteSensorRange:
        """
        Desired Sign / Range for the absolute position register.
        Choose unsigned for an absolute range of[0, +1) rotations, [0, 360) deg, etc.
        Choose signed for an absolute range of[-0.5, +0.5) rotations, [-180, +180) deg, etc.

        :type: AbsoluteSensorRange
        """
    @absoluteSensorRange.setter
    def absoluteSensorRange(self, arg0: AbsoluteSensorRange) -> None:
        """
        Desired Sign / Range for the absolute position register.
        Choose unsigned for an absolute range of[0, +1) rotations, [0, 360) deg, etc.
        Choose signed for an absolute range of[-0.5, +0.5) rotations, [-180, +180) deg, etc.
        """
    @property
    def initializationStrategy(self) -> SensorInitializationStrategy:
        """
        The sensor initialization strategy to use.This will impact the behavior the next time device boots up.

        Pick the strategy on how to initialize the "Position" register.  Depending on the mechanism,
        it may be desirable to auto set the Position register to match the Absolute Position(swerve for example).
        Or it may be desired to zero the sensor on boot(drivetrain translation sensor or a relative servo).

        TIP: Tuner's self-test feature will report what the boot sensor value will be in the event the device is reset.

        :type: SensorInitializationStrategy
        """
    @initializationStrategy.setter
    def initializationStrategy(self, arg0: SensorInitializationStrategy) -> None:
        """
        The sensor initialization strategy to use.This will impact the behavior the next time device boots up.

        Pick the strategy on how to initialize the "Position" register.  Depending on the mechanism,
        it may be desirable to auto set the Position register to match the Absolute Position(swerve for example).
        Or it may be desired to zero the sensor on boot(drivetrain translation sensor or a relative servo).

        TIP: Tuner's self-test feature will report what the boot sensor value will be in the event the device is reset.
        """
    @property
    def integratedSensorOffsetDegrees(self) -> float:
        """
        Adjusts the zero point for the absolute position register.
        The absolute position of the sensor will always have a discontinuity (360 -> 0 deg) or (+180 -> -180)
        and a hard-limited mechanism may have such a discontinuity in its functional range.
        In which case use this config to move the discontinuity outside of the function range.

        :type: float
        """
    @integratedSensorOffsetDegrees.setter
    def integratedSensorOffsetDegrees(self, arg0: float) -> None:
        """
        Adjusts the zero point for the absolute position register.
        The absolute position of the sensor will always have a discontinuity (360 -> 0 deg) or (+180 -> -180)
        and a hard-limited mechanism may have such a discontinuity in its functional range.
        In which case use this config to move the discontinuity outside of the function range.
        """
    @property
    def motorCommutation(self) -> MotorCommutation:
        """
        Choose the type of motor commutation.

        :type: MotorCommutation
        """
    @motorCommutation.setter
    def motorCommutation(self, arg0: MotorCommutation) -> None:
        """
        Choose the type of motor commutation.
        """
    @property
    def statorCurrLimit(self) -> StatorCurrentLimitConfiguration:
        """
        Stator-side current limiting.  This is typically used to limit acceleration/torque and heat generation.

        :type: StatorCurrentLimitConfiguration
        """
    @statorCurrLimit.setter
    def statorCurrLimit(self, arg0: StatorCurrentLimitConfiguration) -> None:
        """
        Stator-side current limiting.  This is typically used to limit acceleration/torque and heat generation.
        """
    @property
    def supplyCurrLimit(self) -> SupplyCurrentLimitConfiguration:
        """
        Supply-side current limiting.  This is typically used to prevent breakers from tripping.

        :type: SupplyCurrentLimitConfiguration
        """
    @supplyCurrLimit.setter
    def supplyCurrLimit(self, arg0: SupplyCurrentLimitConfiguration) -> None:
        """
        Supply-side current limiting.  This is typically used to prevent breakers from tripping.
        """
    pass
class TalonFXControlMode():
    """
    Choose the control mode for a TalonFX / Falcon 500.

    Members:

      PercentOutput : Percent output [-1,1]

      Position : Position closed loop

      Velocity : Velocity closed loop

      Current : Input current closed loop

      Follower : Follow other motor controller

      MotionProfile : Motion Profile

      MotionMagic : Motion Magic

      MotionProfileArc : Motion Profile with auxiliary output

      MusicTone : Plays a single tone.  Frequency (hz) is passed into set.

      Disabled : Disable Motor Controller
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Current: ctre._ctre.TalonFXControlMode # value = TalonFXControlMode.Current
    Disabled: ctre._ctre.TalonFXControlMode # value = TalonFXControlMode.Disabled
    Follower: ctre._ctre.TalonFXControlMode # value = TalonFXControlMode.Follower
    MotionMagic: ctre._ctre.TalonFXControlMode # value = TalonFXControlMode.MotionMagic
    MotionProfile: ctre._ctre.TalonFXControlMode # value = TalonFXControlMode.MotionProfile
    MotionProfileArc: ctre._ctre.TalonFXControlMode # value = TalonFXControlMode.MotionProfileArc
    MusicTone: ctre._ctre.TalonFXControlMode # value = TalonFXControlMode.MusicTone
    PercentOutput: ctre._ctre.TalonFXControlMode # value = TalonFXControlMode.PercentOutput
    Position: ctre._ctre.TalonFXControlMode # value = TalonFXControlMode.Position
    Velocity: ctre._ctre.TalonFXControlMode # value = TalonFXControlMode.Velocity
    __members__: dict # value = {'PercentOutput': TalonFXControlMode.PercentOutput, 'Position': TalonFXControlMode.Position, 'Velocity': TalonFXControlMode.Velocity, 'Current': TalonFXControlMode.Current, 'Follower': TalonFXControlMode.Follower, 'MotionProfile': TalonFXControlMode.MotionProfile, 'MotionMagic': TalonFXControlMode.MotionMagic, 'MotionProfileArc': TalonFXControlMode.MotionProfileArc, 'MusicTone': TalonFXControlMode.MusicTone, 'Disabled': TalonFXControlMode.Disabled}
    pass
class TalonFXFeedbackDevice():
    """
    Choose the feedback device for a Talon FX/Falcon 500.

    Members:

      IntegratedSensor : TalonFX supports an integrated sensor.

      SensorSum : Sum0 + Sum1

      SensorDifference : Diff0 - Diff1

      RemoteSensor0 : Sensor configured in RemoteFilter0

      RemoteSensor1 : Sensor configured in RemoteFilter1

      None_ : Position and velocity will read 0.

      SoftwareEmulatedSensor : Motor Controller will fake a sensor based on applied motor output.
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    IntegratedSensor: ctre._ctre.TalonFXFeedbackDevice # value = TalonFXFeedbackDevice.IntegratedSensor
    None_: ctre._ctre.TalonFXFeedbackDevice # value = TalonFXFeedbackDevice.None_
    RemoteSensor0: ctre._ctre.TalonFXFeedbackDevice # value = TalonFXFeedbackDevice.RemoteSensor0
    RemoteSensor1: ctre._ctre.TalonFXFeedbackDevice # value = TalonFXFeedbackDevice.RemoteSensor1
    SensorDifference: ctre._ctre.TalonFXFeedbackDevice # value = TalonFXFeedbackDevice.SensorDifference
    SensorSum: ctre._ctre.TalonFXFeedbackDevice # value = TalonFXFeedbackDevice.SensorSum
    SoftwareEmulatedSensor: ctre._ctre.TalonFXFeedbackDevice # value = TalonFXFeedbackDevice.SoftwareEmulatedSensor
    __members__: dict # value = {'IntegratedSensor': TalonFXFeedbackDevice.IntegratedSensor, 'SensorSum': TalonFXFeedbackDevice.SensorSum, 'SensorDifference': TalonFXFeedbackDevice.SensorDifference, 'RemoteSensor0': TalonFXFeedbackDevice.RemoteSensor0, 'RemoteSensor1': TalonFXFeedbackDevice.RemoteSensor1, 'None_': TalonFXFeedbackDevice.None_, 'SoftwareEmulatedSensor': TalonFXFeedbackDevice.SoftwareEmulatedSensor}
    pass
class TalonFXInvertType():
    """
    Choose the invert type for a Talon FX based integrated motor controller.
    CCW is the equivalent of SetInverted(false), CW is the equivalent of SetInverted(true).
    FollowMaster/OpposeMaster will match/oppose a master Talon/Victor.  This requires device to be configured as a follower.

    Members:

      CounterClockwise : //!< Same as SetInverted(false)

      Clockwise : //!< Same as SetInverted(true)

      FollowMaster : //!< Follow the invert of the master this MC is following.

      OpposeMaster : //!< Opposite of the invert of the master this MC is following.
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Clockwise: ctre._ctre.TalonFXInvertType # value = TalonFXInvertType.Clockwise
    CounterClockwise: ctre._ctre.TalonFXInvertType # value = TalonFXInvertType.CounterClockwise
    FollowMaster: ctre._ctre.TalonFXInvertType # value = TalonFXInvertType.FollowMaster
    OpposeMaster: ctre._ctre.TalonFXInvertType # value = TalonFXInvertType.OpposeMaster
    __members__: dict # value = {'CounterClockwise': TalonFXInvertType.CounterClockwise, 'Clockwise': TalonFXInvertType.Clockwise, 'FollowMaster': TalonFXInvertType.FollowMaster, 'OpposeMaster': TalonFXInvertType.OpposeMaster}
    pass
class TalonFXPIDSetConfiguration(BaseTalonPIDSetConfiguration, BasePIDSetConfiguration):
    """
    Configurables available to TalonFX's PID
    """
    def __init__(self, defaultFeedbackDevice: FeedbackDevice) -> None: ...
    pass
class TalonFXSensorCollection():
    """
    Collection of sensors available to the Talon FX.

    For best performance and update-rate,
    we recommend using the configSelectedFeedbackSensor() and getSelectedSensor*() routines.
    However there are occasions where accessing raw sensor values may be useful or convenient.
    Particularly if you are seeding one sensor based on another, or need to circumvent sensor-phase.

    Use the GetTalonFXSensorCollection() routine inside your motor controller to create a sensor collection.
    """
    def __init__(self, motorController: BaseTalon) -> None: 
        """
        Constructor for TalonFXSensorCollection

        :param motorController: Talon Motor Controller to connect Collection to
        """
    def getIntegratedSensorAbsolutePosition(self) -> float: 
        """
        Get the IntegratedSensor absolute position of the Talon FX, regardless of whether
        it is actually being used for feedback.  This will be within one rotation (2048 units).
        The signage and range will depend on the configuration.
        Note : Future versions of software may support scaling features (rotations, radians, degrees, etc) depending on the configuration.

        :returns: the IntegratedSensor absolute position.
        """
    def getIntegratedSensorPosition(self) -> float: ...
    def getIntegratedSensorVelocity(self) -> float: 
        """
        Get the IntegratedSensor velocity of the Talon FX, regardless of whether
        it is actually being used for feedback.
        One unit represents one position unit per 100ms (2048 position units per 100ms).
        The signage and range will depend on the configuration.
        Note : Future versions of software may support scaling features (rotations, radians, degrees, etc) depending on the configuration.

        :returns: the IntegratedSensor velocity.
        """
    def isFwdLimitSwitchClosed(self) -> int: ...
    def isRevLimitSwitchClosed(self) -> int: ...
    def setIntegratedSensorPosition(self, newPosition: float, timeoutMs: int = 0) -> ErrorCode: 
        """
        Set the IntegratedSensor reported position.  Typically this is used to "zero" the
        sensor. This only works with IntegratedSensor.  To set the selected sensor position
        regardless of what type it is, see SetSelectedSensorPosition in the motor controller class.

        :param newPosition: The position value to apply to the sensor.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                   config success and report an error if it times out.
                   If zero, no blocking or checking is performed.

        :returns: error code.
        """
    def setIntegratedSensorPositionToAbsolute(self, timeoutMs: int = 0) -> ErrorCode: 
        """
        Set the IntegratedSensor reported position based on the absolute position.
        This can also be done automatically on power boot depending on configuration.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.

        :returns: error code.
        """
    pass
class TalonSRX(BaseTalon, BaseMotorController, IMotorControllerEnhanced, IMotorController, IFollower):
    """
    CTRE Talon SRX Motor Controller when used on CAN Bus.
    """
    def __init__(self, deviceNumber: int) -> None: 
        """
        Constructor for a Talon

        :param deviceNumber: CAN Device ID of TalonSRX
        """
    def configAllSettings(self, allConfigs: TalonSRXConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures all persistent settings.

        :param allConfigs: Object with all of the persistant settings

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configContinuousCurrentLimit(self, amps: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configure the continuous allowable current-draw (when current limit is
        enabled).

        Supply current limiting is also available via ConfigSupplyCurrentLimit(),
        which is a common routine with Talon FX.

        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.

        For simpler current-limiting (single threshold) use
        ConfigContinuousCurrentLimit() and set the peak to zero:
        ConfigPeakCurrentLimit(0).

        :param amps: Amperes to limit.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.
        """
    def configPeakCurrentDuration(self, milliseconds: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configure the peak allowable duration (when current limit is enabled).

        Supply current limiting is also available via ConfigSupplyCurrentLimit(),
        which is a common routine with Talon FX.

        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.

        For simpler current-limiting (single threshold) use
        ConfigContinuousCurrentLimit() and set the peak to zero:
        ConfigPeakCurrentLimit(0).

        :param milliseconds: How long to allow current-draw past peak limit.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                    success and report an error if it times out. If zero, no
                    blocking or checking is performed.
        """
    def configPeakCurrentLimit(self, amps: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Configure the peak allowable current (when current limit is enabled).

        Supply current limiting is also available via ConfigSupplyCurrentLimit(),
        which is a common routine with Talon FX.

        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.

        For simpler current-limiting (single threshold) use
        ConfigContinuousCurrentLimit() and set the peak to zero:
        ConfigPeakCurrentLimit(0).

        :param amps: Amperes to limit.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for config
                 success and report an error if it times out. If zero, no
                 blocking or checking is performed.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int, timeoutMs: int = 0) -> ErrorCode: 
        """
        Select the feedback device for the motor controller.

        :param feedbackDevice: Talon SRX Feedback Device to select.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                      config success and report an error if it times out.
                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Select the feedback device for the motor controller.

        :param feedbackDevice: Feedback Device to select.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                      config success and report an error if it times out.
                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.

        Select the remote feedback device for the motor controller.
        Most CTRE CAN motor controllers will support remote sensors over CAN.

        :param feedbackDevice: Remote Feedback Device to select.

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                      config success and report an error if it times out.
                      If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int, timeoutMs: int) -> ErrorCode: ...
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: TalonSRXFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    def configSupplyCurrentLimit(self, currLimitConfigs: SupplyCurrentLimitConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures the supply (input) current limit.

        :param currLimitConfigs: Current limit configuration

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                        config success and report an error if it times out.
                        If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def configurePID(self, pid: TalonSRXPIDSetConfiguration, pidIdx: int = 0, timeoutMs: int = 50) -> ErrorCode: 
        """
        Sets all PID persistant settings.

        :param pid: Object with all of the PID set persistant settings

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.
        """
    def enableCurrentLimit(self, enable: bool) -> None: 
        """
        Enable or disable Current Limit.

        Supply current limiting is also available via ConfigSupplyCurrentLimit(),
        which is a common routine with Talon FX.

        :param enable: Enable state of current limit.
              @see configPeakCurrentLimit()
              @see configPeakCurrentDuration()
              @see configContinuousCurrentLimit()
        """
    def getAllConfigs(self, allConfigs: TalonSRXConfiguration, timeoutMs: int = 50) -> None: 
        """
        Gets all persistant settings.

        :param allConfigs: Object with all of the persistant settings

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.
        """
    def getPIDConfigs(self, pid: TalonSRXPIDSetConfiguration, pidIdx: int = 0, timeoutMs: int = 50) -> None: 
        """
        Gets all PID set persistant settings.

        :param pid: Object with all of the PID set persistant settings

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.
        """
    def getSensorCollection(self) -> SensorCollection: 
        """
        :returns: object that can get/set individual RAW sensor values.
        """
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: 
        """
        Sets the appropriate output on the talon, depending on the mode.

        :param mode: The output mode to apply.
             In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
             In Current mode, output value is in amperes.
             In Velocity mode, output value is in position change / 100ms.
             In Position mode, output value is in encoder ticks or an analog value,
             depending on the sensor.
             In Follower mode, the output value is the integer device ID of the talon to
             duplicate.

        :param value: The setpoint value, as described above.


             Standard Driving Example:
             _talonLeft.set(ControlMode.PercentOutput, leftJoy);
             _talonRght.set(ControlMode.PercentOutput, rghtJoy);



        :param mode: Sets the appropriate output on the talon, depending on the mode.

        :param demand0: The output value to apply.
                   such as advanced feed forward and/or auxiliary close-looping in firmware.
                   In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                   In Current mode, output value is in amperes.
                   In Velocity mode, output value is in position change / 100ms.
                   In Position mode, output value is in encoder ticks or an analog value,
                   depending on the sensor. See
                   In Follower mode, the output value is the integer device ID of the talon to
                   duplicate.

        :param demand1Type: The demand type for demand1.
                   Neutral: Ignore demand1 and apply no change to the demand0 output.
                   AuxPID: Use demand1 to set the target for the auxiliary PID 1.  Auxiliary
                   PID is always executed as standard Position PID control.
                   ArbitraryFeedForward: Use demand1 as an arbitrary additive value to the
                   demand0 output.  In PercentOutput the demand0 output is the motor output,
                   and in closed-loop modes the demand0 output is the output of PID0.

        :param demand1: Supplmental output value.
                   AuxPID: Target position in Sensor Units
                   ArbitraryFeedForward: Percent Output between -1.0 and 1.0


                   Arcade Drive Example:
                   _talonLeft.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, +joyTurn);
                   _talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, -joyTurn);

                   Drive Straight Example:
                   Note: Selected Sensor Configuration is necessary for both PID0 and PID1.
                   _talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
                   _talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.AuxPID, desiredRobotHeading);

                   Drive Straight to a Distance Example:
                   Note: Other configurations (sensor selection, PID gains, etc.) need to be set.
                   _talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
                   _talonRght.set(ControlMode.MotionMagic, targetDistance, DemandType.AuxPID, desiredRobotHeading);
        """
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None: ...
    @typing.overload
    def set(self, mode: TalonSRXControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    @typing.overload
    def set(self, mode: TalonSRXControlMode, value: float) -> None: ...
    pass
class TalonSRXConfigUtil():
    """
    Util class to help with talon configs
    """
    def __init__(self) -> None: ...
    @staticmethod
    def continuousCurrentLimitDifferent(settings: TalonSRXConfiguration) -> bool: ...
    @staticmethod
    def peakCurrentDurationDifferent(settings: TalonSRXConfiguration) -> bool: ...
    @staticmethod
    def peakCurrentLimitDifferent(settings: TalonSRXConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    pass
class TalonSRXConfiguration(BaseTalonConfiguration, BaseMotorControllerConfiguration, CustomParamConfiguration):
    """
    Configurables available to TalonSRX
    """
    def __init__(self) -> None: ...
    @typing.overload
    def toString(self) -> str: 
        """
        :returns: String representation of all the configs



        :param prependString: String to prepend to all the configs

        :returns: String representation of all the configs
        """
    @typing.overload
    def toString(self, prependString: str) -> str: ...
    @property
    def continuousCurrentLimit(self) -> int:
        """
        Continuous current in amps

        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.

        :type: int
        """
    @continuousCurrentLimit.setter
    def continuousCurrentLimit(self, arg0: int) -> None:
        """
        Continuous current in amps

        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.
        """
    @property
    def peakCurrentDuration(self) -> int:
        """
        Peak Current duration in milliseconds

        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.

        :type: int
        """
    @peakCurrentDuration.setter
    def peakCurrentDuration(self, arg0: int) -> None:
        """
        Peak Current duration in milliseconds

        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.
        """
    @property
    def peakCurrentLimit(self) -> int:
        """
        Peak current in amps

        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.

        :type: int
        """
    @peakCurrentLimit.setter
    def peakCurrentLimit(self, arg0: int) -> None:
        """
        Peak current in amps

        Current limit is activated when current exceeds the peak limit for longer
        than the peak duration. Then software will limit to the continuous limit.
        This ensures current limiting while allowing for momentary excess current
        events.
        """
    pass
class TalonSRXControlMode():
    """
    Choose the control mode for a Talon SRX.

    Members:

      PercentOutput : Percent output [-1,1]

      Position : Position closed loop

      Velocity : Velocity closed loop

      Current : Input current closed loop

      Follower : Follow other motor controller

      MotionProfile : Motion Profile

      MotionMagic : Motion Magic

      MotionProfileArc : Motion Profile with auxiliary output

      Disabled : Disable Motor Controller
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Current: ctre._ctre.TalonSRXControlMode # value = TalonSRXControlMode.Current
    Disabled: ctre._ctre.TalonSRXControlMode # value = TalonSRXControlMode.Disabled
    Follower: ctre._ctre.TalonSRXControlMode # value = TalonSRXControlMode.Follower
    MotionMagic: ctre._ctre.TalonSRXControlMode # value = TalonSRXControlMode.MotionMagic
    MotionProfile: ctre._ctre.TalonSRXControlMode # value = TalonSRXControlMode.MotionProfile
    MotionProfileArc: ctre._ctre.TalonSRXControlMode # value = TalonSRXControlMode.MotionProfileArc
    PercentOutput: ctre._ctre.TalonSRXControlMode # value = TalonSRXControlMode.PercentOutput
    Position: ctre._ctre.TalonSRXControlMode # value = TalonSRXControlMode.Position
    Velocity: ctre._ctre.TalonSRXControlMode # value = TalonSRXControlMode.Velocity
    __members__: dict # value = {'PercentOutput': TalonSRXControlMode.PercentOutput, 'Position': TalonSRXControlMode.Position, 'Velocity': TalonSRXControlMode.Velocity, 'Current': TalonSRXControlMode.Current, 'Follower': TalonSRXControlMode.Follower, 'MotionProfile': TalonSRXControlMode.MotionProfile, 'MotionMagic': TalonSRXControlMode.MotionMagic, 'MotionProfileArc': TalonSRXControlMode.MotionProfileArc, 'Disabled': TalonSRXControlMode.Disabled}
    pass
class TalonSRXFeedbackDevice():
    """
    Choose the feedback device for a Talon SRX

    Members:

      QuadEncoder : Quadrature encoder

      Analog : Analog potentiometer/encoder

      Tachometer : Tachometer

      PulseWidthEncodedPosition : CTRE Mag Encoder in Relative mode or
    any other device that uses PWM to encode its output

      SensorSum : Sum0 + Sum1

      SensorDifference : Diff0 - Diff1

      RemoteSensor0 : Sensor configured in RemoteFilter0

      RemoteSensor1 : Sensor configured in RemoteFilter1

      None_ : Position and velocity will read 0.

      SoftwareEmulatedSensor : Motor Controller will fake a sensor based on applied motor output.

      CTRE_MagEncoder_Absolute : CTR mag encoder configured in absolute, is the same
    as a PWM sensor.

      CTRE_MagEncoder_Relative : CTR mag encoder configured in relative, is the same
    as an quadrature encoder sensor.
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Analog: ctre._ctre.TalonSRXFeedbackDevice # value = TalonSRXFeedbackDevice.Analog
    CTRE_MagEncoder_Absolute: ctre._ctre.TalonSRXFeedbackDevice # value = TalonSRXFeedbackDevice.PulseWidthEncodedPosition
    CTRE_MagEncoder_Relative: ctre._ctre.TalonSRXFeedbackDevice # value = TalonSRXFeedbackDevice.QuadEncoder
    None_: ctre._ctre.TalonSRXFeedbackDevice # value = TalonSRXFeedbackDevice.None_
    PulseWidthEncodedPosition: ctre._ctre.TalonSRXFeedbackDevice # value = TalonSRXFeedbackDevice.PulseWidthEncodedPosition
    QuadEncoder: ctre._ctre.TalonSRXFeedbackDevice # value = TalonSRXFeedbackDevice.QuadEncoder
    RemoteSensor0: ctre._ctre.TalonSRXFeedbackDevice # value = TalonSRXFeedbackDevice.RemoteSensor0
    RemoteSensor1: ctre._ctre.TalonSRXFeedbackDevice # value = TalonSRXFeedbackDevice.RemoteSensor1
    SensorDifference: ctre._ctre.TalonSRXFeedbackDevice # value = TalonSRXFeedbackDevice.SensorDifference
    SensorSum: ctre._ctre.TalonSRXFeedbackDevice # value = TalonSRXFeedbackDevice.SensorSum
    SoftwareEmulatedSensor: ctre._ctre.TalonSRXFeedbackDevice # value = TalonSRXFeedbackDevice.SoftwareEmulatedSensor
    Tachometer: ctre._ctre.TalonSRXFeedbackDevice # value = TalonSRXFeedbackDevice.Tachometer
    __members__: dict # value = {'QuadEncoder': TalonSRXFeedbackDevice.QuadEncoder, 'Analog': TalonSRXFeedbackDevice.Analog, 'Tachometer': TalonSRXFeedbackDevice.Tachometer, 'PulseWidthEncodedPosition': TalonSRXFeedbackDevice.PulseWidthEncodedPosition, 'SensorSum': TalonSRXFeedbackDevice.SensorSum, 'SensorDifference': TalonSRXFeedbackDevice.SensorDifference, 'RemoteSensor0': TalonSRXFeedbackDevice.RemoteSensor0, 'RemoteSensor1': TalonSRXFeedbackDevice.RemoteSensor1, 'None_': TalonSRXFeedbackDevice.None_, 'SoftwareEmulatedSensor': TalonSRXFeedbackDevice.SoftwareEmulatedSensor, 'CTRE_MagEncoder_Absolute': TalonSRXFeedbackDevice.PulseWidthEncodedPosition, 'CTRE_MagEncoder_Relative': TalonSRXFeedbackDevice.QuadEncoder}
    pass
class TalonSRXPIDSetConfiguration(BaseTalonPIDSetConfiguration, BasePIDSetConfiguration):
    """
    Configurables available to TalonSRX's PID
    """
    def __init__(self, defaultFeedbackDevice: FeedbackDevice) -> None: ...
    pass
class TrajectoryPoint():
    """
    Motion Profile Trajectory Point
    This is simply a data transfer object.
    """
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, position: float, velocity: float, arbFeedFwd: float, auxiliaryPos: float, auxiliaryVel: float, auxiliaryArbFeedFwd: float, profileSlotSelect0: int, profileSlotSelect1: int, isLastPoint: bool, zeroPos: bool, timeDur: int, useAuxPID: bool) -> None: ...
    @property
    def arbFeedFwd(self) -> float:
        """
        Added to the output of PID[0], should be within [-1,+1] where 0.01 = 1%.

        :type: float
        """
    @arbFeedFwd.setter
    def arbFeedFwd(self, arg0: float) -> None:
        """
        Added to the output of PID[0], should be within [-1,+1] where 0.01 = 1%.
        """
    @property
    def auxiliaryArbFeedFwd(self) -> float:
        """
        Added to the output of PID[1], should be within [-1,+1] where 0.01 = 1%.

        :type: float
        """
    @auxiliaryArbFeedFwd.setter
    def auxiliaryArbFeedFwd(self, arg0: float) -> None:
        """
        Added to the output of PID[1], should be within [-1,+1] where 0.01 = 1%.
        """
    @property
    def auxiliaryPos(self) -> float:
        """
        The position for auxiliary PID[1] to target (in sensor units).

        :type: float
        """
    @auxiliaryPos.setter
    def auxiliaryPos(self, arg0: float) -> None:
        """
        The position for auxiliary PID[1] to target (in sensor units).
        """
    @property
    def auxiliaryVel(self) -> float:
        """
        The velocity for auxiliary PID[1] to target. (in sensor-units per 100ms).

        :type: float
        """
    @auxiliaryVel.setter
    def auxiliaryVel(self, arg0: float) -> None:
        """
        The velocity for auxiliary PID[1] to target. (in sensor-units per 100ms).
        """
    @property
    def headingDeg(self) -> float:
        """
        Not used.  Use auxiliaryPos instead.  @see auxiliaryPos

        :type: float
        """
    @headingDeg.setter
    def headingDeg(self, arg0: float) -> None:
        """
        Not used.  Use auxiliaryPos instead.  @see auxiliaryPos
        """
    @property
    def isLastPoint(self) -> bool:
        """
        Set to true to signal Talon that this is the final point, so do not
        attempt to pop another trajectory point from out of the Talon buffer.
        Instead continue processing this way point.  Typically the velocity
        member variable should be zero so that the motor doesn't spin indefinitely.

        :type: bool
        """
    @isLastPoint.setter
    def isLastPoint(self, arg0: bool) -> None:
        """
        Set to true to signal Talon that this is the final point, so do not
        attempt to pop another trajectory point from out of the Talon buffer.
        Instead continue processing this way point.  Typically the velocity
        member variable should be zero so that the motor doesn't spin indefinitely.
        """
    @property
    def position(self) -> float:
        """
        The position to servo to (in sensor units).

        :type: float
        """
    @position.setter
    def position(self, arg0: float) -> None:
        """
        The position to servo to (in sensor units).
        """
    @property
    def profileSlotSelect0(self) -> int:
        """
        Which slot to get PIDF gains.
        PID is used for position servo.
        F is used as the Kv constant for velocity feed-forward.
        Typically this is hard-coded
        to a particular slot, but you are free to gain schedule if need be.
        gain schedule if need be.
        Choose from [0,3].

        :type: int
        """
    @profileSlotSelect0.setter
    def profileSlotSelect0(self, arg0: int) -> None:
        """
        Which slot to get PIDF gains.
        PID is used for position servo.
        F is used as the Kv constant for velocity feed-forward.
        Typically this is hard-coded
        to a particular slot, but you are free to gain schedule if need be.
        gain schedule if need be.
        Choose from [0,3].
        """
    @property
    def profileSlotSelect1(self) -> int:
        """
        Which slot to get PIDF gains for auxiliary PID.
        This only has impact during MotionProfileArc Control mode.
        Choose from [0,3].

        :type: int
        """
    @profileSlotSelect1.setter
    def profileSlotSelect1(self, arg0: int) -> None:
        """
        Which slot to get PIDF gains for auxiliary PID.
        This only has impact during MotionProfileArc Control mode.
        Choose from [0,3].
        """
    @property
    def timeDur(self) -> int:
        """
        :type: int
        """
    @timeDur.setter
    def timeDur(self, arg0: int) -> None:
        pass
    @property
    def useAuxPID(self) -> bool:
        """
        If using MotionProfileArc, this flag must be true on all points.
        If using MotionProfile, this flag must be false on all points.

        :type: bool
        """
    @useAuxPID.setter
    def useAuxPID(self, arg0: bool) -> None:
        """
        If using MotionProfileArc, this flag must be true on all points.
        If using MotionProfile, this flag must be false on all points.
        """
    @property
    def velocity(self) -> float:
        """
        The velocity to feed-forward (in sensor-units per 100ms).

        :type: float
        """
    @velocity.setter
    def velocity(self, arg0: float) -> None:
        """
        The velocity to feed-forward (in sensor-units per 100ms).
        """
    @property
    def zeroPos(self) -> bool:
        """
        Set to true to signal Talon to zero the selected sensor.
        When generating MPs, one simple method is to make the first target position zero,
        and the final target position the target distance from the current position.
        Then when you fire the MP, the current position gets set to zero.
        If this is the intent, you can set zeroPos on the first trajectory point.

        Otherwise you can leave this false for all points, and offset the positions
        of all trajectory points so they are correct.

        If using multiple sensor sources (Arc modes) we recommend you manually set sensor positions
        before arming MP.

        :type: bool
        """
    @zeroPos.setter
    def zeroPos(self, arg0: bool) -> None:
        """
        Set to true to signal Talon to zero the selected sensor.
        When generating MPs, one simple method is to make the first target position zero,
        and the final target position the target distance from the current position.
        Then when you fire the MP, the current position gets set to zero.
        If this is the intent, you can set zeroPos on the first trajectory point.

        Otherwise you can leave this false for all points, and offset the positions
        of all trajectory points so they are correct.

        If using multiple sensor sources (Arc modes) we recommend you manually set sensor positions
        before arming MP.
        """
    pass
class VelocityMeasPeriod():
    """
    Velocity Measurement Periods

    Members:

      Period_1Ms : 1ms measurement period

      Period_2Ms : 2ms measurement period

      Period_5Ms : 5ms measurement period

      Period_10Ms : 10ms measurement period

      Period_20Ms : 20ms measurement period

      Period_25Ms : 25ms measurement period

      Period_50Ms : 50ms measurement period

      Period_100Ms : 100ms measurement period
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Period_100Ms: ctre._ctre.VelocityMeasPeriod # value = VelocityMeasPeriod.Period_100Ms
    Period_10Ms: ctre._ctre.VelocityMeasPeriod # value = VelocityMeasPeriod.Period_10Ms
    Period_1Ms: ctre._ctre.VelocityMeasPeriod # value = VelocityMeasPeriod.Period_1Ms
    Period_20Ms: ctre._ctre.VelocityMeasPeriod # value = VelocityMeasPeriod.Period_20Ms
    Period_25Ms: ctre._ctre.VelocityMeasPeriod # value = VelocityMeasPeriod.Period_25Ms
    Period_2Ms: ctre._ctre.VelocityMeasPeriod # value = VelocityMeasPeriod.Period_2Ms
    Period_50Ms: ctre._ctre.VelocityMeasPeriod # value = VelocityMeasPeriod.Period_50Ms
    Period_5Ms: ctre._ctre.VelocityMeasPeriod # value = VelocityMeasPeriod.Period_5Ms
    __members__: dict # value = {'Period_1Ms': VelocityMeasPeriod.Period_1Ms, 'Period_2Ms': VelocityMeasPeriod.Period_2Ms, 'Period_5Ms': VelocityMeasPeriod.Period_5Ms, 'Period_10Ms': VelocityMeasPeriod.Period_10Ms, 'Period_20Ms': VelocityMeasPeriod.Period_20Ms, 'Period_25Ms': VelocityMeasPeriod.Period_25Ms, 'Period_50Ms': VelocityMeasPeriod.Period_50Ms, 'Period_100Ms': VelocityMeasPeriod.Period_100Ms}
    pass
class VelocityMeasPeriodRoutines():
    """
    Class to handle routines specific to VelocityMeasPeriod
    """
    def __init__(self) -> None: ...
    @staticmethod
    def toString(value: VelocityMeasPeriod) -> str: 
        """
        String representation of specified VelocityMeasPeriod

        :param value: VelocityMeasPeriod to convert to a string

        :returns: string representation of VelocityMeasPeriod
        """
    pass
class VictorConfigUtil():
    """
    Util class to help with VictorSPX configs
    """
    def __init__(self) -> None: ...
    @staticmethod
    def diff0TermDifferent(settings: VictorSPXConfiguration) -> bool: ...
    @staticmethod
    def diff1TermDifferent(settings: VictorSPXConfiguration) -> bool: ...
    @staticmethod
    def forwardLimitSwitchDeviceIDDifferent(settings: VictorSPXConfiguration) -> bool: ...
    @staticmethod
    def forwardLimitSwitchDifferent(settings: VictorSPXConfiguration) -> bool: ...
    @staticmethod
    def forwardLimitSwitchNormalDifferent(settings: VictorSPXConfiguration) -> bool: ...
    @staticmethod
    def forwardLimitSwitchSourceDifferent(settings: VictorSPXConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    @staticmethod
    def reverseLimitSwitchDeviceIDDifferent(settings: VictorSPXConfiguration) -> bool: ...
    @staticmethod
    def reverseLimitSwitchDifferent(settings: VictorSPXConfiguration) -> bool: ...
    @staticmethod
    def reverseLimitSwitchNormalDifferent(settings: VictorSPXConfiguration) -> bool: ...
    @staticmethod
    def reverseLimitSwitchSourceDifferent(settings: VictorSPXConfiguration) -> bool: ...
    @staticmethod
    def sum0TermDifferent(settings: VictorSPXConfiguration) -> bool: ...
    @staticmethod
    def sum1TermDifferent(settings: VictorSPXConfiguration) -> bool: ...
    pass
class VictorSPX(BaseMotorController, IMotorController, IFollower):
    """
    VEX Victor SPX Motor Controller when used on CAN Bus.
    """
    def __init__(self, deviceNumber: int) -> None: 
        """
        Constructor

        :param deviceNumber: [0,62]
        """
    def configAllSettings(self, allConfigs: VictorSPXConfiguration, timeoutMs: int = 50) -> ErrorCode: 
        """
        Configures all persistent settings.

        :param allConfigs: Object with all of the persistant settings

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.

        :returns: Error Code generated by function. 0 indicates no error.
        """
    def getAllConfigs(self, allConfigs: VictorSPXConfiguration, timeoutMs: int = 50) -> None: 
        """
        Gets all persistant settings.

        :param allConfigs: Object with all of the persistant settings

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                  config success and report an error if it times out.
                  If zero, no blocking or checking is performed.
        """
    def getPIDConfigs(self, pid: VictorSPXPIDSetConfiguration, pidIdx: int = 0, timeoutMs: int = 50) -> None: 
        """
        Gets all PID set persistant settings.

        :param pid: Object with all of the PID set persistant settings

        :param pidIdx: 0 for Primary closed-loop. 1 for auxiliary closed-loop.

        :param timeoutMs: Timeout value in ms. If nonzero, function will wait for
                 config success and report an error if it times out.
                 If zero, no blocking or checking is performed.
        """
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: 
        """
        Sets the appropriate output on the motor controller, depending on the mode.

        :param mode: The output mode to apply.
             In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
             In Velocity mode, output value is in position change / 100ms.
             In Position mode, output value is in encoder ticks or an analog value,
             depending on the sensor.
             In Follower mode, the output value is the integer device ID of the motor controller to
             duplicate.

        :param value: The setpoint value, as described above.


             Standard Driving Example:
             victorLeft.set(ControlMode.PercentOutput, leftJoy);
             victorRght.set(ControlMode.PercentOutput, rghtJoy);



        :param mode: Sets the appropriate output on the motor controller, depending on the mode.

        :param demand0: The output value to apply.
                   such as advanced feed forward and/or auxiliary close-looping in firmware.
                   In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                   In Velocity mode, output value is in position change / 100ms.
                   In Position mode, output value is in encoder ticks or an analog value,
                   depending on the sensor. See
                   In Follower mode, the output value is the integer device ID of the motor controller to
                   duplicate.

        :param demand1Type: The demand type for demand1.
                   Neutral: Ignore demand1 and apply no change to the demand0 output.
                   AuxPID: Use demand1 to set the target for the auxiliary PID 1.  Auxiliary
                   PID is always executed as standard Position PID control.
                   ArbitraryFeedForward: Use demand1 as an arbitrary additive value to the
                   demand0 output.  In PercentOutput the demand0 output is the motor output,
                   and in closed-loop modes the demand0 output is the output of PID0.

        :param demand1: Supplmental output value.
                   AuxPID: Target position in Sensor Units
                   ArbitraryFeedForward: Percent Output between -1.0 and 1.0


                   Arcade Drive Example:
                   _victorLeft.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, +joyTurn);
                   _victorRght.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, -joyTurn);

                   Drive Straight Example:
                   Note: Selected Sensor Configuration is necessary for both PID0 and PID1.
                   _victorLeft.follow(_victorRght, FollwerType.AuxOutput1);
                   _victorRght.set(ControlMode.PercentOutput, joyForward, DemandType.AuxPID, desiredRobotHeading);

                   Drive Straight to a Distance Example:
                   Note: Other configurations (sensor selection, PID gains, etc.) need to be set.
                   _victorLeft.follow(_victorRght, FollwerType.AuxOutput1);
                   _victorRght.set(ControlMode.MotionMagic, targetDistance, DemandType.AuxPID, desiredRobotHeading);
        """
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None: ...
    @typing.overload
    def set(self, mode: VictorSPXControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    @typing.overload
    def set(self, mode: VictorSPXControlMode, value: float) -> None: ...
    pass
class VictorSPXConfiguration(BaseMotorControllerConfiguration, CustomParamConfiguration):
    """
    Configurables available to VictorSPX
    """
    def __init__(self) -> None: ...
    @typing.overload
    def toString(self) -> str: 
        """
        :returns: String representation of all the configs



        :param prependString: String to prepend to all the configs

        :returns: String representation of all the configs
        """
    @typing.overload
    def toString(self, prependString: str) -> str: ...
    @property
    def auxiliaryPID(self) -> VictorSPXPIDSetConfiguration:
        """
        Auxiliary PID configuration

        :type: VictorSPXPIDSetConfiguration
        """
    @auxiliaryPID.setter
    def auxiliaryPID(self, arg0: VictorSPXPIDSetConfiguration) -> None:
        """
        Auxiliary PID configuration
        """
    @property
    def diff0Term(self) -> RemoteFeedbackDevice:
        """
        Feedback Device for Diff 0 Term

        :type: RemoteFeedbackDevice
        """
    @diff0Term.setter
    def diff0Term(self, arg0: RemoteFeedbackDevice) -> None:
        """
        Feedback Device for Diff 0 Term
        """
    @property
    def diff1Term(self) -> RemoteFeedbackDevice:
        """
        Feedback Device for Diff 1 Term

        :type: RemoteFeedbackDevice
        """
    @diff1Term.setter
    def diff1Term(self, arg0: RemoteFeedbackDevice) -> None:
        """
        Feedback Device for Diff 1 Term
        """
    @property
    def forwardLimitSwitchDeviceID(self) -> int:
        """
        Forward limit switch device ID

        Limit Switch device id isn't used unless device is a remote

        :type: int
        """
    @forwardLimitSwitchDeviceID.setter
    def forwardLimitSwitchDeviceID(self, arg0: int) -> None:
        """
        Forward limit switch device ID

        Limit Switch device id isn't used unless device is a remote
        """
    @property
    def forwardLimitSwitchNormal(self) -> LimitSwitchNormal:
        """
        Forward limit switch normally open/closed

        :type: LimitSwitchNormal
        """
    @forwardLimitSwitchNormal.setter
    def forwardLimitSwitchNormal(self, arg0: LimitSwitchNormal) -> None:
        """
        Forward limit switch normally open/closed
        """
    @property
    def forwardLimitSwitchSource(self) -> RemoteLimitSwitchSource:
        """
        Forward Limit Switch Source

        User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature

        :type: RemoteLimitSwitchSource
        """
    @forwardLimitSwitchSource.setter
    def forwardLimitSwitchSource(self, arg0: RemoteLimitSwitchSource) -> None:
        """
        Forward Limit Switch Source

        User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature
        """
    @property
    def primaryPID(self) -> VictorSPXPIDSetConfiguration:
        """
        Primary PID configuration

        :type: VictorSPXPIDSetConfiguration
        """
    @primaryPID.setter
    def primaryPID(self, arg0: VictorSPXPIDSetConfiguration) -> None:
        """
        Primary PID configuration
        """
    @property
    def reverseLimitSwitchDeviceID(self) -> int:
        """
        Reverse limit switch device ID

        Limit Switch device id isn't used unless device is a remote

        :type: int
        """
    @reverseLimitSwitchDeviceID.setter
    def reverseLimitSwitchDeviceID(self, arg0: int) -> None:
        """
        Reverse limit switch device ID

        Limit Switch device id isn't used unless device is a remote
        """
    @property
    def reverseLimitSwitchNormal(self) -> LimitSwitchNormal:
        """
        Reverse limit switch normally open/closed

        :type: LimitSwitchNormal
        """
    @reverseLimitSwitchNormal.setter
    def reverseLimitSwitchNormal(self, arg0: LimitSwitchNormal) -> None:
        """
        Reverse limit switch normally open/closed
        """
    @property
    def reverseLimitSwitchSource(self) -> RemoteLimitSwitchSource:
        """
        Reverse Limit Switch Source

        User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature

        :type: RemoteLimitSwitchSource
        """
    @reverseLimitSwitchSource.setter
    def reverseLimitSwitchSource(self, arg0: RemoteLimitSwitchSource) -> None:
        """
        Reverse Limit Switch Source

        User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature
        """
    @property
    def sum0Term(self) -> RemoteFeedbackDevice:
        """
        Feedback Device for Sum 0 Term

        :type: RemoteFeedbackDevice
        """
    @sum0Term.setter
    def sum0Term(self, arg0: RemoteFeedbackDevice) -> None:
        """
        Feedback Device for Sum 0 Term
        """
    @property
    def sum1Term(self) -> RemoteFeedbackDevice:
        """
        Feedback Device for Sum 1 Term

        :type: RemoteFeedbackDevice
        """
    @sum1Term.setter
    def sum1Term(self, arg0: RemoteFeedbackDevice) -> None:
        """
        Feedback Device for Sum 1 Term
        """
    pass
class VictorSPXControlMode():
    """
    Choose the control mode for a Victor SPX.

    Members:

      PercentOutput : Percent output [-1,1]

      Position : Position closed loop

      Velocity : Velocity closed loop

      Follower : Follow other motor controller

      MotionProfile : Motion Profile

      MotionMagic : Motion Magic

      MotionProfileArc : Motion Profile with auxiliary output

      Disabled : Disable Motor Controller
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, arg0: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: int) -> None: ...
    @property
    def name(self) -> None:
        """
        :type: None
        """
    Disabled: ctre._ctre.VictorSPXControlMode # value = VictorSPXControlMode.Disabled
    Follower: ctre._ctre.VictorSPXControlMode # value = VictorSPXControlMode.Follower
    MotionMagic: ctre._ctre.VictorSPXControlMode # value = VictorSPXControlMode.MotionMagic
    MotionProfile: ctre._ctre.VictorSPXControlMode # value = VictorSPXControlMode.MotionProfile
    MotionProfileArc: ctre._ctre.VictorSPXControlMode # value = VictorSPXControlMode.MotionProfileArc
    PercentOutput: ctre._ctre.VictorSPXControlMode # value = VictorSPXControlMode.PercentOutput
    Position: ctre._ctre.VictorSPXControlMode # value = VictorSPXControlMode.Position
    Velocity: ctre._ctre.VictorSPXControlMode # value = VictorSPXControlMode.Velocity
    __members__: dict # value = {'PercentOutput': VictorSPXControlMode.PercentOutput, 'Position': VictorSPXControlMode.Position, 'Velocity': VictorSPXControlMode.Velocity, 'Follower': VictorSPXControlMode.Follower, 'MotionProfile': VictorSPXControlMode.MotionProfile, 'MotionMagic': VictorSPXControlMode.MotionMagic, 'MotionProfileArc': VictorSPXControlMode.MotionProfileArc, 'Disabled': VictorSPXControlMode.Disabled}
    pass
class VictorSPXPIDSetConfigUtil():
    """
    Util class to help with VictorSPX's PID configs
    """
    def __init__(self) -> None: ...
    @staticmethod
    def selectedFeedbackCoefficientDifferent(settings: VictorSPXPIDSetConfiguration) -> bool: ...
    @staticmethod
    def selectedFeedbackSensorDifferent(settings: VictorSPXPIDSetConfiguration) -> bool: 
        """
        Determine if specified value is different from default

        :param settings: settings to compare against

        :returns: if specified value is different from default
                  @{
        """
    pass
class VictorSPXPIDSetConfiguration(BasePIDSetConfiguration):
    """
    Configurables available to VictorSPX's PID
    """
    def __init__(self) -> None: ...
    @typing.overload
    def toString(self) -> str: 
        """
        :returns: String representation of all the configs



        :param prependString: String to prepend to all the configs

        :returns: String representation of all the configs
        """
    @typing.overload
    def toString(self, prependString: str) -> str: ...
    @property
    def selectedFeedbackSensor(self) -> RemoteFeedbackDevice:
        """
        Feedback device for a particular PID loop.

        :type: RemoteFeedbackDevice
        """
    @selectedFeedbackSensor.setter
    def selectedFeedbackSensor(self, arg0: RemoteFeedbackDevice) -> None:
        """
        Feedback device for a particular PID loop.
        """
    pass
class WPI_BaseMotorController(BaseMotorController, IMotorController, IFollower, wpilib.interfaces._interfaces.SpeedController, wpilib.interfaces._interfaces.PIDOutput, wpilib._wpilib.SendableBase, wpilib._wpilib.Sendable):
    """
    VEX Victor SPX Motor Controller when used on CAN Bus.
    """
    def PIDWrite(self, output: float) -> None: 
        """
        Special write for PID, same functionality as calling set

        :param output: Output to send to motor
        """
    def disable(self) -> None: 
        """
        Common interface for disabling a motor.
        """
    def feed(self) -> None: 
        """
        Feed the motor safety object.

        Resets the timer on this object that is used to do the timeouts.
        """
    def get(self) -> float: 
        """
        Common interface for getting the current set speed of a speed controller.

        :returns: The current set speed.  Value is between -1.0 and 1.0.
        """
    def getDescription(self) -> str: 
        """
        :returns: description of controller
        """
    def getExpiration(self) -> float: 
        """
        Retrieve the timeout value for the corresponding motor safety object.

        :returns: the timeout value in seconds.
        """
    def getInverted(self) -> bool: 
        """
        Common interface for returning the inversion state of a speed controller.

        :returns: isInverted The state of inversion, true is inverted.
        """
    def getMotorSafety(self) -> wpilib._wpilib.MotorSafety: 
        """
        :returns: the Motor Safety object corresponding to this device.
        """
    def isAlive(self) -> bool: 
        """
        Determine if the motor is still operating or has timed out.

        :returns: true if the motor is still operating normally and hasn't timed out.
        """
    def isSafetyEnabled(self) -> bool: 
        """
        Return the state of the motor safety enabled flag.

        Return if the motor safety is currently enabled for this device.

        :returns: True if motor safety is enforced for this device.
        """
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1: float) -> None: 
        """
        Common interface for setting the speed of a simple speed controller.

        :param speed: The speed to set.  Value should be between -1.0 and 1.0.
             Value is also saved for Get().

        Sets the appropriate output on the talon, depending on the mode.

        :param mode: The output mode to apply.
             In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
             In Current mode, output value is in amperes.
             In Velocity mode, output value is in position change / 100ms.
             In Position mode, output value is in encoder ticks or an analog value,
             depending on the sensor.
             In Follower mode, the output value is the integer device ID of the talon to
             duplicate.

        :param value: The setpoint value, as described above.


             Standard Driving Example:
             _talonLeft.set(ControlMode.PercentOutput, leftJoy);
             _talonRght.set(ControlMode.PercentOutput, rghtJoy);

        @deprecated use 4 parameter set

        :param mode: Sets the appropriate output on the talon, depending on the mode.

        :param demand0: The output value to apply.
               such as advanced feed forward and/or auxiliary close-looping in firmware.
               In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
               In Current mode, output value is in amperes.
               In Velocity mode, output value is in position change / 100ms.
               In Position mode, output value is in encoder ticks or an analog value,
               depending on the sensor. See
               In Follower mode, the output value is the integer device ID of the talon to
               duplicate.

        :param demand1: Supplemental value.  This will also be control mode specific for future features.



        :param mode: Sets the appropriate output on the talon, depending on the mode.

        :param demand0: The output value to apply.
                   such as advanced feed forward and/or auxiliary close-looping in firmware.
                   In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
                   In Current mode, output value is in amperes.
                   In Velocity mode, output value is in position change / 100ms.
                   In Position mode, output value is in encoder ticks or an analog value,
                   depending on the sensor. See
                   In Follower mode, the output value is the integer device ID of the talon to
                   duplicate.

        :param demand1Type: The demand type for demand1.
                   Neutral: Ignore demand1 and apply no change to the demand0 output.
                   AuxPID: Use demand1 to set the target for the auxiliary PID 1.
                   ArbitraryFeedForward: Use demand1 as an arbitrary additive value to the
                   demand0 output.  In PercentOutput the demand0 output is the motor output,
                   and in closed-loop modes the demand0 output is the output of PID0.

        :param demand1: Supplmental output value.  Units match the set mode.


                   Arcade Drive Example:
                   _talonLeft.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, +joyTurn);
                   _talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, -joyTurn);

                   Drive Straight Example:
                   Note: Selected Sensor Configuration is necessary for both PID0 and PID1.
                   _talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
                   _talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.AuxPID, desiredRobotHeading);

                   Drive Straight to a Distance Example:
                   Note: Other configurations (sensor selection, PID gains, etc.) need to be set.
                   _talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
                   _talonRght.set(ControlMode.MotionMagic, targetDistance, DemandType.AuxPID, desiredRobotHeading);
        """
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None: ...
    @typing.overload
    def set(self, speed: float) -> None: ...
    def setExpiration(self, expirationTime: float) -> None: 
        """
        Set the expiration time for the corresponding motor safety object.

        :param expirationTime: The timeout value in seconds.
        """
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None: 
        """
        Common interface for inverting direction of a speed controller.

        :param isInverted: The state of inversion, true is inverted.

        Common interface for inverting direction of a speed controller.

        :param invertType: The invert strategy to use. Follower controllers
                  that mirror/oppose the master controller should
                  use this method.
        """
    @typing.overload
    def setInverted(self, isInverted: bool) -> None: ...
    def setSafetyEnabled(self, enabled: bool) -> None: 
        """
        Enable/disable motor safety for this device.

        Turn on and off the motor safety option for this PWM object.

        :param enabled: True if motor safety is enforced for this object.
        """
    def setVoltage(self, output: volts) -> None: 
        """
        Sets the voltage output of the SpeedController.  Compensates for
        the current bus voltage to ensure that the desired voltage is output even
        if the battery voltage is below 12V - highly useful when the voltage
        outputs are "meaningful" (e.g. they come from a feedforward calculation).

        NOTE: This function *must* be called regularly in order for voltage
        compensation to work properly - unlike the ordinary set function, it is not
        "set it and forget it."

        :param output: The voltage to output.
        """
    def stopMotor(self) -> None: 
        """
        Common interface to stop the motor until Set is called again.
        """
    pass
class WPI_TalonFX(TalonFX, BaseTalon, WPI_BaseMotorController, BaseMotorController, IMotorControllerEnhanced, IMotorController, IFollower, wpilib.interfaces._interfaces.SpeedController, wpilib.interfaces._interfaces.PIDOutput, wpilib._wpilib.SendableBase, wpilib._wpilib.Sendable):
    """
    CTRE Talon SRX Motor Controller when used on CAN Bus.
    """
    def __init__(self, deviceNumber: int) -> None: 
        """
        Constructor for a WPI_TalonFX

        :param deviceNumber: Device ID of TalonFX
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None: ...
    @typing.overload
    def set(self, mode: TalonFXControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    @typing.overload
    def set(self, mode: TalonFXControlMode, value: float) -> None: ...
    @typing.overload
    def set(self, value: float) -> None: ...
    @typing.overload
    def setInverted(self, bInvert: bool) -> None: ...
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None: ...
    @typing.overload
    def setInverted(self, invertType: TalonFXInvertType) -> None: ...
    def setVoltage(self, output: volts) -> None: ...
    pass
class WPI_TalonSRX(TalonSRX, BaseTalon, WPI_BaseMotorController, BaseMotorController, IMotorControllerEnhanced, IMotorController, IFollower, wpilib.interfaces._interfaces.SpeedController, wpilib.interfaces._interfaces.PIDOutput, wpilib._wpilib.SendableBase, wpilib._wpilib.Sendable):
    """
    CTRE Talon SRX Motor Controller when used on CAN Bus.
    """
    def __init__(self, deviceNumber: int) -> None: 
        """
        Constructor for a WPI_TalonSRX

        :param deviceNumber: Device ID of TalonSRX
        """
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: FeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None: ...
    @typing.overload
    def set(self, mode: TalonSRXControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    @typing.overload
    def set(self, mode: TalonSRXControlMode, value: float) -> None: ...
    @typing.overload
    def set(self, value: float) -> None: ...
    @typing.overload
    def setInverted(self, bInvert: bool) -> None: ...
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None: ...
    def setVoltage(self, output: volts) -> None: ...
    pass
class WPI_VictorSPX(VictorSPX, WPI_BaseMotorController, BaseMotorController, IMotorController, IFollower, wpilib.interfaces._interfaces.SpeedController, wpilib.interfaces._interfaces.PIDOutput, wpilib._wpilib.SendableBase, wpilib._wpilib.Sendable):
    """
    VEX Victor SPX Motor Controller when used on CAN Bus.
    """
    def __init__(self, deviceNumber: int) -> None: 
        """
        Constructor for a WPI_VictorSPX

        :param deviceNumber: Device ID of VictorSPX
        """
    def configSelectedFeedbackSensor(self, feedbackDevice: RemoteFeedbackDevice, pidIdx: int = 0, timeoutMs: int = 0) -> ErrorCode: ...
    @typing.overload
    def set(self, mode: ControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    @typing.overload
    def set(self, mode: ControlMode, value: float) -> None: ...
    @typing.overload
    def set(self, mode: VictorSPXControlMode, demand0: float, demand1Type: DemandType, demand1: float) -> None: ...
    @typing.overload
    def set(self, mode: VictorSPXControlMode, value: float) -> None: ...
    @typing.overload
    def set(self, value: float) -> None: ...
    @typing.overload
    def setInverted(self, bInvert: bool) -> None: ...
    @typing.overload
    def setInverted(self, invertType: InvertType) -> None: ...
    def setVoltage(self, output: volts) -> None: ...
    pass
